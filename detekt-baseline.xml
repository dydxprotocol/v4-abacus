<?xml version="1.0" ?>
<SmellBaseline>
  <ManuallySuppressedIssues></ManuallySuppressedIssues>
  <CurrentIssues>
    <ID>ComplexCondition:Account.kt$Subaccount.Companion$existing?.positionId != positionId || existing?.pnlTotal != pnlTotal || existing?.pnl24h != pnl24h || existing?.pnl24hPercent != pnl24hPercent || existing?.quoteBalance !== quoteBalance || existing.notionalTotal !== notionalTotal || existing.valueTotal !== valueTotal || existing.initialRiskTotal !== initialRiskTotal || existing.adjustedImf !== adjustedImf || existing.equity !== equity || existing.freeCollateral !== freeCollateral || existing.leverage !== leverage || existing.marginUsage !== marginUsage || existing.buyingPower !== buyingPower || existing.openPositions != openPositions || existing.pendingPositions != pendingPositions || existing.orders != orders || existing.marginEnabled != marginEnabled</ID>
    <ID>ComplexCondition:Account.kt$SubaccountFill.Companion$existing?.id != id || existing.marketId != marketId || existing.orderId != orderId || existing.side !== side || existing.type !== type || existing.liquidity !== liquidity || existing.price != price || existing.fee != fee || existing.createdAtMilliseconds != createdAtMilliseconds || existing.resources !== resources</ID>
    <ID>ComplexCondition:Account.kt$SubaccountFill.Companion$id != null &amp;&amp; marketId != null &amp;&amp; side != null &amp;&amp; type != null &amp;&amp; liquidity != null &amp;&amp; price != null &amp;&amp; size != null &amp;&amp; createdAtMilliseconds != null &amp;&amp; resources != null</ID>
    <ID>ComplexCondition:Account.kt$SubaccountFillResources.Companion$existing?.sideStringKey != sideStringKey || existing?.liquidityStringKey != liquidityStringKey || existing?.typeStringKey != typeStringKey || existing?.iconLocal != iconLocal</ID>
    <ID>ComplexCondition:Account.kt$SubaccountFundingPayment.Companion$existing?.marketId != marketId || existing.payment != payment || existing.rate != rate || existing.positionSize != positionSize || existing.price != price || existing.effectiveAtMilliSeconds != effectiveAtMilliSeconds</ID>
    <ID>ComplexCondition:Account.kt$SubaccountFundingPayment.Companion$marketId != null &amp;&amp; payment != null &amp;&amp; rate != null &amp;&amp; positionSize != null &amp;&amp; effectiveAtMilliSeconds != null</ID>
    <ID>ComplexCondition:Account.kt$SubaccountHistoricalPNL.Companion$equity != null &amp;&amp; totalPnl != null &amp;&amp; netTransfers != null &amp;&amp; createdAtMilliseconds != null</ID>
    <ID>ComplexCondition:Account.kt$SubaccountHistoricalPNL.Companion$existing?.equity != equity || existing.totalPnl != totalPnl || existing.netTransfers != netTransfers || existing.createdAtMilliseconds != createdAtMilliseconds</ID>
    <ID>ComplexCondition:Account.kt$SubaccountOrder.Companion$existing?.subaccountNumber != subaccountNumber || existing.id != id || existing.clientId != clientId || existing.type !== type || existing.side !== side || existing.status !== status || existing.timeInForce !== timeInForce || existing.marketId != marketId || existing.clobPairId != clobPairId || existing.orderFlags != orderFlags || existing.price != price || existing.triggerPrice != triggerPrice || existing.trailingPercent != trailingPercent || existing.size != size || existing.remainingSize != remainingSize || existing.totalFilled != totalFilled || existing.goodTilBlock != goodTilBlock || existing.goodTilBlockTime != goodTilBlockTime || existing.createdAtMilliseconds != createdAtMilliseconds || existing.unfillableAtMilliseconds != unfillableAtMilliseconds || existing.expiresAtMilliseconds != expiresAtMilliseconds || existing.updatedAtMilliseconds != updatedAtMilliseconds || existing.postOnly != postOnly || existing.reduceOnly != reduceOnly || existing.cancelReason != cancelReason || existing.resources !== resources</ID>
    <ID>ComplexCondition:Account.kt$SubaccountOrder.Companion$id != null &amp;&amp; marketId != null &amp;&amp; type != null &amp;&amp; side != null &amp;&amp; status != null &amp;&amp; price != null &amp;&amp; size != null &amp;&amp; resources != null</ID>
    <ID>ComplexCondition:Account.kt$SubaccountOrderResources.Companion$existing?.sideStringKey != sideStringKey || existing.typeStringKey != typeStringKey || existing.statusStringKey != statusStringKey || existing.timeInForceStringKey != timeInForceStringKey</ID>
    <ID>ComplexCondition:Account.kt$SubaccountPendingPosition.Companion$existing?.assetId != assetId || existing.firstOrderId != firstOrderId || existing.orderCount != orderCount || existing.freeCollateral !== freeCollateral || existing.quoteBalance !== quoteBalance || existing.equity !== equity</ID>
    <ID>ComplexCondition:Account.kt$SubaccountPosition.Companion$existing?.id != id || existing.assetId != assetId || existing.entryPrice !== entryPrice || existing.exitPrice != exitPrice || existing.createdAtMilliseconds != createdAtMilliseconds || existing.closedAtMilliseconds != closedAtMilliseconds || existing.netFunding != netFunding || existing.realizedPnl !== realizedPnl || existing.realizedPnlPercent !== realizedPnlPercent || existing.unrealizedPnl !== unrealizedPnl || existing.unrealizedPnlPercent !== unrealizedPnlPercent || existing.size !== size || existing.notionalTotal !== notionalTotal || existing.valueTotal !== valueTotal || existing.initialRiskTotal !== initialRiskTotal || existing.adjustedImf !== adjustedImf || existing.adjustedMmf !== adjustedMmf || existing.leverage !== leverage || existing.maxLeverage !== maxLeverage || existing.buyingPower !== buyingPower || existing.liquidationPrice !== liquidationPrice || existing.resources !== resources || existing.childSubaccountNumber !== childSubaccountNumber || existing.freeCollateral !== freeCollateral || existing.quoteBalance !== quoteBalance || existing.equity !== equity</ID>
    <ID>ComplexCondition:Account.kt$SubaccountTransfer.Companion$existing?.id != id || existing.type !== type || existing.asset != asset || existing.amount != amount || existing.updatedAtBlock != updatedAtBlock || existing.updatedAtMilliseconds != updatedAtMilliseconds || existing.fromAddress != fromAddress || existing.toAddress != toAddress || existing.transactionHash != transactionHash || existing.resources !== resources</ID>
    <ID>ComplexCondition:Account.kt$SubaccountTransferResources.Companion$existing?.typeStringKey != typeStringKey || existing?.blockExplorerUrl != blockExplorerUrl || existing?.statusStringKey != statusStringKey || existing?.iconLocal != iconLocal || existing?.indicator != indicator</ID>
    <ID>ComplexCondition:Account.kt$TradeStatesWithPositionSides.Companion$existing == null || existing.current !== current || existing.postOrder !== postOrder || existing.postAllOrders !== postAllOrders</ID>
    <ID>ComplexCondition:AccountSupervisor.kt$AccountSupervisor$url != null &amp;&amp; fromChain != null &amp;&amp; fromToken != null &amp;&amp; nobleAddress != null &amp;&amp; chainId != null &amp;&amp; dydxTokenDemon != null &amp;&amp; squidIntegratorId != null</ID>
    <ID>ComplexCondition:Asset.kt$Asset.Companion$existing?.id != id || existing.name != name || existing.tags != tags || existing.resources !== resources</ID>
    <ID>ComplexCondition:Asset.kt$AssetResources.Companion$existing?.websiteLink != websiteLink || existing?.whitepaperLink != whitepaperLink || existing?.coinMarketCapsLink != coinMarketCapsLink || existing?.imageUrl != imageUrl || existing?.primaryDescriptionKey != primaryDescriptionKey || existing?.secondaryDescriptionKey != secondaryDescriptionKey</ID>
    <ID>ComplexCondition:BaseProcessor.kt$BaseProcessor$firstIncomingTime != null &amp;&amp; lastExisting != null &amp;&amp; firstIncomingTime != lastExisting &amp;&amp; ascending( firstIncomingTime, lastExisting, ) != ascending</ID>
    <ID>ComplexCondition:BaseProcessor.kt$BaseProcessor$lastIncomingTime != null &amp;&amp; firstExisting != null &amp;&amp; lastIncomingTime != firstExisting &amp;&amp; ascending( lastIncomingTime, firstExisting, ) == ascending</ID>
    <ID>ComplexCondition:ClosePositionInput.kt$ClosePositionInput.Companion$existing?.type !== type || existing?.side !== side || existing?.marketId != marketId || existing?.size !== size || existing?.price !== price || existing?.fee != fee || existing?.marketOrder !== marketOrder || existing?.summary !== summary</ID>
    <ID>ComplexCondition:ClosePositionInput.kt$ClosePositionInputSize.Companion$existing?.size != size || existing?.usdcSize != usdcSize || existing?.percent != percent || existing?.input != input</ID>
    <ID>ComplexCondition:Configs.kt$FeeDiscount.Companion$existing?.id != id || existing.tier != tier || existing.symbol != symbol || existing.balance != balance || existing.discount != discount || existing.resources !== resources</ID>
    <ID>ComplexCondition:Configs.kt$FeeDiscount.Companion$id != null &amp;&amp; tier != null &amp;&amp; symbol != null &amp;&amp; balance != null</ID>
    <ID>ComplexCondition:Configs.kt$FeeTier.Companion$existing?.id != id || existing.tier != tier || existing.symbol != symbol || existing.volume != volume || existing.makerShare != makerShare || existing.totalShare != totalShare || existing.maker != maker || existing.taker != taker || existing.resources !== resources</ID>
    <ID>ComplexCondition:Configs.kt$FeeTier.Companion$id != null &amp;&amp; tier != null &amp;&amp; symbol != null &amp;&amp; volume != null</ID>
    <ID>ComplexCondition:ConnectionStats.kt$ConnectionStats$apiState?.status != status || apiState.height != block || apiState.haltedBlock != haltedBlock || apiState.trailingBlocks != blockDiff</ID>
    <ID>ComplexCondition:Input.kt$Input.Companion$existing?.current !== current || existing?.trade !== trade || existing?.closePosition !== closePosition || existing?.transfer !== transfer || existing?.triggerOrders !== triggerOrders || existing?.receiptLines != receiptLines || existing?.errors != errors</ID>
    <ID>ComplexCondition:Market.kt$MarketCandle.Companion$existing?.startedAtMilliseconds != startedAtMilliseconds || existing.trades != trades || existing.updatedAtMilliseconds != updatedAtMilliseconds || existing.low != low || existing.high != high || existing.open != open || existing.close != close || existing.baseTokenVolume != baseTokenVolume || existing.usdVolume != usdVolume</ID>
    <ID>ComplexCondition:Market.kt$MarketCandle.Companion$startedAtMilliseconds != null &amp;&amp; low != null &amp;&amp; high != null &amp;&amp; open != null &amp;&amp; close != null &amp;&amp; baseTokenVolume != null &amp;&amp; usdVolume != null</ID>
    <ID>ComplexCondition:Market.kt$MarketConfigs.Companion$existing == null || existing.largeSize != largeSize || existing.stepSize != stepSize || existing.tickSize != tickSize || existing.displayStepSize != displayStepSize || existing.displayTickSize != displayTickSize || existing.minOrderSize != minOrderSize || existing.initialMarginFraction != initialMarginFraction || existing.maintenanceMarginFraction != maintenanceMarginFraction || existing.incrementalInitialMarginFraction != incrementalInitialMarginFraction || existing.incrementalPositionSize != incrementalPositionSize || existing.maxPositionSize != maxPositionSize || existing.baselinePositionSize != baselinePositionSize || existing.basePositionNotional != basePositionNotional || existing.candleOptions != candleOptions || existing.perpetualMarketType != perpetualMarketType || existing.v4 != v4</ID>
    <ID>ComplexCondition:Market.kt$MarketConfigsV4.Companion$existing == null || existing.clobPairId != clobPairId || existing.atomicResolution != atomicResolution || existing.stepBaseQuantums != stepBaseQuantums || existing.quantumConversionExponent != quantumConversionExponent || existing.subticksPerTick != subticksPerTick</ID>
    <ID>ComplexCondition:Market.kt$MarketOrderbook.Companion$existing?.midPrice != midPrice || existing?.spreadPercent != spreadPercent || existing?.grouping !== grouping || existing?.asks != asks || existing?.bids != bids</ID>
    <ID>ComplexCondition:Market.kt$MarketPerpetual.Companion$existing?.openInterest != openInterest || existing.openInterestUSDC != openInterestUSDC || existing.volume24H != volume24H || existing.trades24H != trades24H || existing.nextFundingRate != nextFundingRate || existing.nextFundingAtMilliseconds != nextFundingAtMilliseconds || existing.line != line</ID>
    <ID>ComplexCondition:Market.kt$MarketTrade.Companion$existing?.id != id || existing?.size != size || existing.side !== side || existing.price != price || existing.type != type || existing.createdAtMilliseconds != createdAtMilliseconds || existing.resources !== resources</ID>
    <ID>ComplexCondition:Market.kt$MarketTrade.Companion$size != null &amp;&amp; price != null &amp;&amp; createdAtMilliseconds != null &amp;&amp; resources != null</ID>
    <ID>ComplexCondition:Market.kt$OrderbookLine.Companion$existing?.size != size || existing.price != price || existing.offset != offset || existing.depth != depth || existing.depthCost != depthCost</ID>
    <ID>ComplexCondition:OnboardingSupervisor.kt$OnboardingSupervisor$fromChain != null &amp;&amp; fromToken != null &amp;&amp; fromAmount != null &amp;&amp; fromAmount &gt; 0 &amp;&amp; fromAmountString != null &amp;&amp; chainId != null &amp;&amp; dydxTokenDemon != null &amp;&amp; url != null &amp;&amp; squidIntegratorId != null</ID>
    <ID>ComplexCondition:OnboardingSupervisor.kt$OnboardingSupervisor$fromChain != null &amp;&amp; fromToken != null &amp;&amp; fromAmount != null &amp;&amp; fromAmount &gt; 0 &amp;&amp; fromAmountString != null &amp;&amp; nobleAddress != null &amp;&amp; chainId != null &amp;&amp; dydxTokenDemon != null &amp;&amp; url != null &amp;&amp; squidIntegratorId != null &amp;&amp; toChain != null &amp;&amp; toToken != null</ID>
    <ID>ComplexCondition:OnboardingSupervisor.kt$OnboardingSupervisor$name != null &amp;&amp; label != null &amp;&amp; icon != null &amp;&amp; depositType != null</ID>
    <ID>ComplexCondition:OnboardingSupervisor.kt$OnboardingSupervisor$nobleChain != null &amp;&amp; nobleToken != null &amp;&amp; toAddress != null &amp;&amp; fromAmount != null &amp;&amp; fromAmount &gt; 0 &amp;&amp; fromAmountString != null &amp;&amp; chainId != null &amp;&amp; dydxTokenDemon != null &amp;&amp; url != null &amp;&amp; squidIntegratorId != null</ID>
    <ID>ComplexCondition:OnboardingSupervisor.kt$OnboardingSupervisor$toChain != null &amp;&amp; toToken != null &amp;&amp; toAddress != null &amp;&amp; fromAmount != null &amp;&amp; fromAmount &gt; 0 &amp;&amp; fromAmountString != null &amp;&amp; chainId != null &amp;&amp; dydxTokenDemon != null &amp;&amp; url != null &amp;&amp; fromAddress != null &amp;&amp; squidIntegratorId != null &amp;&amp; fromChain != null &amp;&amp; fromToken != null</ID>
    <ID>ComplexCondition:OnboardingSupervisor.kt$OnboardingSupervisor$toChain != null &amp;&amp; toToken != null &amp;&amp; toAddress != null &amp;&amp; fromAmount != null &amp;&amp; fromAmount &gt; 0 &amp;&amp; fromAmountString != null &amp;&amp; chainId != null &amp;&amp; dydxTokenDemon != null &amp;&amp; url != null &amp;&amp; squidIntegratorId != null</ID>
    <ID>ComplexCondition:OnboardingSupervisor.kt$OnboardingSupervisor$type == TransferInputField.usdcSize || type == TransferInputField.address || type == TransferInputField.chain || type == TransferInputField.exchange || type == TransferInputField.token</ID>
    <ID>ComplexCondition:OnboardingSupervisor.kt$OnboardingSupervisor$type == TransferInputField.usdcSize || type == TransferInputField.size || type == TransferInputField.token || type == TransferInputField.address</ID>
    <ID>ComplexCondition:OnboardingSupervisor.kt$OnboardingSupervisor$url != null &amp;&amp; fromChain != null &amp;&amp; fromToken != null &amp;&amp; nobleAddress != null &amp;&amp; chainId != null &amp;&amp; dydxTokenDemon != null &amp;&amp; squidIntegratorId != null</ID>
    <ID>ComplexCondition:OnboardingSupervisor.kt$OnboardingSupervisor$url != null &amp;&amp; nobleChain != null &amp;&amp; nobleToken != null &amp;&amp; nobleAddress != null &amp;&amp; chainId != null &amp;&amp; dydxTokenDemon != null &amp;&amp; squidIntegratorId != null &amp;&amp; fromAmountString != null &amp;&amp; fromAmount != null &amp;&amp; fromAmount &gt; 0</ID>
    <ID>ComplexCondition:OrderbookEntryProcessor.kt$OrderbookEntryProcessor$(offset == null &amp;&amp; size &gt; 0.0) || (offset != null &amp;&amp; offset &gt; oldOffset)</ID>
    <ID>ComplexCondition:OrderbookProcessor.kt$OrderbookProcessor$asks != null &amp;&amp; bids != null &amp;&amp; asks.size &gt; 0 &amp;&amp; bids.size &gt; 0</ID>
    <ID>ComplexCondition:Parser.kt$Parser$string == "n" || string == "0" || string == "false" || string == "no" || string == "off"</ID>
    <ID>ComplexCondition:Parser.kt$Parser$string == "y" || string == "1" || string == "true" || string == "yes" || string == "on"</ID>
    <ID>ComplexCondition:SystemSupervisor.kt$SystemSupervisor$stateMachine.featureFlags.withdrawalSafetyEnabled &amp;&amp; configs.retrieveWithdrawSafetyChecks &amp;&amp; (transferType == TransferType.withdrawal || transferType == TransferType.transferOut)</ID>
    <ID>ComplexCondition:TradeAccountStateValidator.kt$TradeAccountStateValidator$equity != null &amp;&amp; ( equity == Numeric.double.ZERO || marginUsage == null || marginUsage &lt; Numeric.double.ZERO || marginUsage &gt; Numeric.double.ONE )</ID>
    <ID>ComplexCondition:TradeInput.kt$SelectionOption.Companion$existing?.type != type || existing.string != string || existing.stringKey != stringKey || existing.iconUrl != iconUrl</ID>
    <ID>ComplexCondition:TradeInput.kt$TradeInput.Companion$existing?.type != type || existing?.side != side || existing?.marketId != marketId || existing?.size != size || existing?.price != price || existing?.timeInForce != timeInForce || existing?.goodTil != goodTil || existing?.execution != execution || existing?.reduceOnly != reduceOnly || existing.postOnly != postOnly || existing.fee != fee || existing?.marginMode != marginMode || existing?.targetLeverage != targetLeverage || existing.bracket != bracket || existing.marketOrder != marketOrder || existing.options != options || existing.summary != summary</ID>
    <ID>ComplexCondition:TradeInput.kt$TradeInputBracket.Companion$existing?.stopLoss != stopLoss || existing?.takeProfit != takeProfit || existing?.goodTil != goodTil || existing?.execution != execution</ID>
    <ID>ComplexCondition:TradeInput.kt$TradeInputMarketOrder.Companion$existing?.size != size || existing?.usdcSize != usdcSize || existing?.price != price || existing?.worstPrice != worstPrice || existing?.filled != filled || existing.orderbook != orderbook</ID>
    <ID>ComplexCondition:TradeInput.kt$TradeInputOptions.Companion$existing?.needsSize != needsSize || existing.needsLeverage != needsLeverage || existing.maxLeverage != maxLeverage || existing.needsLimitPrice != needsLimitPrice || existing.needsTargetLeverage != needsTargetLeverage || existing.needsTriggerPrice != needsTriggerPrice || existing.needsTrailingPercent != needsTrailingPercent || existing.needsGoodUntil != needsGoodUntil || existing.needsReduceOnly != needsReduceOnly || existing.needsPostOnly != needsPostOnly || existing.needsBrackets != needsBrackets || existing.timeInForceOptions != timeInForceOptionsArray || existing.marginModeOptions != marginModeOptions || existing.executionOptions != executionOptionsArray || existing.reduceOnlyTooltip != reduceOnlyTooltip</ID>
    <ID>ComplexCondition:TradeInput.kt$TradeInputSize.Companion$existing?.size != size || existing?.usdcSize != usdcSize || existing?.leverage != leverage || existing?.input != input</ID>
    <ID>ComplexCondition:TradeInput.kt$TradeInputSummary.Companion$existing?.price != price || existing?.payloadPrice != payloadPrice || existing?.size != size || existing?.usdcSize != usdcSize || existing?.slippage != slippage || existing?.fee != fee || existing?.total != total || existing?.positionMargin != positionMargin || existing?.positionLeverage != positionLeverage || existing?.filled != filled</ID>
    <ID>ComplexCondition:TradeInputCalculator.kt$TradeInputCalculator$fee != null &amp;&amp; feeMultiplierPpm != null &amp;&amp; tokenPrice != null &amp;&amp; tokenPriceExponent != null &amp;&amp; fee &gt; 0.0 &amp;&amp; notional != null &amp;&amp; tokenPrice &gt; 0.0</ID>
    <ID>ComplexCondition:TradeInputCalculator.kt$TradeInputCalculator$fee != null &amp;&amp; feeMultiplierPpm != null &amp;&amp; tokenPrice != null &amp;&amp; tokenPriceExponent != null &amp;&amp; fee &gt; 0.0 &amp;&amp; tokenPrice &gt; 0.0</ID>
    <ID>ComplexCondition:TradeInputCalculator.kt$TradeInputCalculator$price != null &amp;&amp; usdcSize != null &amp;&amp; usdcSize &gt; Numeric.double.ZERO &amp;&amp; price &gt; Numeric.double.ZERO</ID>
    <ID>ComplexCondition:TradeInputDataValidator.kt$TradeInputDataValidator$!isShortTermAndRequiresImmediateExecution &amp;&amp; (status == "OPEN" || status == "PENDING" || status == "UNTRIGGERED" || status == "PARTIALLY_FILLED") &amp;&amp; (isCurrentOrderStateful == shouldCountStatefulOrders)</ID>
    <ID>ComplexCondition:TradingStateMachine+Wallet.kt$payload["accounts"] != null || payload["subaccounts"] != null || payload["positions"] != null || payload["perpetualPositions"] != null || payload["assetPositions"] != null || payload["orders"] != null</ID>
    <ID>ComplexCondition:TradingStates.kt$TradeStatesWithDoubleValues.Companion$existing == null || existing.current != current || existing.postOrder != postOrder || existing.postAllOrders != postAllOrders</ID>
    <ID>ComplexCondition:TradingStates.kt$TradeStatesWithStringValues.Companion$existing == null || existing.current != current || existing.postOrder != postOrder || existing.postAllOrders != postAllOrders</ID>
    <ID>ComplexCondition:TransferInput.kt$DepositInputOptions.Companion$existing?.needsSize != needsSize || existing?.needsAddress != needsAddress || existing?.needsFastSpeed != needsFastSpeed || existing?.chains != chains || existing?.assets != assets</ID>
    <ID>ComplexCondition:TransferInput.kt$TransferInput.Companion$existing?.type !== type || existing?.size !== size || existing?.fastSpeed != fastSpeed || existing.fee != fee || existing.exchange != exchange || existing.chain != chain || existing.token != token || existing.address != address || existing.depositOptions != depositOptions || existing.withdrawalOptions != withdrawalOptions || existing.transferOutOptions != transferOutOptions || existing.summary !== summary || existing.resources !== resources || existing.requestPayload !== requestPayload || existing.errors != errors || existing.errorMessage != errorMessage</ID>
    <ID>ComplexCondition:TransferInput.kt$TransferInputChainResource.Companion$existing?.chainName != chainName || existing?.rpc != rpc || existing?.networkName != networkName || existing?.chainId != chainId || existing?.iconUrl != iconUrl</ID>
    <ID>ComplexCondition:TransferInput.kt$TransferInputRequestPayload.Companion$existing?.routeType != routeType || existing?.targetAddress != targetAddress || existing?.data != dataValue || existing?.value != value || existing?.gasLimit != gasLimit || existing?.gasPrice != gasPrice || existing?.maxFeePerGas != maxFeePerGas || existing?.maxPriorityFeePerGas != maxPriorityFeePerGas || existing?.fromChainId != fromChainId || existing?.toChainId != toChainId || existing?.fromAddress != fromAddress || existing?.toAddress != toAddress || existing?.isV2Route != isV2Route || existing?.requestId != requestId</ID>
    <ID>ComplexCondition:TransferInput.kt$TransferInputSummary.Companion$existing?.usdcSize != usdcSize || existing?.fee != fee || existing?.filled != filled || existing.slippage != slippage || existing.exchangeRate != exchangeRate || existing.estimatedRouteDuration != estimatedRouteDuration || existing.bridgeFee != bridgeFee || existing.gasFee != gasFee || existing.toAmount != toAmount || existing.toAmountMin != toAmountMin || existing.toAmountUSDC != toAmountUSDC || existing.aggregatePriceImpact != aggregatePriceImpact</ID>
    <ID>ComplexCondition:TransferInput.kt$TransferInputTokenResource.Companion$existing?.name != name || existing?.address != address || existing?.symbol != symbol || existing?.decimals != decimals || existing?.iconUrl != iconUrl</ID>
    <ID>ComplexCondition:TransferInput.kt$TransferOutInputOptions.Companion$existing?.needsSize != needsSize || existing.needsAddress != needsAddress || existing.chains != chains || existing.assets != assets</ID>
    <ID>ComplexCondition:TransferInput.kt$WithdrawalInputOptions.Companion$existing?.needsSize != needsSize || existing?.needsAddress != needsAddress || existing?.needsFastSpeed != needsFastSpeed || existing?.chains != chains || existing?.assets != assets</ID>
    <ID>ComplexCondition:TransferStatus.kt$TransferRouteStatus.Companion$existing == null || existing.chainId != chainId || existing.txHash != txHash || existing.status != status || existing.action != action</ID>
    <ID>ComplexCondition:TransferStatus.kt$TransferStatus.Companion$existing == null || existing.status != status || existing.gasStatus != gasStatus || existing.axelarTransactionUrl != axelarTransactionUrl || existing.fromChainStatus != fromChainStatus || existing.toChainStatus != toChainStatus || existing.routeStatuses != routeStatuses || existing.error != error || existing.squidTransactionStatus != squidTransactionStatus</ID>
    <ID>ComplexCondition:TriggerOrdersInput.kt$TriggerOrder.Companion$existing?.orderId != orderId || existing?.size != size || existing?.type != type || existing?.side != side || existing?.price != price || existing?.summary != summary</ID>
    <ID>ComplexCondition:TriggerOrdersInput.kt$TriggerOrdersInput.Companion$existing?.marketId != marketId || existing?.size != size || existing?.stopLossOrder != stopLossOrder || existing?.takeProfitOrder != takeProfitOrder</ID>
    <ID>ComplexCondition:TriggerOrdersInput.kt$TriggerPrice.Companion$existing?.limitPrice != limitPrice || existing?.triggerPrice != triggerPrice || existing?.percentDiff != percentDiff || existing?.usdcDiff != usdcDiff || existing?.input != input</ID>
    <ID>ComplexCondition:TriggerOrdersInputCalculator.kt$TriggerOrdersInputCalculator$size == null || size == Numeric.double.ZERO || notionalTotal == Numeric.double.ZERO || leverage == Numeric.double.ZERO</ID>
    <ID>ComplexCondition:TriggerOrdersInputValidator.kt$TriggerOrdersInputValidator$!isShortTermAndRequiresImmediateExecution &amp;&amp; (status == "OPEN" || status == "PENDING" || status == "UNTRIGGERED" || status == "PARTIALLY_FILLED")</ID>
    <ID>ComplexCondition:TriggerOrdersInputValidator.kt$TriggerOrdersInputValidator$triggerPrice != null &amp;&amp; triggerPrice &lt;= 0 || (limitPrice != null &amp;&amp; limitPrice &lt;= 0)</ID>
    <ID>ComplexCondition:V4StateManagerAdaptor+Transfer.kt$fromChain != null &amp;&amp; fromToken != null &amp;&amp; fromAmount != null &amp;&amp; fromAmount &gt; 0 &amp;&amp; fromAmountString != null &amp;&amp; accountAddress != null &amp;&amp; chainId != null &amp;&amp; dydxTokenDemon != null &amp;&amp; url != null &amp;&amp; sourceAddress != null &amp;&amp; squidIntegratorId != null</ID>
    <ID>ComplexCondition:V4StateManagerAdaptor+Transfer.kt$fromChain != null &amp;&amp; fromToken != null &amp;&amp; fromAmount != null &amp;&amp; fromAmount &gt; 0 &amp;&amp; fromAmountString != null &amp;&amp; nobleAddress != null &amp;&amp; chainId != null &amp;&amp; dydxTokenDemon != null &amp;&amp; url != null &amp;&amp; sourceAddress != null &amp;&amp; squidIntegratorId != null &amp;&amp; toChain != null &amp;&amp; toToken != null</ID>
    <ID>ComplexCondition:V4StateManagerAdaptor+Transfer.kt$name != null &amp;&amp; label != null &amp;&amp; icon != null &amp;&amp; depositType != null</ID>
    <ID>ComplexCondition:V4StateManagerAdaptor+Transfer.kt$nobleChain != null &amp;&amp; nobleToken != null &amp;&amp; toAddress != null &amp;&amp; fromAmount != null &amp;&amp; fromAmount &gt; 0 &amp;&amp; fromAmountString != null &amp;&amp; accountAddress != null &amp;&amp; chainId != null &amp;&amp; dydxTokenDemon != null &amp;&amp; url != null &amp;&amp; fromAddress != null &amp;&amp; squidIntegratorId != null</ID>
    <ID>ComplexCondition:V4StateManagerAdaptor+Transfer.kt$toChain != null &amp;&amp; toToken != null &amp;&amp; toAddress != null &amp;&amp; fromAmount != null &amp;&amp; fromAmount &gt; 0 &amp;&amp; fromAmountString != null &amp;&amp; accountAddress != null &amp;&amp; chainId != null &amp;&amp; dydxTokenDemon != null &amp;&amp; url != null &amp;&amp; fromAddress != null &amp;&amp; squidIntegratorId != null</ID>
    <ID>ComplexCondition:V4StateManagerAdaptor+Transfer.kt$toChain != null &amp;&amp; toToken != null &amp;&amp; toAddress != null &amp;&amp; fromAmount != null &amp;&amp; fromAmount &gt; 0 &amp;&amp; fromAmountString != null &amp;&amp; accountAddress != null &amp;&amp; chainId != null &amp;&amp; dydxTokenDemon != null &amp;&amp; url != null &amp;&amp; fromAddress != null &amp;&amp; squidIntegratorId != null &amp;&amp; fromChain != null &amp;&amp; fromToken != null</ID>
    <ID>ComplexCondition:V4StateManagerAdaptor+Transfer.kt$url != null &amp;&amp; fromChain != null &amp;&amp; fromToken != null &amp;&amp; nobleAddress != null &amp;&amp; chainId != null &amp;&amp; dydxTokenDemon != null &amp;&amp; squidIntegratorId != null</ID>
    <ID>ComplexCondition:V4StateManagerAdaptor+Transfer.kt$url != null &amp;&amp; nobleChain != null &amp;&amp; nobleToken != null &amp;&amp; nobleAddress != null &amp;&amp; chainId != null &amp;&amp; dydxTokenDemon != null &amp;&amp; squidIntegratorId != null &amp;&amp; fromAmountString != null &amp;&amp; fromAmount != null &amp;&amp; fromAmount &gt; 0</ID>
    <ID>ComplexCondition:V4StateManagerAdaptor.kt$V4StateManagerAdaptor$apiState?.status != status || apiState.height != block || apiState.haltedBlock != haltedBlock || apiState.trailingBlocks != blockDiff</ID>
    <ID>ComplexCondition:V4StateManagerAdaptor.kt$V4StateManagerAdaptor$type == TransferInputField.usdcSize || type == TransferInputField.address || type == TransferInputField.chain || type == TransferInputField.exchange || type == TransferInputField.token</ID>
    <ID>ComplexCondition:V4StateManagerAdaptor.kt$V4StateManagerAdaptor$type == TransferInputField.usdcSize || type == TransferInputField.size || type == TransferInputField.token || type == TransferInputField.address</ID>
    <ID>ComplexCondition:ValidationError.kt$ValidationError.Companion$existing?.code != code || existing.type !== type || existing.fields != fields || existing.resources !== resources</ID>
    <ID>ComplexCondition:Wallet.kt$User.Companion$existing?.isRegistered != isRegistered || existing.email != email || existing.username != username || existing.feeTierId != feeTierId || existing.makerFeeRate != makerFeeRate || existing.takerFeeRate != takerFeeRate || existing.makerVolume30D != makerVolume30D || existing.takerVolume30D != takerVolume30D || existing.fees30D != fees30D || existing.isEmailVerified != isEmailVerified || existing.country != country || existing.favorited != favorited || existing.walletId != walletId</ID>
    <ID>CyclomaticComplexMethod:Account.kt$Account.Companion$internal fun create( existing: Account?, parser: ParserProtocol, data: Map&lt;String, Any&gt;, tokensInfo: Map&lt;String, TokenInfo&gt;, localizer: LocalizerProtocol?, ): Account</ID>
    <ID>CyclomaticComplexMethod:Account.kt$Subaccount.Companion$internal fun create( existing: Subaccount?, parser: ParserProtocol, data: Map&lt;*, *&gt;?, localizer: LocalizerProtocol?, ): Subaccount?</ID>
    <ID>CyclomaticComplexMethod:Account.kt$SubaccountFill.Companion$internal fun create( existing: SubaccountFill?, parser: ParserProtocol, data: Map&lt;*, *&gt;?, localizer: LocalizerProtocol?, ): SubaccountFill?</ID>
    <ID>CyclomaticComplexMethod:Account.kt$SubaccountOrder.Companion$internal fun create( existing: SubaccountOrder?, parser: ParserProtocol, data: Map&lt;*, *&gt;?, localizer: LocalizerProtocol?, ): SubaccountOrder?</ID>
    <ID>CyclomaticComplexMethod:Account.kt$SubaccountPosition.Companion$internal fun create( existing: SubaccountPosition?, parser: ParserProtocol, data: Map&lt;String, Any&gt;?, ): SubaccountPosition?</ID>
    <ID>CyclomaticComplexMethod:Account.kt$SubaccountTransfer.Companion$internal fun create( existing: SubaccountTransfer?, parser: ParserProtocol, data: Map&lt;*, *&gt;?, ): SubaccountTransfer?</ID>
    <ID>CyclomaticComplexMethod:Account.kt$TradingRewards.Companion$private fun createHistoricalTradingRewardsPerPeriod( objs: IList&lt;HistoricalTradingReward&gt;?, data: List&lt;Any&gt;?, parser: ParserProtocol, period: String, ): IList&lt;HistoricalTradingReward&gt;</ID>
    <ID>CyclomaticComplexMethod:AsyncAbacusStateManager.kt$AsyncAbacusStateManager$private fun parseEnvironments(response: String): Boolean</ID>
    <ID>CyclomaticComplexMethod:AsyncAbacusStateManagerV2.kt$AsyncAbacusStateManagerV2$private fun parseEnvironments(response: String): Boolean</ID>
    <ID>CyclomaticComplexMethod:BaseInputValidator.kt$BaseInputValidator$private fun formatParam(params: Map&lt;String, Any&gt;): String?</ID>
    <ID>CyclomaticComplexMethod:Bech32.kt$Bech32$fun decode(str: String): Bech32Data</ID>
    <ID>CyclomaticComplexMethod:Configs.kt$FeeTier.Companion$internal fun create( existing: FeeTier?, parser: ParserProtocol, data: Map&lt;*, *&gt;?, localizer: LocalizerProtocol?, ): FeeTier?</ID>
    <ID>CyclomaticComplexMethod:ConnectionStats.kt$ConnectionStats$private fun apiState( apiState: ApiState?, indexerState: NetworkState, validatorState: NetworkState, ): ApiState</ID>
    <ID>CyclomaticComplexMethod:FieldsInputValidator.kt$FieldsInputValidator$private fun errorStringKey( transaction: Map&lt;String, Any&gt;, transactionType: String, field: String ): String?</ID>
    <ID>CyclomaticComplexMethod:JsonEncoder.kt$JsonEncoder$internal fun encode(element: Any?): String</ID>
    <ID>CyclomaticComplexMethod:Market.kt$MarketCandle.Companion$internal fun create( existing: MarketCandle?, parser: ParserProtocol, data: Map&lt;*, *&gt;?, ): MarketCandle?</ID>
    <ID>CyclomaticComplexMethod:Market.kt$MarketConfigs.Companion$internal fun create( existing: MarketConfigs?, parser: ParserProtocol, data: Map&lt;String, Any&gt;, ): MarketConfigs?</ID>
    <ID>CyclomaticComplexMethod:Market.kt$MarketTrade.Companion$internal fun create( existing: MarketTrade?, parser: ParserProtocol, data: Map&lt;*, *&gt;?, localizer: LocalizerProtocol?, ): MarketTrade?</ID>
    <ID>CyclomaticComplexMethod:Market.kt$PerpetualMarket.Companion$internal fun create( existing: PerpetualMarket?, parser: ParserProtocol, data: Map&lt;String, Any&gt;, assets: Map&lt;String, Any&gt;?, resetOrderbook: Boolean, resetTrades: Boolean, ): PerpetualMarket?</ID>
    <ID>CyclomaticComplexMethod:MarketsSupervisor.kt$MarketsSupervisor$internal fun receiveMarketsChannelSocketData( info: SocketInfo, payload: IMap&lt;String, Any&gt;, subaccountNumber: Int?, )</ID>
    <ID>CyclomaticComplexMethod:NetworkHelper.kt$NetworkHelper$internal fun updateStateChanges( stateMachine: TradingStateMachine, changes: StateChanges?, oldState: PerpetualState?, )</ID>
    <ID>CyclomaticComplexMethod:NotificationsProvider.kt$NotificationsProvider$private fun createOrderStatusNotification( stateMachine: TradingStateMachine, order: SubaccountOrder, ): Notification?</ID>
    <ID>CyclomaticComplexMethod:OnboardingSupervisor.kt$OnboardingSupervisor$private fun cctpToNoble( state: PerpetualState?, decimals: Int, gas: BigDecimal, accountAddress: String, subaccountNumber: Int?, callback: TransactionCallback )</ID>
    <ID>CyclomaticComplexMethod:OnboardingSupervisor.kt$OnboardingSupervisor$private fun didUpdateStateForTransfer( data: String?, type: TransferInputField?, accountAddress: String, sourceAddress: String, subaccountNumber: Int? )</ID>
    <ID>CyclomaticComplexMethod:OnboardingSupervisor.kt$OnboardingSupervisor$private fun retrieveDepositRouteV1( state: PerpetualState?, accountAddress: String, sourceAddress: String, subaccountNumber: Int?, )</ID>
    <ID>CyclomaticComplexMethod:OnboardingSupervisor.kt$OnboardingSupervisor$private fun retrieveDepositRouteV2( state: PerpetualState?, accountAddress: String, sourceAddress: String, subaccountNumber: Int?, )</ID>
    <ID>CyclomaticComplexMethod:OnboardingSupervisor.kt$OnboardingSupervisor$private fun retrieveWithdrawalRouteNoble( state: PerpetualState?, decimals: Int, gas: BigDecimal, accountAddress: String, sourceAddress: String, subaccountNumber: Int?, )</ID>
    <ID>CyclomaticComplexMethod:OnboardingSupervisor.kt$OnboardingSupervisor$private fun retrieveWithdrawalRouteV1( state: PerpetualState?, decimals: Int, gas: BigDecimal, accountAddress: String, sourceAddress: String, subaccountNumber: Int?, )</ID>
    <ID>CyclomaticComplexMethod:OnboardingSupervisor.kt$OnboardingSupervisor$private fun retrieveWithdrawalRouteV2( state: PerpetualState?, decimals: Int, gas: BigDecimal, accountAddress: String, sourceAddress: String, subaccountNumber: Int?, )</ID>
    <ID>CyclomaticComplexMethod:OrderProcessor.kt$OrderProcessor$private fun shouldUpdate(existing: Map&lt;String, Any&gt;?, payload: Map&lt;String, Any&gt;): Boolean</ID>
    <ID>CyclomaticComplexMethod:OrderbookProcessor.kt$OrderbookProcessor$fun consolidate(orderbook: Map&lt;String, Any&gt;?, stepSize: Double): Map&lt;String, Any&gt;?</ID>
    <ID>CyclomaticComplexMethod:OrderbookProcessor.kt$OrderbookProcessor$private fun receivedChangesLinear( existing: List&lt;Map&lt;String, Any&gt;&gt;?, changes: List&lt;Any&gt;, offset: Long?, ascending: Boolean ): List&lt;Map&lt;String, Any&gt;&gt;</ID>
    <ID>CyclomaticComplexMethod:Parser.kt$Parser$override fun asBool(data: Any?): Boolean?</ID>
    <ID>CyclomaticComplexMethod:ParsingHelper.kt$ParsingHelper.Companion$internal fun &lt;T : Any&gt; merge( parser: ParserProtocol, existing: List&lt;T&gt;?, data: List&lt;*&gt;?, comparison: ObjectAndDataComparisonBlock, createObject: ObjectCreationBlock, syncItems: Boolean = false, includesObjectBlock: IncludesObjectBlock? = null, includesDataBlock: IncludesDataBlock? = null, ): List&lt;T&gt;?</ID>
    <ID>CyclomaticComplexMethod:ParsingHelper.kt$ParsingHelper.Companion$internal inline fun &lt;reified T : Any&gt; transform( parser: ParserProtocol, existing: List&lt;T&gt;?, data: Map&lt;*, *&gt;?, key: ObjectKeyBlock, changed: ObjectAndDataChangedBlock, crossinline comparison: ObjectComparisonBlock, createObject: ObjectCreationBlock, ): List&lt;T&gt;?</ID>
    <ID>CyclomaticComplexMethod:StateManagerAdaptor.kt$StateManagerAdaptor$@Throws(Exception::class) fun placeOrderPayload(): HumanReadablePlaceOrderPayload</ID>
    <ID>CyclomaticComplexMethod:StateManagerAdaptor.kt$StateManagerAdaptor$@Throws(Exception::class) private fun socket( payload: IMap&lt;String, Any&gt;, )</ID>
    <ID>CyclomaticComplexMethod:StateManagerAdaptor.kt$StateManagerAdaptor$private fun updateStateChanges( state: PerpetualState?, changes: StateChanges?, oldState: PerpetualState?, )</ID>
    <ID>CyclomaticComplexMethod:SubaccountCalculator.kt$SubaccountCalculator$private fun calculatePositionValues( position: Map&lt;String, Any&gt;, market: Map&lt;String, Any&gt;?, subaccount: Map&lt;String, Any&gt;, price: Double?, periods: Set&lt;CalculationPeriod&gt;, ): MutableMap&lt;String, Any&gt;</ID>
    <ID>CyclomaticComplexMethod:SubaccountSupervisor.kt$SubaccountSupervisor$@Throws(Exception::class) fun placeOrderPayload(currentHeight: Int?): HumanReadablePlaceOrderPayload</ID>
    <ID>CyclomaticComplexMethod:SubaccountTransformer.kt$SubaccountTransformer$private fun deltaFromTrade( parser: ParserProtocol, trade: Map&lt;String, Any&gt;, market: Map&lt;String, Any&gt;?, usePessimisticCollateralCheck: Boolean, useOptimisticCollateralCheck: Boolean, ): Map&lt;String, Any&gt;?</ID>
    <ID>CyclomaticComplexMethod:TradeAccountStateValidator.kt$TradeAccountStateValidator$private fun fillsExistingOrder( parser: ParserProtocol, trade: Map&lt;String, Any&gt;, orders: Map&lt;String, Any&gt;?, ): Boolean</ID>
    <ID>CyclomaticComplexMethod:TradeInput.kt$TradeInput.Companion$internal fun create( existing: TradeInput?, parser: ParserProtocol, data: Map&lt;*, *&gt;?, ): TradeInput?</ID>
    <ID>CyclomaticComplexMethod:TradeInput.kt$TradeInputOptions.Companion$internal fun create( existing: TradeInputOptions?, parser: ParserProtocol, data: Map&lt;*, *&gt;?, ): TradeInputOptions?</ID>
    <ID>CyclomaticComplexMethod:TradeInputCalculator.kt$TradeInputCalculator$private fun calculatedOptionsFromFields( fields: List&lt;Any&gt;?, trade: Map&lt;String, Any&gt;, position: Map&lt;String, Any&gt;?, market: Map&lt;String, Any&gt;?, ): Map&lt;String, Any&gt;?</ID>
    <ID>CyclomaticComplexMethod:TradeInputCalculator.kt$TradeInputCalculator$private fun summaryForType( trade: Map&lt;String, Any&gt;, subaccount: Map&lt;String, Any&gt;?, user: Map&lt;String, Any&gt;?, market: Map&lt;String, Any&gt;?, rewardsParams: Map&lt;String, Any&gt;?, feeTiers: List&lt;Any&gt;?, type: String, ): Map&lt;String, Any&gt;</ID>
    <ID>CyclomaticComplexMethod:TradeInputValidator.kt$TradeInputValidator$private fun change( parser: ParserProtocol, subaccount: Map&lt;String, Any&gt;?, trade: Map&lt;String, Any&gt;, ): PositionChange</ID>
    <ID>CyclomaticComplexMethod:TradeTriggerPriceValidator.kt$TradeTriggerPriceValidator$override fun validateTrade( subaccount: Map&lt;String, Any&gt;?, market: Map&lt;String, Any&gt;?, configs: Map&lt;String, Any&gt;?, trade: Map&lt;String, Any&gt;, change: PositionChange, restricted: Boolean, environment: V4Environment?, ): List&lt;Any&gt;?</ID>
    <ID>CyclomaticComplexMethod:TradingStateMachine+ClosePositionInput.kt$fun TradingStateMachine.closePosition( data: String?, type: ClosePositionInputField, subaccountNumber: Int ): StateResponse</ID>
    <ID>CyclomaticComplexMethod:TradingStateMachine+TradeInput.kt$fun TradingStateMachine.trade( data: String?, type: TradeInputField?, subaccountNumber: Int, ): StateResponse</ID>
    <ID>CyclomaticComplexMethod:TradingStateMachine+TradeInput.kt$fun TradingStateMachine.tradeDataOption(typeText: String?): String?</ID>
    <ID>CyclomaticComplexMethod:TradingStateMachine+TransferInput.kt$fun TradingStateMachine.transfer( data: String?, type: TransferInputField?, subaccountNumber: Int = 0 ): StateResponse</ID>
    <ID>CyclomaticComplexMethod:TradingStateMachine+TriggerOrdersInput.kt$fun TradingStateMachine.triggerOrders( data: String?, type: TriggerOrdersInputField?, subaccountNumber: Int, ): StateResponse</ID>
    <ID>CyclomaticComplexMethod:TradingStateMachine.kt$TradingStateMachine$@Throws(Exception::class) private fun socket( url: AbUrl, payload: Map&lt;String, Any&gt;, subaccountNumber: Int, height: BlockAndTime?, ): StateResponse</ID>
    <ID>CyclomaticComplexMethod:TradingStateMachine.kt$TradingStateMachine$fun rest( url: AbUrl, payload: String, subaccountNumber: Int, height: Int?, deploymentUri: String? = null, period: String? = null, ): StateResponse</ID>
    <ID>CyclomaticComplexMethod:TradingStateMachine.kt$TradingStateMachine$internal fun update(changes: StateChanges): StateChanges</ID>
    <ID>CyclomaticComplexMethod:TradingStateMachine.kt$TradingStateMachine$private fun recalculateStates(changes: StateChanges)</ID>
    <ID>CyclomaticComplexMethod:TradingStateMachine.kt$TradingStateMachine$private fun update( state: PerpetualState?, changes: StateChanges, tokensInfo: Map&lt;String, TokenInfo&gt;, localizer: LocalizerProtocol?, ): PerpetualState</ID>
    <ID>CyclomaticComplexMethod:TransferInput.kt$DepositInputOptions.Companion$internal fun create( existing: DepositInputOptions?, parser: ParserProtocol, data: Map&lt;*, *&gt;? ): DepositInputOptions?</ID>
    <ID>CyclomaticComplexMethod:TransferInput.kt$TransferInput.Companion$internal fun create( existing: TransferInput?, parser: ParserProtocol, data: Map&lt;*, *&gt;?, environment: V4Environment? ): TransferInput?</ID>
    <ID>CyclomaticComplexMethod:TransferInput.kt$TransferInputRequestPayload.Companion$internal fun create( existing: TransferInputRequestPayload?, parser: ParserProtocol, data: Map&lt;*, *&gt;? ): TransferInputRequestPayload?</ID>
    <ID>CyclomaticComplexMethod:TransferInput.kt$TransferInputSummary.Companion$internal fun create( existing: TransferInputSummary?, parser: ParserProtocol, data: Map&lt;*, *&gt;? ): TransferInputSummary?</ID>
    <ID>CyclomaticComplexMethod:TransferInput.kt$WithdrawalInputOptions.Companion$internal fun create( existing: WithdrawalInputOptions?, parser: ParserProtocol, data: Map&lt;*, *&gt;? ): WithdrawalInputOptions?</ID>
    <ID>CyclomaticComplexMethod:TriggerOrdersInputCalculator.kt$TriggerOrdersInputCalculator$private fun calculateTriggerPrices( triggerPrices: Map&lt;String, Any&gt;, position: Map&lt;String, Any&gt;, size: Double?, ): MutableMap&lt;String, Any&gt;</ID>
    <ID>CyclomaticComplexMethod:TriggerOrdersInputValidator.kt$TriggerOrdersInputValidator$private fun validateCalculatedPricesPositive( triggerOrder: Map&lt;String, Any&gt;, ): List&lt;Any&gt;?</ID>
    <ID>CyclomaticComplexMethod:TriggerOrdersInputValidator.kt$TriggerOrdersInputValidator$private fun validateLimitPrice( triggerOrder: Map&lt;String, Any&gt;, ): List&lt;Any&gt;?</ID>
    <ID>CyclomaticComplexMethod:V4StateManagerAdaptor+Transfer.kt$internal fun V4StateManagerAdaptor.cctpToNoble( state: PerpetualState?, decimals: Int, gas: BigDecimal, callback: TransactionCallback )</ID>
    <ID>CyclomaticComplexMethod:V4StateManagerAdaptor+Transfer.kt$internal fun V4StateManagerAdaptor.retrieveWithdrawalRouteNoble( state: PerpetualState?, decimals: Int, gas: BigDecimal, )</ID>
    <ID>CyclomaticComplexMethod:V4StateManagerAdaptor+Transfer.kt$internal fun V4StateManagerAdaptor.retrieveWithdrawalRouteV1( state: PerpetualState?, decimals: Int, gas: BigDecimal, )</ID>
    <ID>CyclomaticComplexMethod:V4StateManagerAdaptor+Transfer.kt$internal fun V4StateManagerAdaptor.retrieveWithdrawalRouteV2( state: PerpetualState?, decimals: Int, gas: BigDecimal, )</ID>
    <ID>CyclomaticComplexMethod:V4StateManagerAdaptor+Transfer.kt$private fun V4StateManagerAdaptor.retrieveDepositRouteV1(state: PerpetualState?)</ID>
    <ID>CyclomaticComplexMethod:V4StateManagerAdaptor+Transfer.kt$private fun V4StateManagerAdaptor.retrieveDepositRouteV2(state: PerpetualState?)</ID>
    <ID>CyclomaticComplexMethod:V4StateManagerAdaptor.kt$V4StateManagerAdaptor$override fun didUpdateStateForTransfer(data: String?, type: TransferInputField?)</ID>
    <ID>CyclomaticComplexMethod:V4StateManagerAdaptor.kt$V4StateManagerAdaptor$private fun apiState( apiState: ApiState?, indexerState: NetworkState, validatorState: NetworkState, ): ApiState</ID>
    <ID>CyclomaticComplexMethod:Wallet.kt$User.Companion$internal fun create( existing: User?, parser: ParserProtocol, data: Map&lt;*, *&gt;? ): User?</ID>
    <ID>EmptyDefaultConstructor:AccountTransformer.kt$AccountTransformer$()</ID>
    <ID>EmptyDefaultConstructor:Network.kt$NetworkState$()</ID>
    <ID>EmptyDefaultConstructor:Timer.kt$LocalTimer$()</ID>
    <ID>EmptyFunctionBlock:TradingStateMachine.kt$TradingStateMachine${ }</ID>
    <ID>EnumNaming:AbacusHelper.kt$RiskLevel$high : RiskLevel</ID>
    <ID>EnumNaming:AbacusHelper.kt$RiskLevel$low : RiskLevel</ID>
    <ID>EnumNaming:AbacusHelper.kt$RiskLevel$medium : RiskLevel</ID>
    <ID>EnumNaming:Account.kt$FillLiquidity$maker : FillLiquidity</ID>
    <ID>EnumNaming:Account.kt$FillLiquidity$taker : FillLiquidity</ID>
    <ID>EnumNaming:ApiUtils.kt$HttpVerb$delete : HttpVerb</ID>
    <ID>EnumNaming:ApiUtils.kt$HttpVerb$get : HttpVerb</ID>
    <ID>EnumNaming:ApiUtils.kt$HttpVerb$post : HttpVerb</ID>
    <ID>EnumNaming:ApiUtils.kt$HttpVerb$put : HttpVerb</ID>
    <ID>EnumNaming:BaseProcessor.kt$ComparisonOrder$ascending</ID>
    <ID>EnumNaming:BaseProcessor.kt$ComparisonOrder$descending</ID>
    <ID>EnumNaming:BaseProcessor.kt$ComparisonOrder$same</ID>
    <ID>EnumNaming:PublicProtocols.kt$ThreadingType$abacus</ID>
    <ID>EnumNaming:PublicProtocols.kt$ThreadingType$main</ID>
    <ID>EnumNaming:PublicProtocols.kt$ThreadingType$network</ID>
    <ID>EnumNaming:PublicProtocols.kt$TransactionType$simulateTransferNativeToken : TransactionType</ID>
    <ID>EnumNaming:PublicProtocols.kt$TransactionType$simulateWithdraw : TransactionType</ID>
    <ID>EnumNaming:Settings.kt$OrderbookGrouping$none : OrderbookGrouping</ID>
    <ID>EnumNaming:Settings.kt$OrderbookGrouping$x10 : OrderbookGrouping</ID>
    <ID>EnumNaming:Settings.kt$OrderbookGrouping$x100 : OrderbookGrouping</ID>
    <ID>EnumNaming:Settings.kt$OrderbookGrouping$x1000 : OrderbookGrouping</ID>
    <ID>EnumNaming:StateChanges.kt$Changes$accountBalances : Changes</ID>
    <ID>EnumNaming:StateChanges.kt$Changes$assets : Changes</ID>
    <ID>EnumNaming:StateChanges.kt$Changes$candles : Changes</ID>
    <ID>EnumNaming:StateChanges.kt$Changes$compliance : Changes</ID>
    <ID>EnumNaming:StateChanges.kt$Changes$configs : Changes</ID>
    <ID>EnumNaming:StateChanges.kt$Changes$fills : Changes</ID>
    <ID>EnumNaming:StateChanges.kt$Changes$fundingPayments : Changes</ID>
    <ID>EnumNaming:StateChanges.kt$Changes$historicalFundings : Changes</ID>
    <ID>EnumNaming:StateChanges.kt$Changes$historicalPnl : Changes</ID>
    <ID>EnumNaming:StateChanges.kt$Changes$input : Changes</ID>
    <ID>EnumNaming:StateChanges.kt$Changes$launchIncentive : Changes</ID>
    <ID>EnumNaming:StateChanges.kt$Changes$markets : Changes</ID>
    <ID>EnumNaming:StateChanges.kt$Changes$orderbook : Changes</ID>
    <ID>EnumNaming:StateChanges.kt$Changes$restriction : Changes</ID>
    <ID>EnumNaming:StateChanges.kt$Changes$sparklines : Changes</ID>
    <ID>EnumNaming:StateChanges.kt$Changes$subaccount : Changes</ID>
    <ID>EnumNaming:StateChanges.kt$Changes$trades : Changes</ID>
    <ID>EnumNaming:StateChanges.kt$Changes$tradingRewards : Changes</ID>
    <ID>EnumNaming:StateChanges.kt$Changes$transferStatuses : Changes</ID>
    <ID>EnumNaming:StateChanges.kt$Changes$transfers : Changes</ID>
    <ID>EnumNaming:StateChanges.kt$Changes$wallet : Changes</ID>
    <ID>EnumNaming:SubaccountCalculator.kt$CalculationPeriod$current : CalculationPeriod</ID>
    <ID>EnumNaming:SubaccountCalculator.kt$CalculationPeriod$post : CalculationPeriod</ID>
    <ID>EnumNaming:SubaccountCalculator.kt$CalculationPeriod$settled : CalculationPeriod</ID>
    <ID>EnumNaming:SystemUtils.kt$Platform$android : Platform</ID>
    <ID>EnumNaming:SystemUtils.kt$Platform$ios : Platform</ID>
    <ID>EnumNaming:SystemUtils.kt$Platform$web : Platform</ID>
    <ID>EnumNaming:TradeInput.kt$MarginMode$cross : MarginMode</ID>
    <ID>EnumNaming:TradeInput.kt$MarginMode$isolated : MarginMode</ID>
    <ID>EnumNaming:TradeInput.kt$OrderSide$buy : OrderSide</ID>
    <ID>EnumNaming:TradeInput.kt$OrderSide$sell : OrderSide</ID>
    <ID>EnumNaming:TradeInput.kt$OrderStatus$canceling : OrderStatus</ID>
    <ID>EnumNaming:TradeInput.kt$OrderStatus$cancelled : OrderStatus</ID>
    <ID>EnumNaming:TradeInput.kt$OrderStatus$filled : OrderStatus</ID>
    <ID>EnumNaming:TradeInput.kt$OrderStatus$open : OrderStatus</ID>
    <ID>EnumNaming:TradeInput.kt$OrderStatus$partiallyFilled : OrderStatus</ID>
    <ID>EnumNaming:TradeInput.kt$OrderStatus$pending : OrderStatus</ID>
    <ID>EnumNaming:TradeInput.kt$OrderStatus$untriggered : OrderStatus</ID>
    <ID>EnumNaming:TradeInput.kt$OrderType$deleveraged : OrderType</ID>
    <ID>EnumNaming:TradeInput.kt$OrderType$finalSettlement : OrderType</ID>
    <ID>EnumNaming:TradeInput.kt$OrderType$limit : OrderType</ID>
    <ID>EnumNaming:TradeInput.kt$OrderType$liquidated : OrderType</ID>
    <ID>EnumNaming:TradeInput.kt$OrderType$liquidation : OrderType</ID>
    <ID>EnumNaming:TradeInput.kt$OrderType$market : OrderType</ID>
    <ID>EnumNaming:TradeInput.kt$OrderType$offsetting : OrderType</ID>
    <ID>EnumNaming:TradeInput.kt$OrderType$stopLimit : OrderType</ID>
    <ID>EnumNaming:TradeInput.kt$OrderType$stopMarket : OrderType</ID>
    <ID>EnumNaming:TradeInput.kt$OrderType$takeProfitLimit : OrderType</ID>
    <ID>EnumNaming:TradeInput.kt$OrderType$takeProfitMarket : OrderType</ID>
    <ID>EnumNaming:TradeInput.kt$OrderType$trailingStop : OrderType</ID>
    <ID>EnumNaming:TradeInput.kt$ReceiptLine$bridgeFee : ReceiptLine</ID>
    <ID>EnumNaming:TradeInput.kt$ReceiptLine$buyingPower : ReceiptLine</ID>
    <ID>EnumNaming:TradeInput.kt$ReceiptLine$equity : ReceiptLine</ID>
    <ID>EnumNaming:TradeInput.kt$ReceiptLine$exchangeRate : ReceiptLine</ID>
    <ID>EnumNaming:TradeInput.kt$ReceiptLine$exchangeReceived : ReceiptLine</ID>
    <ID>EnumNaming:TradeInput.kt$ReceiptLine$expectedPrice : ReceiptLine</ID>
    <ID>EnumNaming:TradeInput.kt$ReceiptLine$fee : ReceiptLine</ID>
    <ID>EnumNaming:TradeInput.kt$ReceiptLine$gasFee : ReceiptLine</ID>
    <ID>EnumNaming:TradeInput.kt$ReceiptLine$marginUsage : ReceiptLine</ID>
    <ID>EnumNaming:TradeInput.kt$ReceiptLine$reward : ReceiptLine</ID>
    <ID>EnumNaming:TradeInput.kt$ReceiptLine$slippage : ReceiptLine</ID>
    <ID>EnumNaming:TradeInput.kt$ReceiptLine$total : ReceiptLine</ID>
    <ID>EnumNaming:TradeInput.kt$ReceiptLine$transferRouteEstimatedDuration : ReceiptLine</ID>
    <ID>EnumNaming:TradeInput.kt$ReceiptLine$walletBalance : ReceiptLine</ID>
    <ID>EnumNaming:TradeInputCalculator.kt$TradeCalculation$closePosition : TradeCalculation</ID>
    <ID>EnumNaming:TradeInputCalculator.kt$TradeCalculation$trade : TradeCalculation</ID>
    <ID>EnumNaming:TradingStateMachine+ClosePositionInput.kt$ClosePositionInputField$market : ClosePositionInputField</ID>
    <ID>EnumNaming:TradingStateMachine+ClosePositionInput.kt$ClosePositionInputField$percent : ClosePositionInputField</ID>
    <ID>EnumNaming:TradingStateMachine+ClosePositionInput.kt$ClosePositionInputField$size : ClosePositionInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TradeInput.kt$TradeInputField$bracketsExecution : TradeInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TradeInput.kt$TradeInputField$bracketsGoodUntilDuration : TradeInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TradeInput.kt$TradeInputField$bracketsGoodUntilUnit : TradeInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TradeInput.kt$TradeInputField$bracketsStopLossPercent : TradeInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TradeInput.kt$TradeInputField$bracketsStopLossPrice : TradeInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TradeInput.kt$TradeInputField$bracketsStopLossReduceOnly : TradeInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TradeInput.kt$TradeInputField$bracketsTakeProfitPercent : TradeInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TradeInput.kt$TradeInputField$bracketsTakeProfitPrice : TradeInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TradeInput.kt$TradeInputField$bracketsTakeProfitReduceOnly : TradeInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TradeInput.kt$TradeInputField$execution : TradeInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TradeInput.kt$TradeInputField$goodTilDuration : TradeInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TradeInput.kt$TradeInputField$goodTilUnit : TradeInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TradeInput.kt$TradeInputField$leverage : TradeInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TradeInput.kt$TradeInputField$limitPrice : TradeInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TradeInput.kt$TradeInputField$marginMode : TradeInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TradeInput.kt$TradeInputField$postOnly : TradeInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TradeInput.kt$TradeInputField$reduceOnly : TradeInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TradeInput.kt$TradeInputField$side : TradeInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TradeInput.kt$TradeInputField$size : TradeInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TradeInput.kt$TradeInputField$targetLeverage : TradeInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TradeInput.kt$TradeInputField$timeInForceType : TradeInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TradeInput.kt$TradeInputField$trailingPercent : TradeInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TradeInput.kt$TradeInputField$triggerPrice : TradeInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TradeInput.kt$TradeInputField$type : TradeInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TradeInput.kt$TradeInputField$usdcSize : TradeInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TransferInput.kt$TransferInputField$address : TransferInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TransferInput.kt$TransferInputField$chain : TransferInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TransferInput.kt$TransferInputField$exchange : TransferInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TransferInput.kt$TransferInputField$fastSpeed : TransferInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TransferInput.kt$TransferInputField$size : TransferInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TransferInput.kt$TransferInputField$token : TransferInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TransferInput.kt$TransferInputField$type : TransferInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TransferInput.kt$TransferInputField$usdcFee : TransferInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TransferInput.kt$TransferInputField$usdcSize : TransferInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TriggerOrdersInput.kt$TriggerOrdersInputField$marketId : TriggerOrdersInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TriggerOrdersInput.kt$TriggerOrdersInputField$size : TriggerOrdersInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TriggerOrdersInput.kt$TriggerOrdersInputField$stopLossLimitPrice : TriggerOrdersInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TriggerOrdersInput.kt$TriggerOrdersInputField$stopLossOrderId : TriggerOrdersInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TriggerOrdersInput.kt$TriggerOrdersInputField$stopLossOrderSize : TriggerOrdersInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TriggerOrdersInput.kt$TriggerOrdersInputField$stopLossOrderType : TriggerOrdersInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TriggerOrdersInput.kt$TriggerOrdersInputField$stopLossPercentDiff : TriggerOrdersInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TriggerOrdersInput.kt$TriggerOrdersInputField$stopLossPrice : TriggerOrdersInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TriggerOrdersInput.kt$TriggerOrdersInputField$stopLossUsdcDiff : TriggerOrdersInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TriggerOrdersInput.kt$TriggerOrdersInputField$takeProfitLimitPrice : TriggerOrdersInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TriggerOrdersInput.kt$TriggerOrdersInputField$takeProfitOrderId : TriggerOrdersInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TriggerOrdersInput.kt$TriggerOrdersInputField$takeProfitOrderSize : TriggerOrdersInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TriggerOrdersInput.kt$TriggerOrdersInputField$takeProfitOrderType : TriggerOrdersInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TriggerOrdersInput.kt$TriggerOrdersInputField$takeProfitPercentDiff : TriggerOrdersInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TriggerOrdersInput.kt$TriggerOrdersInputField$takeProfitPrice : TriggerOrdersInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TriggerOrdersInput.kt$TriggerOrdersInputField$takeProfitUsdcDiff : TriggerOrdersInputField</ID>
    <ID>EnumNaming:TransferInput.kt$TransferType$deposit : TransferType</ID>
    <ID>EnumNaming:TransferInput.kt$TransferType$transferOut : TransferType</ID>
    <ID>EnumNaming:TransferInput.kt$TransferType$withdrawal : TransferType</ID>
    <ID>EnumNaming:ValidationError.kt$ErrorType$error : ErrorType</ID>
    <ID>EnumNaming:ValidationError.kt$ErrorType$required : ErrorType</ID>
    <ID>EnumNaming:ValidationError.kt$ErrorType$warning : ErrorType</ID>
    <ID>ExplicitItLambdaParameter:AccountProcessor.kt$SubaccountProcessor${ it -&gt; val data = parser.asNativeMap(it) parser.asString(data?.get("status")) == "OPEN" }</ID>
    <ID>ExplicitItLambdaParameter:AccountSupervisor.kt$AccountSupervisor${ it -&gt; helper.send(error, it, hash) }</ID>
    <ID>ExplicitItLambdaParameter:AccountSupervisor.kt$AccountSupervisor${ it -&gt; helper.send(null, it, hash) }</ID>
    <ID>ExplicitItLambdaParameter:AsyncAbacusStateManager.kt$AsyncAbacusStateManager${ it -&gt; it.id == environment }</ID>
    <ID>ExplicitItLambdaParameter:AsyncAbacusStateManagerV2.kt$AsyncAbacusStateManagerV2${ it -&gt; it.id == environment }</ID>
    <ID>ExplicitItLambdaParameter:EquityTiersProcessor.kt$EquityTiersProcessor${ it -&gt; itemProcessor.received(null, it)?.let { received -&gt; modified["shortTermOrderEquityTiers"]?.add(received) } }</ID>
    <ID>ExplicitItLambdaParameter:EquityTiersProcessor.kt$EquityTiersProcessor${ it -&gt; itemProcessor.received(null, it)?.let { received -&gt; modified["statefulOrderEquityTiers"]?.add(received) } }</ID>
    <ID>ExplicitItLambdaParameter:FeeDiscountsProcessor.kt$FeeDiscountsProcessor${ it -&gt; itemProcessor.received(null, it)?.let { received -&gt; modified.add(received) } }</ID>
    <ID>ExplicitItLambdaParameter:FeeTiersProcessor.kt$FeeTiersProcessor${ it -&gt; itemProcessor.received(null, it)?.let { received -&gt; modified.add(received) } }</ID>
    <ID>ExplicitItLambdaParameter:LaunchIncentiveSeasonsProcessor.kt$LaunchIncentiveSeasonsProcessor${ it -&gt; itemProcessor.received(null, it)?.let { received -&gt; modified.add(received) } }</ID>
    <ID>ExplicitItLambdaParameter:LimiterCapacitiesProcessor.kt$LimiterCapacitiesProcessor${ it -&gt; itemProcessor.received(null, it)?.let { received -&gt; modified.add(received) } }</ID>
    <ID>ExplicitItLambdaParameter:MarketProcessor.kt$MarketProcessor${ it -&gt; candles = candlesProcessor.channel_data(candles, resolution, it) }</ID>
    <ID>ExplicitItLambdaParameter:MarketProcessor.kt$MarketProcessor${ it -&gt; trades = tradesProcessor.channel_data(trades, it) }</ID>
    <ID>ExplicitItLambdaParameter:SquidProcessor.kt$SquidProcessor${ it -&gt; for (chain in it) { parser.asNativeMap(chain)?.let { chain -&gt; if (parser.asString(chain.get("chainType")) != "cosmos") { options.add(chainProcessor.received(null, chain)) } } } }</ID>
    <ID>ExplicitItLambdaParameter:V4StateManagerAdaptor.kt$V4StateManagerAdaptor${ it -&gt; send(error, it, hash) }</ID>
    <ID>ExplicitItLambdaParameter:V4StateManagerAdaptor.kt$V4StateManagerAdaptor${ it -&gt; send(null, it, hash) }</ID>
    <ID>ForbiddenComment:Account.kt$SubaccountOrder.Companion$// TODO: Remove default to 0 for subaccountNumber once new indexer response is consumed. Prevents breaking change</ID>
    <ID>ForbiddenComment:TradeInputCalculator.kt$TradeInputCalculator$// TODO: When Child Subaccounts are added to Subaccount data class, return the child subaccount's leverage</ID>
    <ID>ForbiddenComment:TradeInputCalculator.kt$TradeInputCalculator$// TODO: When the collateral of child subaccounts is implemented, return from here. The below code is the CROSS implementation.</ID>
    <ID>ForbiddenComment:TradingStateMachine.kt$TradingStateMachine$// TODO: update price diffs based on price.input</ID>
    <ID>FunctionOnlyReturningConstant:MarketsSupervisor.kt$MarketsSupervisor$private fun shouldBatchMarketsChannelData(): Boolean</ID>
    <ID>FunctionOnlyReturningConstant:StateManagerAdaptorV2.kt$StateManagerAdaptorV2$private fun height(): BlockAndTime?</ID>
    <ID>FunctionOnlyReturningConstant:TradeAccountStateValidator.kt$TradeAccountStateValidator$private fun validateSubaccountOrders( parser: ParserProtocol, subaccount: Map&lt;String, Any&gt;, ): Map&lt;String, Any&gt;?</ID>
    <ID>FunctionOnlyReturningConstant:TradeMarketOrderInputValidator.kt$TradeMarketOrderInputValidator$private fun accountRestricted(): Boolean</ID>
    <ID>FunctionOnlyReturningConstant:TradingStateMachine+TriggerOrdersInput.kt$fun TradingStateMachine.validTriggerOrdersInput( triggerOrders: Map&lt;String, Any&gt;, typeText: String? ): Boolean</ID>
    <ID>FunctionOnlyReturningConstant:TradingStateMachine.kt$TradingStateMachine$private fun priceOverwrite(markets: Map&lt;String, Any&gt;): Map&lt;String, Any&gt;?</ID>
    <ID>FunctionOnlyReturningConstant:V4StateManagerConfigs.kt$V4StateManagerConfigs$fun nobleDenom(): String?</ID>
    <ID>FunctionParameterNaming:AsyncAbacusStateManager.kt$AsyncAbacusStateManager.Companion$_nativeImplementations: ProtocolNativeImpFactory</ID>
    <ID>FunctionParameterNaming:AsyncAbacusStateManagerV2.kt$AsyncAbacusStateManagerV2.Companion$_nativeImplementations: ProtocolNativeImpFactory</ID>
    <ID>InvalidPackageDeclaration:AbacusHelper.kt$package exchange.dydx.abacus.utils</ID>
    <ID>InvalidPackageDeclaration:Account.kt$package exchange.dydx.abacus.output</ID>
    <ID>InvalidPackageDeclaration:AccountCalculator.kt$package exchange.dydx.abacus.calculator</ID>
    <ID>InvalidPackageDeclaration:AccountInputValidator.kt$package exchange.dydx.abacus.validator</ID>
    <ID>InvalidPackageDeclaration:AccountProcessor.kt$package exchange.dydx.abacus.processor.wallet.account</ID>
    <ID>InvalidPackageDeclaration:AccountSupervisor.kt$package exchange.dydx.abacus.state.v2.supervisor</ID>
    <ID>InvalidPackageDeclaration:AccountTransformer.kt$package exchange.dydx.abacus.calculator</ID>
    <ID>InvalidPackageDeclaration:AccountsSupervisor.kt$package exchange.dydx.abacus.state.v2.supervisor</ID>
    <ID>InvalidPackageDeclaration:AddressFormatException.kt$package exchange.dydx.abacus.utils.beth32</ID>
    <ID>InvalidPackageDeclaration:AnalyticsUtils.kt$package exchange.dydx.abacus.utils</ID>
    <ID>InvalidPackageDeclaration:ApiUtils.kt$package exchange.dydx.abacus.state.app.adaptors</ID>
    <ID>InvalidPackageDeclaration:Asset.kt$package exchange.dydx.abacus.output</ID>
    <ID>InvalidPackageDeclaration:AssetPositionProcessor.kt$package exchange.dydx.abacus.processor.wallet.account</ID>
    <ID>InvalidPackageDeclaration:AssetPositionsProcessor.kt$package exchange.dydx.abacus.processor.wallet.account</ID>
    <ID>InvalidPackageDeclaration:AssetProcessor.kt$package exchange.dydx.abacus.processor.assets</ID>
    <ID>InvalidPackageDeclaration:AssetsProcessor.kt$package exchange.dydx.abacus.processor.assets</ID>
    <ID>InvalidPackageDeclaration:AsyncAbacusStateManager.kt$package exchange.dydx.abacus.state.manager</ID>
    <ID>InvalidPackageDeclaration:AsyncAbacusStateManagerProtocol.kt$package exchange.dydx.abacus.state.manager</ID>
    <ID>InvalidPackageDeclaration:AsyncAbacusStateManagerV2.kt$package exchange.dydx.abacus.state.v2.manager</ID>
    <ID>InvalidPackageDeclaration:BaseInputValidator.kt$package exchange.dydx.abacus.validator</ID>
    <ID>InvalidPackageDeclaration:BaseProcessor.kt$package exchange.dydx.abacus.processor.base</ID>
    <ID>InvalidPackageDeclaration:Bech32.kt$package exchange.dydx.abacus.utils.beth32</ID>
    <ID>InvalidPackageDeclaration:Bech32Data.kt$package exchange.dydx.abacus.utils.beth32</ID>
    <ID>InvalidPackageDeclaration:CandleProcessor.kt$package exchange.dydx.abacus.processor.markets</ID>
    <ID>InvalidPackageDeclaration:CandlesProcessor.kt$package exchange.dydx.abacus.processor.markets</ID>
    <ID>InvalidPackageDeclaration:CctpChainTokenInfo.kt$package exchange.dydx.abacus.state.manager</ID>
    <ID>InvalidPackageDeclaration:ClosePositionInput.kt$package exchange.dydx.abacus.output.input</ID>
    <ID>InvalidPackageDeclaration:Compliance.kt$package exchange.dydx.abacus.output</ID>
    <ID>InvalidPackageDeclaration:Configs.kt$package exchange.dydx.abacus.output</ID>
    <ID>InvalidPackageDeclaration:Configs.kt$package exchange.dydx.abacus.state.v2.supervisor</ID>
    <ID>InvalidPackageDeclaration:ConfigsProcessor.kt$package exchange.dydx.abacus.processor.configs</ID>
    <ID>InvalidPackageDeclaration:ConnectionStats.kt$package exchange.dydx.abacus.state.v2.supervisor</ID>
    <ID>InvalidPackageDeclaration:ConnectionsSupervisor.kt$package exchange.dydx.abacus.state.v2.supervisor</ID>
    <ID>InvalidPackageDeclaration:Constants.kt$package exchange.dydx.abacus.utils</ID>
    <ID>InvalidPackageDeclaration:DepositValidator.kt$package exchange.dydx.abacus.validator.transfer</ID>
    <ID>InvalidPackageDeclaration:Documentation.kt$package exchange.dydx.abacus.output</ID>
    <ID>InvalidPackageDeclaration:DynamicLocalizer.kt$package exchange.dydx.abacus.state.app.helper</ID>
    <ID>InvalidPackageDeclaration:Enviroment.kt$package exchange.dydx.abacus.state.manager</ID>
    <ID>InvalidPackageDeclaration:EquityTierProcessor.kt$package exchange.dydx.abacus.processor.configs</ID>
    <ID>InvalidPackageDeclaration:EquityTiersProcessor.kt$package exchange.dydx.abacus.processor.configs</ID>
    <ID>InvalidPackageDeclaration:ExchangeInfo.kt$package exchange.dydx.abacus.state.manager</ID>
    <ID>InvalidPackageDeclaration:FeeDiscountProcessor.kt$package exchange.dydx.abacus.processor.configs</ID>
    <ID>InvalidPackageDeclaration:FeeDiscountsProcessor.kt$package exchange.dydx.abacus.processor.configs</ID>
    <ID>InvalidPackageDeclaration:FeeTierProcessor.kt$package exchange.dydx.abacus.processor.configs</ID>
    <ID>InvalidPackageDeclaration:FeeTiersProcessor.kt$package exchange.dydx.abacus.processor.configs</ID>
    <ID>InvalidPackageDeclaration:FieldsInputValidator.kt$package exchange.dydx.abacus.validator</ID>
    <ID>InvalidPackageDeclaration:FillProcessor.kt$package exchange.dydx.abacus.processor.wallet.account</ID>
    <ID>InvalidPackageDeclaration:FillsProcessor.kt$package exchange.dydx.abacus.processor.wallet.account</ID>
    <ID>InvalidPackageDeclaration:Formatter.kt$package exchange.dydx.abacus.state.app.helper</ID>
    <ID>InvalidPackageDeclaration:FundingPaymentProcessor.kt$package exchange.dydx.abacus.processor.wallet.account</ID>
    <ID>InvalidPackageDeclaration:FundingPaymentsProcessor.kt$package exchange.dydx.abacus.processor.wallet.account</ID>
    <ID>InvalidPackageDeclaration:GoodTil.kt$package exchange.dydx.abacus.utils</ID>
    <ID>InvalidPackageDeclaration:HistoricalFundingProcessor.kt$package exchange.dydx.abacus.processor.markets</ID>
    <ID>InvalidPackageDeclaration:HistoricalFundingsProcessor.kt$package exchange.dydx.abacus.processor.markets</ID>
    <ID>InvalidPackageDeclaration:HistoricalPNLProcessor.kt$package exchange.dydx.abacus.processor.wallet.account</ID>
    <ID>InvalidPackageDeclaration:HistoricalPNLsProcessor.kt$package exchange.dydx.abacus.processor.wallet.account</ID>
    <ID>InvalidPackageDeclaration:HistoricalTradingRewardProcessor.kt$package exchange.dydx.abacus.processor.wallet.account</ID>
    <ID>InvalidPackageDeclaration:HistoricalTradingRewardsProcessor.kt$package exchange.dydx.abacus.processor.wallet.account</ID>
    <ID>InvalidPackageDeclaration:Input.kt$package exchange.dydx.abacus.output.input</ID>
    <ID>InvalidPackageDeclaration:InputValidator.kt$package exchange.dydx.abacus.validator</ID>
    <ID>InvalidPackageDeclaration:JsonEncoder.kt$package exchange.dydx.abacus.utils</ID>
    <ID>InvalidPackageDeclaration:JsonUtils.kt$package exchange.dydx.abacus.utils</ID>
    <ID>InvalidPackageDeclaration:LaunchIncentive.kt$package exchange.dydx.abacus.output</ID>
    <ID>InvalidPackageDeclaration:LaunchIncentivePointProcessor.kt$package exchange.dydx.abacus.processor.wallet.account</ID>
    <ID>InvalidPackageDeclaration:LaunchIncentivePointsProcessor.kt$package exchange.dydx.abacus.processor.wallet.account</ID>
    <ID>InvalidPackageDeclaration:LaunchIncentiveProcessor.kt$package exchange.dydx.abacus.processor.launchIncentive</ID>
    <ID>InvalidPackageDeclaration:LaunchIncentiveSeasonProcessor.kt$package exchange.dydx.abacus.processor.launchIncentive</ID>
    <ID>InvalidPackageDeclaration:LaunchIncentiveSeasonsProcessor.kt$package exchange.dydx.abacus.processor.launchIncentive</ID>
    <ID>InvalidPackageDeclaration:LimiterCapacitiesProcessor.kt$package exchange.dydx.abacus.processor.configs</ID>
    <ID>InvalidPackageDeclaration:LimiterCapacityProcessor.kt$package exchange.dydx.abacus.processor.configs</ID>
    <ID>InvalidPackageDeclaration:List+Utils.kt$package exchange.dydx.abacus.utils</ID>
    <ID>InvalidPackageDeclaration:LocalizerProtocol.kt$package exchange.dydx.abacus.protocols</ID>
    <ID>InvalidPackageDeclaration:Logger.kt$package exchange.dydx.abacus.utils</ID>
    <ID>InvalidPackageDeclaration:LoggerProtocol.kt$package exchange.dydx.abacus.protocols</ID>
    <ID>InvalidPackageDeclaration:Map+Utils.kt$package exchange.dydx.abacus.utils</ID>
    <ID>InvalidPackageDeclaration:Market.kt$package exchange.dydx.abacus.output</ID>
    <ID>InvalidPackageDeclaration:MarketCalculator.kt$package exchange.dydx.abacus.calculator</ID>
    <ID>InvalidPackageDeclaration:MarketId.kt$package exchange.dydx.abacus.processor.utils</ID>
    <ID>InvalidPackageDeclaration:MarketProcessor.kt$package exchange.dydx.abacus.processor.markets</ID>
    <ID>InvalidPackageDeclaration:MarketSupervisor.kt$package exchange.dydx.abacus.state.v2.supervisor</ID>
    <ID>InvalidPackageDeclaration:MarketsProcessor.kt$package exchange.dydx.abacus.processor.markets</ID>
    <ID>InvalidPackageDeclaration:MarketsSummaryProcessor.kt$package exchange.dydx.abacus.processor.markets</ID>
    <ID>InvalidPackageDeclaration:MarketsSupervisor.kt$package exchange.dydx.abacus.state.v2.supervisor</ID>
    <ID>InvalidPackageDeclaration:Address.kt$package exchange.dydx.abacus.state.manager.utils</ID>
    <ID>InvalidPackageDeclaration:Network.kt$package exchange.dydx.abacus.state.manager</ID>
    <ID>InvalidPackageDeclaration:NetworkConfigsProcessor.kt$package exchange.dydx.abacus.processor.configs</ID>
    <ID>InvalidPackageDeclaration:NetworkHelper.kt$package exchange.dydx.abacus.state.v2.supervisor</ID>
    <ID>InvalidPackageDeclaration:NetworkSupervisor.kt$package exchange.dydx.abacus.state.v2.supervisor</ID>
    <ID>InvalidPackageDeclaration:Notification.kt$package exchange.dydx.abacus.output</ID>
    <ID>InvalidPackageDeclaration:NotificationsProvider.kt$package exchange.dydx.abacus.state.manager</ID>
    <ID>InvalidPackageDeclaration:Numeric.kt$package exchange.dydx.abacus.utils</ID>
    <ID>InvalidPackageDeclaration:OnboardingSupervisor.kt$package exchange.dydx.abacus.state.v2.supervisor</ID>
    <ID>InvalidPackageDeclaration:OrderProcessor.kt$package exchange.dydx.abacus.processor.wallet.account</ID>
    <ID>InvalidPackageDeclaration:OrderTypeProcessor.kt$package exchange.dydx.abacus.processor.utils</ID>
    <ID>InvalidPackageDeclaration:OrderbookEntryProcessor.kt$package exchange.dydx.abacus.processor.markets</ID>
    <ID>InvalidPackageDeclaration:OrderbookProcessor.kt$package exchange.dydx.abacus.processor.markets</ID>
    <ID>InvalidPackageDeclaration:OrdersProcessor.kt$package exchange.dydx.abacus.processor.wallet.account</ID>
    <ID>InvalidPackageDeclaration:Parser.kt$package exchange.dydx.abacus.utils</ID>
    <ID>InvalidPackageDeclaration:ParserProtocol.kt$package exchange.dydx.abacus.protocols</ID>
    <ID>InvalidPackageDeclaration:ParsingError.kt$package exchange.dydx.abacus.responses</ID>
    <ID>InvalidPackageDeclaration:ParsingHelper.kt$package exchange.dydx.abacus.utils</ID>
    <ID>InvalidPackageDeclaration:Payloads.kt$package exchange.dydx.abacus.state.manager</ID>
    <ID>InvalidPackageDeclaration:PerpTradingStateMachine.kt$package exchange.dydx.abacus.state.model</ID>
    <ID>InvalidPackageDeclaration:PerpetualPositionProcessor.kt$package exchange.dydx.abacus.processor.wallet.account</ID>
    <ID>InvalidPackageDeclaration:PerpetualPositionsProcessor.kt$package exchange.dydx.abacus.processor.wallet.account</ID>
    <ID>InvalidPackageDeclaration:PerpetualState.kt$package exchange.dydx.abacus.output</ID>
    <ID>InvalidPackageDeclaration:ProtocolNativeImpFactory.kt$package exchange.dydx.abacus.utils</ID>
    <ID>InvalidPackageDeclaration:PublicProtocols.kt$package exchange.dydx.abacus.protocols</ID>
    <ID>InvalidPackageDeclaration:RegulatoryRestriction.kt$package exchange.dydx.abacus.output</ID>
    <ID>InvalidPackageDeclaration:RewardsProcessor.kt$package exchange.dydx.abacus.processor</ID>
    <ID>InvalidPackageDeclaration:Rounder.kt$package exchange.dydx.abacus.utils</ID>
    <ID>InvalidPackageDeclaration:SerializableCollections.kt$package exchange.dydx.abacus.utils</ID>
    <ID>InvalidPackageDeclaration:ServerTime.kt$package exchange.dydx.abacus.utils</ID>
    <ID>InvalidPackageDeclaration:Set+Utils.kt$package exchange.dydx.abacus.utils</ID>
    <ID>InvalidPackageDeclaration:Settings.kt$package exchange.dydx.abacus.state.manager</ID>
    <ID>InvalidPackageDeclaration:SquidChainProcessor.kt$package exchange.dydx.abacus.processor.squid</ID>
    <ID>InvalidPackageDeclaration:SquidChainResourceProcessor.kt$package exchange.dydx.abacus.processor.squid</ID>
    <ID>InvalidPackageDeclaration:SquidProcessor.kt$package exchange.dydx.abacus.processor.squid</ID>
    <ID>InvalidPackageDeclaration:SquidRoutePayloadProcessor.kt$package exchange.dydx.abacus.processor.squid</ID>
    <ID>InvalidPackageDeclaration:SquidRouteProcessor.kt$package exchange.dydx.abacus.processor.squid</ID>
    <ID>InvalidPackageDeclaration:SquidRouteV2PayloadProcessor.kt$package exchange.dydx.abacus.processor.squid</ID>
    <ID>InvalidPackageDeclaration:SquidRouteV2Processor.kt$package exchange.dydx.abacus.processor.squid</ID>
    <ID>InvalidPackageDeclaration:SquidStatusProcessor.kt$package exchange.dydx.abacus.processor.squid</ID>
    <ID>InvalidPackageDeclaration:SquidTokenProcessor.kt$package exchange.dydx.abacus.processor.squid</ID>
    <ID>InvalidPackageDeclaration:SquidTokenResourceProcessor.kt$package exchange.dydx.abacus.processor.squid</ID>
    <ID>InvalidPackageDeclaration:StateChanges.kt$package exchange.dydx.abacus.state.changes</ID>
    <ID>InvalidPackageDeclaration:StateManagerAdaptor.kt$package exchange.dydx.abacus.state.manager</ID>
    <ID>InvalidPackageDeclaration:StateManagerAdaptorV2.kt$package exchange.dydx.abacus.state.v2.manager</ID>
    <ID>InvalidPackageDeclaration:StateManagerConfigs.kt$package exchange.dydx.abacus.state.manager.configs</ID>
    <ID>InvalidPackageDeclaration:StateResponse.kt$package exchange.dydx.abacus.responses</ID>
    <ID>InvalidPackageDeclaration:String+Utils.kt$package exchange.dydx.abacus.utils</ID>
    <ID>InvalidPackageDeclaration:StringHelper.kt$package exchange.dydx.abacus.utils</ID>
    <ID>InvalidPackageDeclaration:SubaccountCalculator.kt$package exchange.dydx.abacus.calculator</ID>
    <ID>InvalidPackageDeclaration:SubaccountSupervisor.kt$package exchange.dydx.abacus.state.v2.supervisor</ID>
    <ID>InvalidPackageDeclaration:SubaccountTransformer.kt$package exchange.dydx.abacus.calculator</ID>
    <ID>InvalidPackageDeclaration:SystemSupervisor.kt$package exchange.dydx.abacus.state.v2.supervisor</ID>
    <ID>InvalidPackageDeclaration:SystemUtils.kt$package exchange.dydx.abacus.state.manager</ID>
    <ID>InvalidPackageDeclaration:Threading.kt$package exchange.dydx.abacus.utils</ID>
    <ID>InvalidPackageDeclaration:Timer.kt$package exchange.dydx.abacus.utils</ID>
    <ID>InvalidPackageDeclaration:TradeAccountStateValidator.kt$package exchange.dydx.abacus.validator.trade</ID>
    <ID>InvalidPackageDeclaration:TradeBracketOrdersValidator.kt$package exchange.dydx.abacus.validator.trade</ID>
    <ID>InvalidPackageDeclaration:TradeInput.kt$package exchange.dydx.abacus.output.input</ID>
    <ID>InvalidPackageDeclaration:TradeInputCalculator.kt$package exchange.dydx.abacus.calculator</ID>
    <ID>InvalidPackageDeclaration:TradeInputDataValidator.kt$package exchange.dydx.abacus.validator.trade</ID>
    <ID>InvalidPackageDeclaration:TradeInputValidator.kt$package exchange.dydx.abacus.validator</ID>
    <ID>InvalidPackageDeclaration:TradeMarketOrderInputValidator.kt$package exchange.dydx.abacus.validator.trade</ID>
    <ID>InvalidPackageDeclaration:TradePositionStateValidator.kt$package exchange.dydx.abacus.validator.trade</ID>
    <ID>InvalidPackageDeclaration:TradeProcessor.kt$package exchange.dydx.abacus.processor.markets</ID>
    <ID>InvalidPackageDeclaration:TradeTriggerPriceValidator.kt$package exchange.dydx.abacus.validator.trade</ID>
    <ID>InvalidPackageDeclaration:TradesProcessor.kt$package exchange.dydx.abacus.processor.markets</ID>
    <ID>InvalidPackageDeclaration:TradingStateMachine+Account.kt$package exchange.dydx.abacus.state.model</ID>
    <ID>InvalidPackageDeclaration:TradingStateMachine+Candles.kt$package exchange.dydx.abacus.state.model</ID>
    <ID>InvalidPackageDeclaration:TradingStateMachine+ClosePositionInput.kt$package exchange.dydx.abacus.state.model</ID>
    <ID>InvalidPackageDeclaration:TradingStateMachine+EquityTiers.kt$package exchange.dydx.abacus.state.model</ID>
    <ID>InvalidPackageDeclaration:TradingStateMachine+Errors.kt$package exchange.dydx.abacus.state.model</ID>
    <ID>InvalidPackageDeclaration:TradingStateMachine+FeeDiscounts.kt$package exchange.dydx.abacus.state.model</ID>
    <ID>InvalidPackageDeclaration:TradingStateMachine+FeeTiers.kt$package exchange.dydx.abacus.state.model</ID>
    <ID>InvalidPackageDeclaration:TradingStateMachine+HistoricalFunding.kt$package exchange.dydx.abacus.state.model</ID>
    <ID>InvalidPackageDeclaration:TradingStateMachine+HistoricalPnl.kt$package exchange.dydx.abacus.state.model</ID>
    <ID>InvalidPackageDeclaration:TradingStateMachine+HistoricalTradingRewards.kt$package exchange.dydx.abacus.state.model</ID>
    <ID>InvalidPackageDeclaration:TradingStateMachine+LaunchIncentive.kt$package exchange.dydx.abacus.state.model</ID>
    <ID>InvalidPackageDeclaration:TradingStateMachine+Markets.kt$package exchange.dydx.abacus.state.model</ID>
    <ID>InvalidPackageDeclaration:TradingStateMachine+Orderbook.kt$package exchange.dydx.abacus.state.model</ID>
    <ID>InvalidPackageDeclaration:TradingStateMachine+ParentSubaccount.kt$package exchange.dydx.abacus.state.model</ID>
    <ID>InvalidPackageDeclaration:TradingStateMachine+Rewards.kt$package exchange.dydx.abacus.state.model</ID>
    <ID>InvalidPackageDeclaration:TradingStateMachine+Squid.kt$package exchange.dydx.abacus.state.model</ID>
    <ID>InvalidPackageDeclaration:TradingStateMachine+TradeInput.kt$package exchange.dydx.abacus.state.model</ID>
    <ID>InvalidPackageDeclaration:TradingStateMachine+Trades.kt$package exchange.dydx.abacus.state.model</ID>
    <ID>InvalidPackageDeclaration:TradingStateMachine+TransferInput.kt$package exchange.dydx.abacus.state.model</ID>
    <ID>InvalidPackageDeclaration:TradingStateMachine+TriggerOrdersInput.kt$package exchange.dydx.abacus.state.model</ID>
    <ID>InvalidPackageDeclaration:TradingStateMachine+Wallet.kt$package exchange.dydx.abacus.state.model</ID>
    <ID>InvalidPackageDeclaration:TradingStateMachine+WithdrawalGating.kt$package exchange.dydx.abacus.state.model</ID>
    <ID>InvalidPackageDeclaration:TradingStateMachine.kt$package exchange.dydx.abacus.state.model</ID>
    <ID>InvalidPackageDeclaration:TradingStates.kt$package exchange.dydx.abacus.output</ID>
    <ID>InvalidPackageDeclaration:TransactionQueue.kt$package exchange.dydx.abacus.state.manager</ID>
    <ID>InvalidPackageDeclaration:TransferInput.kt$package exchange.dydx.abacus.output.input</ID>
    <ID>InvalidPackageDeclaration:TransferInputCalculator.kt$package exchange.dydx.abacus.calculator</ID>
    <ID>InvalidPackageDeclaration:TransferInputValidator.kt$package exchange.dydx.abacus.validator</ID>
    <ID>InvalidPackageDeclaration:TransferOutValidator.kt$package exchange.dydx.abacus.validator.transfer</ID>
    <ID>InvalidPackageDeclaration:TransferProcessor.kt$package exchange.dydx.abacus.processor.wallet.account</ID>
    <ID>InvalidPackageDeclaration:TransferStatus.kt$package exchange.dydx.abacus.output</ID>
    <ID>InvalidPackageDeclaration:TransfersProcessor.kt$package exchange.dydx.abacus.processor.wallet.account</ID>
    <ID>InvalidPackageDeclaration:TriggerOrdersInput.kt$package exchange.dydx.abacus.output.input</ID>
    <ID>InvalidPackageDeclaration:TriggerOrdersInputCalculator.kt$package exchange.dydx.abacus.calculator</ID>
    <ID>InvalidPackageDeclaration:TriggerOrdersInputValidator.kt$package exchange.dydx.abacus.validator</ID>
    <ID>InvalidPackageDeclaration:UserProcessor.kt$package exchange.dydx.abacus.processor.wallet.user</ID>
    <ID>InvalidPackageDeclaration:V3AccountProcessor.kt$package exchange.dydx.abacus.processor.wallet.account.deprecated</ID>
    <ID>InvalidPackageDeclaration:V3ApiKey.kt$package exchange.dydx.abacus.state.app.signer</ID>
    <ID>InvalidPackageDeclaration:V4StateManagerAdaptor+Transfer.kt$package exchange.dydx.abacus.state.manager</ID>
    <ID>InvalidPackageDeclaration:V4StateManagerAdaptor.kt$package exchange.dydx.abacus.state.manager</ID>
    <ID>InvalidPackageDeclaration:V4StateManagerConfigs.kt$package exchange.dydx.abacus.state.manager.configs</ID>
    <ID>InvalidPackageDeclaration:V4TransactionErrors.kt$package exchange.dydx.abacus.state.app.adaptors</ID>
    <ID>InvalidPackageDeclaration:ValidationError.kt$package exchange.dydx.abacus.output.input</ID>
    <ID>InvalidPackageDeclaration:ValidatorProtocols.kt$package exchange.dydx.abacus.validator</ID>
    <ID>InvalidPackageDeclaration:Wallet.kt$package exchange.dydx.abacus.output</ID>
    <ID>InvalidPackageDeclaration:WalletProcessor.kt$package exchange.dydx.abacus.processor.wallet</ID>
    <ID>InvalidPackageDeclaration:WithdrawalCapacityProcessor.kt$package exchange.dydx.abacus.processor.configs</ID>
    <ID>InvalidPackageDeclaration:WithdrawalCapacityValidator.kt$package exchange.dydx.abacus.validator.transfer</ID>
    <ID>InvalidPackageDeclaration:WithdrawalGatingProcessor.kt$package exchange.dydx.abacus.processor.configs</ID>
    <ID>InvalidPackageDeclaration:WithdrawalGatingValidator.kt$package exchange.dydx.abacus.validator.transfer</ID>
    <ID>LargeClass:AccountSupervisor.kt$AccountSupervisor : DynamicNetworkSupervisor</ID>
    <ID>LargeClass:OnboardingSupervisor.kt$OnboardingSupervisor : NetworkSupervisor</ID>
    <ID>LargeClass:StateManagerAdaptor.kt$StateManagerAdaptor</ID>
    <ID>LargeClass:SubaccountSupervisor.kt$SubaccountSupervisor : DynamicNetworkSupervisor</ID>
    <ID>LargeClass:TradeInputCalculator.kt$TradeInputCalculator</ID>
    <ID>LargeClass:TradingStateMachine.kt$TradingStateMachine</ID>
    <ID>LargeClass:V4StateManagerAdaptor.kt$V4StateManagerAdaptor : StateManagerAdaptor</ID>
    <ID>LongMethod:Account.kt$Account.Companion$internal fun create( existing: Account?, parser: ParserProtocol, data: Map&lt;String, Any&gt;, tokensInfo: Map&lt;String, TokenInfo&gt;, localizer: LocalizerProtocol?, ): Account</ID>
    <ID>LongMethod:Account.kt$Subaccount.Companion$internal fun create( existing: Subaccount?, parser: ParserProtocol, data: Map&lt;*, *&gt;?, localizer: LocalizerProtocol?, ): Subaccount?</ID>
    <ID>LongMethod:Account.kt$SubaccountOrder.Companion$internal fun create( existing: SubaccountOrder?, parser: ParserProtocol, data: Map&lt;*, *&gt;?, localizer: LocalizerProtocol?, ): SubaccountOrder?</ID>
    <ID>LongMethod:Account.kt$SubaccountPosition.Companion$internal fun create( existing: SubaccountPosition?, parser: ParserProtocol, data: Map&lt;String, Any&gt;?, ): SubaccountPosition?</ID>
    <ID>LongMethod:Account.kt$TradingRewards.Companion$private fun createHistoricalTradingRewardsPerPeriod( objs: IList&lt;HistoricalTradingReward&gt;?, data: List&lt;Any&gt;?, parser: ParserProtocol, period: String, ): IList&lt;HistoricalTradingReward&gt;</ID>
    <ID>LongMethod:AccountCalculator.kt$AccountCalculator$private fun mergeChildPendingPositions( parentSubaccount: Map&lt;String, Any&gt;, childSubaccountNumber: Int, childSubaccount: Map&lt;String, Any&gt;, childOrders: Map&lt;String, Any&gt;, markets: Map&lt;String, Any&gt;?, ): Map&lt;String, Any&gt;</ID>
    <ID>LongMethod:ConnectionStats.kt$ConnectionStats$private fun apiState( apiState: ApiState?, indexerState: NetworkState, validatorState: NetworkState, ): ApiState</ID>
    <ID>LongMethod:JsonEncoder.kt$JsonEncoder$internal fun encode(element: Any?): String</ID>
    <ID>LongMethod:Market.kt$MarketConfigs.Companion$internal fun create( existing: MarketConfigs?, parser: ParserProtocol, data: Map&lt;String, Any&gt;, ): MarketConfigs?</ID>
    <ID>LongMethod:NetworkHelper.kt$NetworkHelper$internal fun updateStateChanges( stateMachine: TradingStateMachine, changes: StateChanges?, oldState: PerpetualState?, )</ID>
    <ID>LongMethod:NotificationsProvider.kt$NotificationsProvider$private fun createNotificationForFill( stateMachine: TradingStateMachine, fill: SubaccountFill, ): Notification?</ID>
    <ID>LongMethod:NotificationsProvider.kt$NotificationsProvider$private fun createOrderStatusNotification( stateMachine: TradingStateMachine, order: SubaccountOrder, ): Notification?</ID>
    <ID>LongMethod:OnboardingSupervisor.kt$OnboardingSupervisor$private fun cctpToNoble( state: PerpetualState?, decimals: Int, gas: BigDecimal, accountAddress: String, subaccountNumber: Int?, callback: TransactionCallback )</ID>
    <ID>LongMethod:OnboardingSupervisor.kt$OnboardingSupervisor$private fun didUpdateStateForTransfer( data: String?, type: TransferInputField?, accountAddress: String, sourceAddress: String, subaccountNumber: Int? )</ID>
    <ID>LongMethod:OnboardingSupervisor.kt$OnboardingSupervisor$private fun retrieveDepositRouteV2( state: PerpetualState?, accountAddress: String, sourceAddress: String, subaccountNumber: Int?, )</ID>
    <ID>LongMethod:OnboardingSupervisor.kt$OnboardingSupervisor$private fun retrieveWithdrawalRouteV2( state: PerpetualState?, decimals: Int, gas: BigDecimal, accountAddress: String, sourceAddress: String, subaccountNumber: Int?, )</ID>
    <ID>LongMethod:OrderbookProcessor.kt$OrderbookProcessor$private fun receivedChangesLinear( existing: List&lt;Map&lt;String, Any&gt;&gt;?, changes: List&lt;Any&gt;, offset: Long?, ascending: Boolean ): List&lt;Map&lt;String, Any&gt;&gt;</ID>
    <ID>LongMethod:ParsingHelper.kt$ParsingHelper.Companion$internal fun &lt;T : Any&gt; merge( parser: ParserProtocol, existing: List&lt;T&gt;?, data: List&lt;*&gt;?, comparison: ObjectAndDataComparisonBlock, createObject: ObjectCreationBlock, syncItems: Boolean = false, includesObjectBlock: IncludesObjectBlock? = null, includesDataBlock: IncludesDataBlock? = null, ): List&lt;T&gt;?</ID>
    <ID>LongMethod:StateManagerAdaptor.kt$StateManagerAdaptor$@Throws(Exception::class) fun placeOrderPayload(): HumanReadablePlaceOrderPayload</ID>
    <ID>LongMethod:StateManagerAdaptor.kt$StateManagerAdaptor$private fun updateStateChanges( state: PerpetualState?, changes: StateChanges?, oldState: PerpetualState?, )</ID>
    <ID>LongMethod:SubaccountCalculator.kt$SubaccountCalculator$private fun calculatePositionValues( position: Map&lt;String, Any&gt;, market: Map&lt;String, Any&gt;?, subaccount: Map&lt;String, Any&gt;, price: Double?, periods: Set&lt;CalculationPeriod&gt;, ): MutableMap&lt;String, Any&gt;</ID>
    <ID>LongMethod:SubaccountCalculator.kt$SubaccountCalculator$private fun calculateSubaccountEquity( subaccount: MutableMap&lt;String, Any&gt;, positions: Map&lt;String, Map&lt;String, Any&gt;&gt;?, periods: Set&lt;CalculationPeriod&gt;, )</ID>
    <ID>LongMethod:SubaccountSupervisor.kt$SubaccountSupervisor$@Throws(Exception::class) fun placeOrderPayload(currentHeight: Int?): HumanReadablePlaceOrderPayload</ID>
    <ID>LongMethod:SubaccountSupervisor.kt$SubaccountSupervisor$private fun submitPlaceOrder( callback: TransactionCallback, payload: HumanReadablePlaceOrderPayload, analyticsPayload: IMap&lt;String, Any&gt;?, isTriggerOrder: Boolean = false, transferPayload: HumanReadableSubaccountTransferPayload? = null, ): HumanReadablePlaceOrderPayload</ID>
    <ID>LongMethod:TradeAccountStateValidator.kt$TradeAccountStateValidator$private fun fillsExistingOrder( parser: ParserProtocol, trade: Map&lt;String, Any&gt;, orders: Map&lt;String, Any&gt;?, ): Boolean</ID>
    <ID>LongMethod:TradeInput.kt$TradeInput.Companion$internal fun create( existing: TradeInput?, parser: ParserProtocol, data: Map&lt;*, *&gt;?, ): TradeInput?</ID>
    <ID>LongMethod:TradeInput.kt$TradeInputOptions.Companion$internal fun create( existing: TradeInputOptions?, parser: ParserProtocol, data: Map&lt;*, *&gt;?, ): TradeInputOptions?</ID>
    <ID>LongMethod:TradeInputCalculator.kt$TradeInputCalculator$internal fun calculate( state: Map&lt;String, Any&gt;, subaccountNumber: Int?, input: String?, ): Map&lt;String, Any&gt;</ID>
    <ID>LongMethod:TradeInputCalculator.kt$TradeInputCalculator$private fun calculateMarketOrderFromLeverage( equity: Double, oraclePrice: Double, positionSize: Double?, isBuying: Boolean, feeRate: Double, leverage: Double, stepSize: Double, orderbook: List&lt;Map&lt;String, Any&gt;&gt;, ): Map&lt;String, Any&gt;?</ID>
    <ID>LongMethod:TradeInputCalculator.kt$TradeInputCalculator$private fun calculateMarketOrderFromUsdcSize( usdcSize: Double?, orderbook: List&lt;Map&lt;String, Any&gt;&gt;?, stepSize: Double, ): Map&lt;String, Any&gt;?</ID>
    <ID>LongMethod:TradeInputCalculator.kt$TradeInputCalculator$private fun calculatedOptionsFromFields( fields: List&lt;Any&gt;?, trade: Map&lt;String, Any&gt;, position: Map&lt;String, Any&gt;?, market: Map&lt;String, Any&gt;?, ): Map&lt;String, Any&gt;?</ID>
    <ID>LongMethod:TradeInputCalculator.kt$TradeInputCalculator$private fun requiredFields(trade: Map&lt;String, Any&gt;, market: Map&lt;String, Any&gt;?): List&lt;Any&gt;?</ID>
    <ID>LongMethod:TradeInputCalculator.kt$TradeInputCalculator$private fun summaryForType( trade: Map&lt;String, Any&gt;, subaccount: Map&lt;String, Any&gt;?, user: Map&lt;String, Any&gt;?, market: Map&lt;String, Any&gt;?, rewardsParams: Map&lt;String, Any&gt;?, feeTiers: List&lt;Any&gt;?, type: String, ): Map&lt;String, Any&gt;</ID>
    <ID>LongMethod:TradeInputDataValidator.kt$TradeInputDataValidator$private fun validateOrder( trade: Map&lt;String, Any&gt;, subaccount: Map&lt;String, Any&gt;?, configs: Map&lt;String, Any&gt;?, environment: V4Environment?, ): List&lt;Any&gt;?</ID>
    <ID>LongMethod:TradePositionStateValidator.kt$TradePositionStateValidator$private fun validatePositionLeverage( position: Map&lt;String, Any&gt;, trade: Map&lt;String, Any&gt;, change: PositionChange, restricted: Boolean, ): Map&lt;String, Any&gt;?</ID>
    <ID>LongMethod:TradeTriggerPriceValidator.kt$TradeTriggerPriceValidator$override fun validateTrade( subaccount: Map&lt;String, Any&gt;?, market: Map&lt;String, Any&gt;?, configs: Map&lt;String, Any&gt;?, trade: Map&lt;String, Any&gt;, change: PositionChange, restricted: Boolean, environment: V4Environment?, ): List&lt;Any&gt;?</ID>
    <ID>LongMethod:TradingStateMachine+ClosePositionInput.kt$fun TradingStateMachine.closePosition( data: String?, type: ClosePositionInputField, subaccountNumber: Int ): StateResponse</ID>
    <ID>LongMethod:TradingStateMachine+TradeInput.kt$fun TradingStateMachine.trade( data: String?, type: TradeInputField?, subaccountNumber: Int, ): StateResponse</ID>
    <ID>LongMethod:TradingStateMachine+TransferInput.kt$fun TradingStateMachine.transfer( data: String?, type: TransferInputField?, subaccountNumber: Int = 0 ): StateResponse</ID>
    <ID>LongMethod:TradingStateMachine+TriggerOrdersInput.kt$fun TradingStateMachine.triggerOrders( data: String?, type: TriggerOrdersInputField?, subaccountNumber: Int, ): StateResponse</ID>
    <ID>LongMethod:TradingStateMachine.kt$TradingStateMachine$@Throws(Exception::class) private fun socket( url: AbUrl, payload: Map&lt;String, Any&gt;, subaccountNumber: Int, height: BlockAndTime?, ): StateResponse</ID>
    <ID>LongMethod:TradingStateMachine.kt$TradingStateMachine$internal fun update(changes: StateChanges): StateChanges</ID>
    <ID>LongMethod:TradingStateMachine.kt$TradingStateMachine$private fun calculateReceipt(input: Map&lt;String, Any&gt;): List&lt;String&gt;?</ID>
    <ID>LongMethod:TradingStateMachine.kt$TradingStateMachine$private fun recalculateStates(changes: StateChanges)</ID>
    <ID>LongMethod:TradingStateMachine.kt$TradingStateMachine$private fun update( state: PerpetualState?, changes: StateChanges, tokensInfo: Map&lt;String, TokenInfo&gt;, localizer: LocalizerProtocol?, ): PerpetualState</ID>
    <ID>LongMethod:TransferInput.kt$DepositInputOptions.Companion$internal fun create( existing: DepositInputOptions?, parser: ParserProtocol, data: Map&lt;*, *&gt;? ): DepositInputOptions?</ID>
    <ID>LongMethod:TransferInput.kt$TransferInput.Companion$internal fun create( existing: TransferInput?, parser: ParserProtocol, data: Map&lt;*, *&gt;?, environment: V4Environment? ): TransferInput?</ID>
    <ID>LongMethod:TransferInput.kt$WithdrawalInputOptions.Companion$internal fun create( existing: WithdrawalInputOptions?, parser: ParserProtocol, data: Map&lt;*, *&gt;? ): WithdrawalInputOptions?</ID>
    <ID>LongMethod:TransferInputCalculator.kt$TransferInputCalculator$private fun summaryForType( transfer: Map&lt;String, Any&gt;, type: String ): Map&lt;String, Any&gt;</ID>
    <ID>LongMethod:TriggerOrdersInputCalculator.kt$TriggerOrdersInputCalculator$private fun calculateTriggerPrices( triggerPrices: Map&lt;String, Any&gt;, position: Map&lt;String, Any&gt;, size: Double?, ): MutableMap&lt;String, Any&gt;</ID>
    <ID>LongMethod:TriggerOrdersInputValidator.kt$TriggerOrdersInputValidator$private fun validateOrderCount( triggerOrders: Map&lt;String, Any&gt;, subaccount: Map&lt;String, Any&gt;?, configs: Map&lt;String, Any&gt;?, environment: V4Environment?, ): List&lt;Any&gt;?</ID>
    <ID>LongMethod:V4StateManagerAdaptor+Transfer.kt$internal fun V4StateManagerAdaptor.cctpToNoble( state: PerpetualState?, decimals: Int, gas: BigDecimal, callback: TransactionCallback )</ID>
    <ID>LongMethod:V4StateManagerAdaptor+Transfer.kt$internal fun V4StateManagerAdaptor.retrieveWithdrawalRouteV2( state: PerpetualState?, decimals: Int, gas: BigDecimal, )</ID>
    <ID>LongMethod:V4StateManagerAdaptor+Transfer.kt$private fun V4StateManagerAdaptor.retrieveDepositRouteV2(state: PerpetualState?)</ID>
    <ID>LongMethod:V4StateManagerAdaptor.kt$V4StateManagerAdaptor$override fun didUpdateStateForTransfer(data: String?, type: TransferInputField?)</ID>
    <ID>LongMethod:V4StateManagerAdaptor.kt$V4StateManagerAdaptor$private fun apiState( apiState: ApiState?, indexerState: NetworkState, validatorState: NetworkState, ): ApiState</ID>
    <ID>LongParameterList:AccountCalculator.kt$AccountCalculator$( account: Map&lt;String, Any&gt;?, subaccountNumbers: List&lt;Int&gt;, configs: Map&lt;String, Any&gt;?, markets: Map&lt;String, Any&gt;?, price: Map&lt;String, Any&gt;?, periods: Set&lt;CalculationPeriod&gt;, )</ID>
    <ID>LongParameterList:AccountTransformer.kt$AccountTransformer$( account: Map&lt;String, Any&gt;?, subaccountNumber: Int?, trade: Map&lt;String, Any&gt;, market: Map&lt;String, Any&gt;?, parser: ParserProtocol, period: String, usePessimisticCollateralCheck: Boolean, useOptimisticCollateralCheck: Boolean )</ID>
    <ID>LongParameterList:AsyncAbacusStateManager.kt$AsyncAbacusStateManager$( val deploymentUri: String, val deployment: String, // MAINNET, TESTNET, DEV val appConfigs: AppConfigs, val ioImplementations: IOImplementations, val uiImplementations: UIImplementations, val stateNotification: StateNotificationProtocol? = null, val dataNotification: DataNotificationProtocol? = null )</ID>
    <ID>LongParameterList:AsyncAbacusStateManagerV2.kt$AsyncAbacusStateManagerV2$( val deploymentUri: String, val deployment: String, // MAINNET, TESTNET, DEV val appConfigs: AppConfigsV2, val ioImplementations: IOImplementations, val uiImplementations: UIImplementations, val stateNotification: StateNotificationProtocol? = null, val dataNotification: DataNotificationProtocol? = null )</ID>
    <ID>LongParameterList:BaseInputValidator.kt$BaseInputValidator$( type: String, errorCode: String, fields: List&lt;String&gt;?, actionStringKey: String?, titleStringKey: String, textStringKey: String, textParams: Map&lt;String, Any&gt;? = null, action: String? = null, link: String? = null, linkText: String? = null, )</ID>
    <ID>LongParameterList:Enviroment.kt$Environment$( val id: String, val name: String?, val ethereumChainId: String, val dydxChainId: String?, val squidIntegratorId: String?, val isMainNet: Boolean, val endpoints: EnvironmentEndpoints, val links: EnvironmentLinks?, val walletConnection: WalletConnection?, val apps: AppsRequirements?, val governance: EnvironmentGovernance?, val featureFlags: EnvironmentFeatureFlags, )</ID>
    <ID>LongParameterList:Enviroment.kt$V4Environment$( id: String, name: String?, ethereumChainId: String, dydxChainId: String?, squidIntegratorId: String?, val chainName: String?, val chainLogo: String?, isMainNet: Boolean, endpoints: EnvironmentEndpoints, links: EnvironmentLinks?, walletConnection: WalletConnection?, apps: AppsRequirements?, val tokens: IMap&lt;String, TokenInfo&gt;, governance: EnvironmentGovernance?, featureFlags: EnvironmentFeatureFlags, )</ID>
    <ID>LongParameterList:Enviroment.kt$V4Environment.Companion$( id: String, data: Map&lt;String, Any&gt;, parser: ParserProtocol, deploymentUri: String, localizer: LocalizerProtocol?, tokensData: Map&lt;String, Any&gt;?, linksData: Map&lt;String, Any&gt;?, walletsData: Map&lt;String, Any&gt;?, governanceData: Map&lt;String, Any&gt;?, )</ID>
    <ID>LongParameterList:InputValidator.kt$InputValidator$( wallet: Map&lt;String, Any&gt;?, user: Map&lt;String, Any&gt;?, subaccount: Map&lt;String, Any&gt;?, markets: Map&lt;String, Any&gt;?, configs: Map&lt;String, Any&gt;?, currentBlockAndHeight: BlockAndTime?, transaction: Map&lt;String, Any&gt;, transactionType: String, environment: V4Environment?, )</ID>
    <ID>LongParameterList:InputValidator.kt$InputValidator$( wallet: Map&lt;String, Any&gt;?, user: Map&lt;String, Any&gt;?, subaccount: Map&lt;String, Any&gt;?, markets: Map&lt;String, Any&gt;?, input: Map&lt;String, Any&gt;?, configs: Map&lt;String, Any&gt;?, currentBlockAndHeight: BlockAndTime?, environment: V4Environment?, )</ID>
    <ID>LongParameterList:Market.kt$PerpetualMarket.Companion$( existing: PerpetualMarket?, parser: ParserProtocol, data: Map&lt;String, Any&gt;, assets: Map&lt;String, Any&gt;?, resetOrderbook: Boolean, resetTrades: Boolean, )</ID>
    <ID>LongParameterList:NetworkHelper.kt$NetworkHelper$( internal val deploymentUri: String, internal val environment: V4Environment, internal val uiImplementations: UIImplementations, internal val ioImplementations: IOImplementations, internal val configs: V4StateManagerConfigs, internal var stateNotification: StateNotificationProtocol?, internal var dataNotification: DataNotificationProtocol?, internal val parser: ParserProtocol, internal val indexerRestrictionChanged: (UsageRestriction?) -&gt; Unit )</ID>
    <ID>LongParameterList:NetworkHelper.kt$NetworkHelper$( url: String, items: List&lt;Any&gt;?, timeField: String, sampleDuration: Duration, maxDuration: Duration, beforeParam: String, afterParam: String? = null, additionalParams: Map&lt;String, String&gt;? = null, previousUrl: String?, callback: RestCallbackWithUrl, )</ID>
    <ID>LongParameterList:OnboardingSupervisor.kt$OnboardingSupervisor$( state: PerpetualState?, decimals: Int, gas: BigDecimal, accountAddress: String, sourceAddress: String, subaccountNumber: Int?, )</ID>
    <ID>LongParameterList:OnboardingSupervisor.kt$OnboardingSupervisor$( state: PerpetualState?, decimals: Int, gas: BigDecimal, accountAddress: String, subaccountNumber: Int?, callback: TransactionCallback )</ID>
    <ID>LongParameterList:ParsingHelper.kt$ParsingHelper.Companion$( parser: ParserProtocol, existing: List&lt;T&gt;?, data: List&lt;*&gt;?, comparison: ObjectAndDataComparisonBlock, createObject: ObjectCreationBlock, syncItems: Boolean = false, includesObjectBlock: IncludesObjectBlock? = null, includesDataBlock: IncludesDataBlock? = null, )</ID>
    <ID>LongParameterList:ParsingHelper.kt$ParsingHelper.Companion$( parser: ParserProtocol, existing: List&lt;T&gt;?, data: Map&lt;*, *&gt;?, key: ObjectKeyBlock, changed: ObjectAndDataChangedBlock, crossinline comparison: ObjectComparisonBlock, createObject: ObjectCreationBlock, )</ID>
    <ID>LongParameterList:ProtocolNativeImpFactory.kt$IOImplementations$( var rest: RestProtocol?, var webSocket: WebSocketProtocol?, var chain: DYDXChainTransactionsProtocol?, var tracking: TrackingProtocol?, var threading: ThreadingProtocol?, var timer: TimerProtocol?, var fileSystem: FileSystemProtocol?, )</ID>
    <ID>LongParameterList:ProtocolNativeImpFactory.kt$ProtocolNativeImpFactory$( var rest: RestProtocol? = null, var webSocket: WebSocketProtocol? = null, var chain: DYDXChainTransactionsProtocol? = null, var localizer: LocalizerProtocol? = null, var formatter: FormatterProtocol? = null, var tracking: TrackingProtocol? = null, var threading: ThreadingProtocol? = null, var timer: TimerProtocol? = null, var stateNotification: StateNotificationProtocol? = null, var dataNotification: DataNotificationProtocol? = null, var fileSystem: FileSystemProtocol? = null, var v3Signer: V3PrivateSignerProtocol? = null, var apiKey: V3ApiKey? = null, )</ID>
    <ID>LongParameterList:StateManagerAdaptor.kt$StateManagerAdaptor$( url: String, items: List&lt;Any&gt;?, timeField: String, sampleDuration: Duration, maxDuration: Duration, beforeParam: String, afterParam: String? = null, additionalParams: Map&lt;String, String&gt;? = null, previousUrl: String?, callback: (url: String, response: String?, httpCode: Int, headers: Map&lt;String, Any&gt;?) -&gt; Unit, )</ID>
    <ID>LongParameterList:StateManagerAdaptor.kt$StateManagerAdaptor$( val deploymentUri: String, val environment: V4Environment, val ioImplementations: IOImplementations, val uiImplementations: UIImplementations, open val configs: StateManagerConfigs, val appConfigs: AppConfigs, var stateNotification: StateNotificationProtocol?, var dataNotification: DataNotificationProtocol?, )</ID>
    <ID>LongParameterList:StateManagerAdaptorV2.kt$StateManagerAdaptorV2$( val deploymentUri: String, val environment: V4Environment, val ioImplementations: IOImplementations, val uiImplementations: UIImplementations, val configs: V4StateManagerConfigs, val appConfigs: AppConfigsV2, var stateNotification: StateNotificationProtocol?, var dataNotification: DataNotificationProtocol?, )</ID>
    <ID>LongParameterList:SubaccountTransformer.kt$SubaccountTransformer$( subaccount: Map&lt;String, Any&gt;?, trade: Map&lt;String, Any&gt;, market: Map&lt;String, Any&gt;?, parser: ParserProtocol, period: String, usePessimisticCollateralCheck: Boolean, useOptimisticCollateralCheck: Boolean, )</ID>
    <ID>LongParameterList:TradeInputCalculator.kt$TradeInputCalculator$( equity: Double, oraclePrice: Double, positionSize: Double?, isBuying: Boolean, feeRate: Double, leverage: Double, stepSize: Double, orderbook: List&lt;Map&lt;String, Any&gt;&gt;, )</ID>
    <ID>LongParameterList:TradeInputCalculator.kt$TradeInputCalculator$( trade: Map&lt;String, Any&gt;, market: Map&lt;String, Any&gt;?, subaccount: Map&lt;String, Any&gt;?, user: Map&lt;String, Any&gt;, isBuying: Boolean, input: String, )</ID>
    <ID>LongParameterList:TradeInputCalculator.kt$TradeInputCalculator$( trade: Map&lt;String, Any&gt;, subaccount: Map&lt;String, Any&gt;?, user: Map&lt;String, Any&gt;?, market: Map&lt;String, Any&gt;?, rewardsParams: Map&lt;String, Any&gt;?, feeTiers: List&lt;Any&gt;?, type: String, )</ID>
    <ID>LongParameterList:TradeInputValidator.kt$TradeInputValidator$( parser: ParserProtocol, subaccount: Map&lt;String, Any&gt;?, market: Map&lt;String, Any&gt;?, trade: Map&lt;String, Any&gt;, change: PositionChange, restricted: Boolean, )</ID>
    <ID>LongParameterList:TradingStateMachine.kt$TradingStateMachine$( url: AbUrl, payload: String, subaccountNumber: Int, height: Int?, deploymentUri: String? = null, period: String? = null, )</ID>
    <ID>LongParameterList:TransferStatus.kt$TransferStatus$( val status: String?, val gasStatus: String?, val axelarTransactionUrl: String?, val fromChainStatus: TransferChainStatus?, val toChainStatus: TransferChainStatus?, var routeStatuses: IList&lt;TransferRouteStatus&gt;?, val error: String?, val squidTransactionStatus: String?, )</ID>
    <ID>LongParameterList:V4StateManagerAdaptor.kt$V4StateManagerAdaptor$( deploymentUri: String, environment: V4Environment, ioImplementations: IOImplementations, uiImplementations: UIImplementations, override var configs: V4StateManagerConfigs, appConfigs: AppConfigs, stateNotification: StateNotificationProtocol?, dataNotification: DataNotificationProtocol?, )</ID>
    <ID>LongParameterList:ValidatorProtocols.kt$TradeValidatorProtocol$( subaccount: Map&lt;String, Any&gt;?, market: Map&lt;String, Any&gt;?, configs: Map&lt;String, Any&gt;?, trade: Map&lt;String, Any&gt;, change: PositionChange, restricted: Boolean, environment: V4Environment?, )</ID>
    <ID>LongParameterList:ValidatorProtocols.kt$TransferValidatorProtocol$( wallet: Map&lt;String, Any&gt;?, subaccount: Map&lt;String, Any&gt;?, transfer: Map&lt;String, Any&gt;, configs: Map&lt;String, Any&gt;?, currentBlockAndHeight: BlockAndTime?, restricted: Boolean, environment: V4Environment?, )</ID>
    <ID>LongParameterList:ValidatorProtocols.kt$ValidatorProtocol$( wallet: Map&lt;String, Any&gt;?, user: Map&lt;String, Any&gt;?, subaccount: Map&lt;String, Any&gt;?, markets: Map&lt;String, Any&gt;?, configs: Map&lt;String, Any&gt;?, currentBlockAndHeight: BlockAndTime?, transaction: Map&lt;String, Any&gt;, transactionType: String, environment: V4Environment?, )</ID>
    <ID>LoopWithTooManyJumpStatements:AccountCalculator.kt$AccountCalculator$for</ID>
    <ID>LoopWithTooManyJumpStatements:AsyncAbacusStateManager.kt$AsyncAbacusStateManager$for</ID>
    <ID>LoopWithTooManyJumpStatements:AsyncAbacusStateManagerV2.kt$AsyncAbacusStateManagerV2$for</ID>
    <ID>LoopWithTooManyJumpStatements:Enviroment.kt$V4Environment.Companion$for</ID>
    <ID>LoopWithTooManyJumpStatements:NotificationsProvider.kt$NotificationsProvider$for</ID>
    <ID>LoopWithTooManyJumpStatements:StateManagerAdaptor.kt$StateManagerAdaptor$for</ID>
    <ID>LoopWithTooManyJumpStatements:SubaccountSupervisor.kt$SubaccountSupervisor$for</ID>
    <ID>MagicNumber:AbacusHelper.kt$AbacusHelper.Companion$0.2</ID>
    <ID>MagicNumber:AbacusHelper.kt$AbacusHelper.Companion$0.4</ID>
    <ID>MagicNumber:AbacusHelper.kt$AbacusHelper.Companion$5</ID>
    <ID>MagicNumber:Account.kt$12</ID>
    <ID>MagicNumber:AccountSupervisor.kt$AccountSupervisor$10.0</ID>
    <ID>MagicNumber:AccountSupervisor.kt$AccountSupervisor$15.0</ID>
    <ID>MagicNumber:AccountSupervisor.kt$AccountSupervisor$5000</ID>
    <ID>MagicNumber:AccountSupervisor.kt$AccountSupervisor$60.0</ID>
    <ID>MagicNumber:AccountsSupervisor.kt$AccountsSupervisor$30</ID>
    <ID>MagicNumber:AccountsSupervisor.kt$AccountsSupervisor$7</ID>
    <ID>MagicNumber:AccountsSupervisor.kt$AccountsSupervisor$90</ID>
    <ID>MagicNumber:ApiUtils.kt$AbUrl$443</ID>
    <ID>MagicNumber:ApiUtils.kt$AbUrl$80</ID>
    <ID>MagicNumber:AsyncAbacusStateManager.kt$AsyncAbacusStateManager$200</ID>
    <ID>MagicNumber:AsyncAbacusStateManager.kt$AsyncAbacusStateManager$299</ID>
    <ID>MagicNumber:AsyncAbacusStateManagerV2.kt$AsyncAbacusStateManagerV2$200</ID>
    <ID>MagicNumber:AsyncAbacusStateManagerV2.kt$AsyncAbacusStateManagerV2$299</ID>
    <ID>MagicNumber:Bech32.kt$Bech32$0x07</ID>
    <ID>MagicNumber:Bech32.kt$Bech32$0x1ea119fa</ID>
    <ID>MagicNumber:Bech32.kt$Bech32$0x1ffffff</ID>
    <ID>MagicNumber:Bech32.kt$Bech32$0x26508e6d</ID>
    <ID>MagicNumber:Bech32.kt$Bech32$0x2a1462b3</ID>
    <ID>MagicNumber:Bech32.kt$Bech32$0x3b6a57b2</ID>
    <ID>MagicNumber:Bech32.kt$Bech32$0x3d4233dd</ID>
    <ID>MagicNumber:Bech32.kt$Bech32$0x7f</ID>
    <ID>MagicNumber:Bech32.kt$Bech32$0xff</ID>
    <ID>MagicNumber:Bech32.kt$Bech32$10</ID>
    <ID>MagicNumber:Bech32.kt$Bech32$11</ID>
    <ID>MagicNumber:Bech32.kt$Bech32$12</ID>
    <ID>MagicNumber:Bech32.kt$Bech32$126</ID>
    <ID>MagicNumber:Bech32.kt$Bech32$13</ID>
    <ID>MagicNumber:Bech32.kt$Bech32$14</ID>
    <ID>MagicNumber:Bech32.kt$Bech32$15</ID>
    <ID>MagicNumber:Bech32.kt$Bech32$16</ID>
    <ID>MagicNumber:Bech32.kt$Bech32$17</ID>
    <ID>MagicNumber:Bech32.kt$Bech32$18</ID>
    <ID>MagicNumber:Bech32.kt$Bech32$19</ID>
    <ID>MagicNumber:Bech32.kt$Bech32$20</ID>
    <ID>MagicNumber:Bech32.kt$Bech32$21</ID>
    <ID>MagicNumber:Bech32.kt$Bech32$22</ID>
    <ID>MagicNumber:Bech32.kt$Bech32$23</ID>
    <ID>MagicNumber:Bech32.kt$Bech32$24</ID>
    <ID>MagicNumber:Bech32.kt$Bech32$25</ID>
    <ID>MagicNumber:Bech32.kt$Bech32$26</ID>
    <ID>MagicNumber:Bech32.kt$Bech32$27</ID>
    <ID>MagicNumber:Bech32.kt$Bech32$28</ID>
    <ID>MagicNumber:Bech32.kt$Bech32$29</ID>
    <ID>MagicNumber:Bech32.kt$Bech32$3</ID>
    <ID>MagicNumber:Bech32.kt$Bech32$30</ID>
    <ID>MagicNumber:Bech32.kt$Bech32$31</ID>
    <ID>MagicNumber:Bech32.kt$Bech32$33</ID>
    <ID>MagicNumber:Bech32.kt$Bech32$4</ID>
    <ID>MagicNumber:Bech32.kt$Bech32$5</ID>
    <ID>MagicNumber:Bech32.kt$Bech32$6</ID>
    <ID>MagicNumber:Bech32.kt$Bech32$7</ID>
    <ID>MagicNumber:Bech32.kt$Bech32$8</ID>
    <ID>MagicNumber:Bech32.kt$Bech32$83</ID>
    <ID>MagicNumber:Bech32.kt$Bech32$9</ID>
    <ID>MagicNumber:Bech32.kt$Bech32$90</ID>
    <ID>MagicNumber:ConnectionStats.kt$ConnectionStats$1.5</ID>
    <ID>MagicNumber:ConnectionStats.kt$ConnectionStats$10.0</ID>
    <ID>MagicNumber:ConnectionStats.kt$ConnectionStats$15</ID>
    <ID>MagicNumber:ConnectionsSupervisor.kt$ConnectionsSupervisor$10.0</ID>
    <ID>MagicNumber:Double+Utils.kt$10</ID>
    <ID>MagicNumber:DynamicLocalizer.kt$DynamicLocalizer$200</ID>
    <ID>MagicNumber:DynamicLocalizer.kt$DynamicLocalizer$299</ID>
    <ID>MagicNumber:Enviroment.kt$V4Environment.Companion$18</ID>
    <ID>MagicNumber:Enviroment.kt$V4Environment.Companion$6</ID>
    <ID>MagicNumber:Formatter.kt$10</ID>
    <ID>MagicNumber:Formatter.kt$Formatter$10</ID>
    <ID>MagicNumber:Formatter.kt$Formatter$100</ID>
    <ID>MagicNumber:GoodTil.kt$GoodTil.Companion$7</ID>
    <ID>MagicNumber:InputValidator.kt$InputValidator$1000</ID>
    <ID>MagicNumber:InputValidator.kt$InputValidator$1001</ID>
    <ID>MagicNumber:InputValidator.kt$InputValidator$1002</ID>
    <ID>MagicNumber:InputValidator.kt$InputValidator$1010</ID>
    <ID>MagicNumber:InputValidator.kt$InputValidator$1020</ID>
    <ID>MagicNumber:InputValidator.kt$InputValidator$1021</ID>
    <ID>MagicNumber:InputValidator.kt$InputValidator$1022</ID>
    <ID>MagicNumber:InputValidator.kt$InputValidator$1030</ID>
    <ID>MagicNumber:InputValidator.kt$InputValidator$1031</ID>
    <ID>MagicNumber:InputValidator.kt$InputValidator$1032</ID>
    <ID>MagicNumber:InputValidator.kt$InputValidator$1033</ID>
    <ID>MagicNumber:InputValidator.kt$InputValidator$1034</ID>
    <ID>MagicNumber:InputValidator.kt$InputValidator$1040</ID>
    <ID>MagicNumber:InputValidator.kt$InputValidator$1041</ID>
    <ID>MagicNumber:InputValidator.kt$InputValidator$1042</ID>
    <ID>MagicNumber:InputValidator.kt$InputValidator$1043</ID>
    <ID>MagicNumber:InputValidator.kt$InputValidator$1044</ID>
    <ID>MagicNumber:InputValidator.kt$InputValidator$1051</ID>
    <ID>MagicNumber:InputValidator.kt$InputValidator$1052</ID>
    <ID>MagicNumber:InputValidator.kt$InputValidator$1053</ID>
    <ID>MagicNumber:InputValidator.kt$InputValidator$1060</ID>
    <ID>MagicNumber:InputValidator.kt$InputValidator$1061</ID>
    <ID>MagicNumber:InputValidator.kt$InputValidator$1070</ID>
    <ID>MagicNumber:InputValidator.kt$InputValidator$1071</ID>
    <ID>MagicNumber:InputValidator.kt$InputValidator$1080</ID>
    <ID>MagicNumber:InputValidator.kt$InputValidator$1081</ID>
    <ID>MagicNumber:InputValidator.kt$InputValidator$1082</ID>
    <ID>MagicNumber:InputValidator.kt$InputValidator$1083</ID>
    <ID>MagicNumber:InputValidator.kt$InputValidator$1090</ID>
    <ID>MagicNumber:InputValidator.kt$InputValidator$1091</ID>
    <ID>MagicNumber:InputValidator.kt$InputValidator$1092</ID>
    <ID>MagicNumber:InputValidator.kt$InputValidator$1093</ID>
    <ID>MagicNumber:InputValidator.kt$InputValidator$1100</ID>
    <ID>MagicNumber:InputValidator.kt$InputValidator$1200</ID>
    <ID>MagicNumber:InputValidator.kt$InputValidator$1201</ID>
    <ID>MagicNumber:InputValidator.kt$InputValidator$1202</ID>
    <ID>MagicNumber:InputValidator.kt$InputValidator$1203</ID>
    <ID>MagicNumber:InputValidator.kt$InputValidator$1204</ID>
    <ID>MagicNumber:LaunchIncentive.kt$LaunchIncentiveSeason.Companion$1000.0</ID>
    <ID>MagicNumber:MarketProcessor.kt$MarketProcessor$0.0001</ID>
    <ID>MagicNumber:MarketProcessor.kt$MarketProcessor$0.01</ID>
    <ID>MagicNumber:MarketProcessor.kt$MarketProcessor$15</ID>
    <ID>MagicNumber:MarketProcessor.kt$MarketProcessor$24</ID>
    <ID>MagicNumber:MarketProcessor.kt$MarketProcessor$30</ID>
    <ID>MagicNumber:MarketProcessor.kt$MarketProcessor$3600</ID>
    <ID>MagicNumber:MarketProcessor.kt$MarketProcessor$4</ID>
    <ID>MagicNumber:MarketProcessor.kt$MarketProcessor$5</ID>
    <ID>MagicNumber:MarketProcessor.kt$MarketProcessor$60</ID>
    <ID>MagicNumber:MarketSupervisor.kt$MarketSupervisor$365</ID>
    <ID>MagicNumber:MarketsSupervisor.kt$MarketsSupervisor$60.0</ID>
    <ID>MagicNumber:Network.kt$NetworkState$3</ID>
    <ID>MagicNumber:Network.kt$NetworkState$6</ID>
    <ID>MagicNumber:NetworkHelper.kt$NetworkHelper$200</ID>
    <ID>MagicNumber:NetworkHelper.kt$NetworkHelper$299</ID>
    <ID>MagicNumber:NetworkHelper.kt$NetworkHelper$403</ID>
    <ID>MagicNumber:NetworkHelper.kt$NetworkHelper$429</ID>
    <ID>MagicNumber:NetworkHelper.kt$NetworkHelper$5.0</ID>
    <ID>MagicNumber:NetworkHelper.kt$NetworkHelper$99</ID>
    <ID>MagicNumber:Notification.kt$NotificationPriority.URGENT$5</ID>
    <ID>MagicNumber:Numeric.kt$Decimals$10.0</ID>
    <ID>MagicNumber:Numeric.kt$Decimals$24</ID>
    <ID>MagicNumber:Numeric.kt$Doubles$10.0</ID>
    <ID>MagicNumber:OnboardingSupervisor.kt$OnboardingSupervisor$18</ID>
    <ID>MagicNumber:OnboardingSupervisor.kt$OnboardingSupervisor$6</ID>
    <ID>MagicNumber:Settings.kt$OrderbookGrouping.x10$10</ID>
    <ID>MagicNumber:Settings.kt$OrderbookGrouping.x100$100</ID>
    <ID>MagicNumber:Settings.kt$OrderbookGrouping.x1000$1000</ID>
    <ID>MagicNumber:SquidRouteProcessor.kt$SquidRouteProcessor$6</ID>
    <ID>MagicNumber:SquidRouteV2Processor.kt$SquidRouteV2Processor$6</ID>
    <ID>MagicNumber:StateManagerAdaptor.kt$StateManagerAdaptor$10.0</ID>
    <ID>MagicNumber:StateManagerAdaptor.kt$StateManagerAdaptor$127</ID>
    <ID>MagicNumber:StateManagerAdaptor.kt$StateManagerAdaptor$15.0</ID>
    <ID>MagicNumber:StateManagerAdaptor.kt$StateManagerAdaptor$200</ID>
    <ID>MagicNumber:StateManagerAdaptor.kt$StateManagerAdaptor$28.0</ID>
    <ID>MagicNumber:StateManagerAdaptor.kt$StateManagerAdaptor$299</ID>
    <ID>MagicNumber:StateManagerAdaptor.kt$StateManagerAdaptor$30</ID>
    <ID>MagicNumber:StateManagerAdaptor.kt$StateManagerAdaptor$365</ID>
    <ID>MagicNumber:StateManagerAdaptor.kt$StateManagerAdaptor$60.0</ID>
    <ID>MagicNumber:StateManagerAdaptor.kt$StateManagerAdaptor$7</ID>
    <ID>MagicNumber:StateManagerAdaptor.kt$StateManagerAdaptor$90</ID>
    <ID>MagicNumber:StateManagerAdaptor.kt$StateManagerAdaptor$99</ID>
    <ID>MagicNumber:StateManagerAdaptorV2.kt$StateManagerAdaptorV2$127</ID>
    <ID>MagicNumber:SubaccountCalculator.kt$SubaccountCalculator$0.05</ID>
    <ID>MagicNumber:SubaccountSupervisor.kt$SubaccountSupervisor$202</ID>
    <ID>MagicNumber:SubaccountSupervisor.kt$SubaccountSupervisor$28.0</ID>
    <ID>MagicNumber:TradeInputCalculator.kt$TradeInputCalculator$0.00001</ID>
    <ID>MagicNumber:TradeInputCalculator.kt$TradeInputCalculator$0.001</ID>
    <ID>MagicNumber:TradeInputCalculator.kt$TradeInputCalculator$0.01</ID>
    <ID>MagicNumber:TradeInputCalculator.kt$TradeInputCalculator$0.05</ID>
    <ID>MagicNumber:TradeInputCalculator.kt$TradeInputCalculator$0.1</ID>
    <ID>MagicNumber:TradeInputCalculator.kt$TradeInputCalculator$0.2</ID>
    <ID>MagicNumber:TradeInputCalculator.kt$TradeInputCalculator$28</ID>
    <ID>MagicNumber:TradeInputDataValidator.kt$TradeInputDataValidator$20</ID>
    <ID>MagicNumber:TradeMarketOrderInputValidator.kt$TradeMarketOrderInputValidator$0.05</ID>
    <ID>MagicNumber:TradeMarketOrderInputValidator.kt$TradeMarketOrderInputValidator$0.1</ID>
    <ID>MagicNumber:TradesProcessor.kt$TradesProcessor$500</ID>
    <ID>MagicNumber:TransferInputCalculator.kt$TransferInputCalculator$100.0</ID>
    <ID>MagicNumber:TriggerOrdersInputCalculator.kt$TriggerOrdersInputCalculator$0.05</ID>
    <ID>MagicNumber:TriggerOrdersInputCalculator.kt$TriggerOrdersInputCalculator$0.1</ID>
    <ID>MagicNumber:TriggerOrdersInputCalculator.kt$TriggerOrdersInputCalculator$0.2</ID>
    <ID>MagicNumber:TriggerOrdersInputCalculator.kt$TriggerOrdersInputCalculator$100</ID>
    <ID>MagicNumber:TriggerOrdersInputCalculator.kt$TriggerOrdersInputCalculator$100.0</ID>
    <ID>MagicNumber:TriggerOrdersInputValidator.kt$TriggerOrdersInputValidator$20</ID>
    <ID>MagicNumber:V4StateManagerAdaptor.kt$V4StateManagerAdaptor$1.5</ID>
    <ID>MagicNumber:V4StateManagerAdaptor.kt$V4StateManagerAdaptor$10.0</ID>
    <ID>MagicNumber:V4StateManagerAdaptor.kt$V4StateManagerAdaptor$18</ID>
    <ID>MagicNumber:V4StateManagerAdaptor.kt$V4StateManagerAdaptor$202</ID>
    <ID>MagicNumber:V4StateManagerAdaptor.kt$V4StateManagerAdaptor$403</ID>
    <ID>MagicNumber:V4StateManagerAdaptor.kt$V4StateManagerAdaptor$429</ID>
    <ID>MagicNumber:V4StateManagerAdaptor.kt$V4StateManagerAdaptor$5.0</ID>
    <ID>MagicNumber:V4StateManagerAdaptor.kt$V4StateManagerAdaptor$5000</ID>
    <ID>MagicNumber:V4StateManagerAdaptor.kt$V4StateManagerAdaptor$6</ID>
    <ID>MagicNumber:V4StateManagerAdaptor.kt$V4StateManagerAdaptor$60.0</ID>
    <ID>MagicNumber:WithdrawalCapacityProcessor.kt$WithdrawalCapacityProcessor$6</ID>
    <ID>MagicNumber:WithdrawalGatingValidator.kt$WithdrawalGatingValidator$1.1</ID>
    <ID>MagicNumber:WithdrawalGatingValidator.kt$WithdrawalGatingValidator$1.5</ID>
    <ID>MatchingDeclarationName:TradingStateMachine+ClosePositionInput.kt$ClosePositionInputField</ID>
    <ID>MatchingDeclarationName:TradingStateMachine+TradeInput.kt$TradeInputField</ID>
    <ID>MatchingDeclarationName:TradingStateMachine+TransferInput.kt$TransferInputField</ID>
    <ID>MatchingDeclarationName:TradingStateMachine+TriggerOrdersInput.kt$TriggerOrdersInputField</ID>
    <ID>MaxLineLength:Account.kt$SubaccountFundingPayment.Companion$if</ID>
    <ID>MaxLineLength:Account.kt$SubaccountOrder.Companion$// TODO: Remove default to 0 for subaccountNumber once new indexer response is consumed. Prevents breaking change</ID>
    <ID>MaxLineLength:Account.kt$SubaccountOrder.Companion$if</ID>
    <ID>MaxLineLength:AsyncAbacusStateManager.kt$AsyncAbacusStateManager$override</ID>
    <ID>MaxLineLength:BaseProcessor.kt$BaseProcessor$}</ID>
    <ID>MaxLineLength:Configs.kt$WithdrawalCapacity.Companion$return if (existing?.capacity != capacityAsString) WithdrawalCapacity(capacityAsString) else existing</ID>
    <ID>MaxLineLength:Configs.kt$WithdrawalGating.Companion$return</ID>
    <ID>MaxLineLength:ConnectionsSupervisor.kt$ConnectionsSupervisor$latestBlockAndTime.block + (lapsedTime.inWholeMilliseconds / averageMillisecondsPerBlock).toInt()</ID>
    <ID>MaxLineLength:Enviroment.kt$EnvironmentGovernance.Companion$val newMarketsMethodology = EnvironmentGovernanceNewMarketProposal.parse(newMarketsMethodologyData, parser) ?: return null</ID>
    <ID>MaxLineLength:Enviroment.kt$V4Environment.Companion$val governance = EnvironmentGovernance.parse(governanceData ?: parser.asNativeMap(data["governance"]) ?: return null, parser)</ID>
    <ID>MaxLineLength:EquityTierProcessor.kt$EquityTierProcessor$received["requiredTotalNetCollateralUSD"] = parser.asDouble(requiredTotalNetCollateralUSD / QUANTUM_MULTIPLIER)!!</ID>
    <ID>MaxLineLength:Network.kt$ApiState$return status == ApiStatus.INDEXER_DOWN || status == ApiStatus.INDEXER_HALTED || status == ApiStatus.VALIDATOR_DOWN || status == ApiStatus.VALIDATOR_HALTED</ID>
    <ID>MaxLineLength:NotificationsProvider.kt$NotificationsProvider$/* Short term orders should get filled/partially filled immediately, so we don't need to handle OPENED notification And it doesn't have a timestamp */</ID>
    <ID>MaxLineLength:NotificationsProvider.kt$NotificationsProvider$OrderType.stopLimit</ID>
    <ID>MaxLineLength:OnboardingSupervisor.kt$OnboardingSupervisor$OnboardingConfigs.SquidVersion.V1</ID>
    <ID>MaxLineLength:OrderProcessor.kt$/* { "subaccountNumber: 0, // new field "id": "3c5193d7a49805ffcf231af1ed446188f04aaa6756bf9df7b5913568b2763d7", "clientId": "69967309621008383", "market": "ETH-USD", "accountId": "dace1648-c854-5aed-9879-88899bf647a3", "side": "BUY", "size": "0.1", "remainingSize": "0.1", "limitFee": "0.002", "price": "1500", "triggerPrice": null, "trailingPercent": null, "type": "LIMIT", "status": "OPEN", "signature": "06f422ea494514293c6da82b70aca83f30718a01beb942f3e877a3ce8411d8f700d227caf5a57357df3dd66b38e2faff07147f29db539696e7d4799f32063172", "timeInForce": "GTT", "postOnly": false, "cancelReason": null, "expiresAt": "2022-08-29T22:45:30.776Z", "unfillableAt": null, "updatedAt": "2022-08-01T22:25:31.139Z", "createdAt": "2022-08-01T22:25:31.111Z", "reduceOnly": false, "country": "JP", "client": "01", "reduceOnlySize": null } to { "subaccountNumber": 0, "id": "45537274a3ef9afca657d9de73fb5fe5762f97336ce5502da0581e394dccdeb", "marketId": "ETH-USD", "price": 1192.5, "triggerPrice": null, "trailingPercent": null, "size": 2, "remainingSize": 2, "createdAtMilliseconds": 80092349090234, "unfillableAtMilliseconds": null, "expiresAtMilliseconds": 80092349090234, "postOnly": false, "reduceOnly": false, "cancelReason": null, "resources": { "sideStringKey": "BUY", "typeStringKey": "LIMIT", "statusStringKey": "OPEN", "timeInForceStringKey": "GTT" } } */</ID>
    <ID>MaxLineLength:Rounder.kt$Rounder.Companion$fun</ID>
    <ID>MaxLineLength:SquidProcessor.kt$SquidProcessor$// Fallback to the first token's address from the filtered list if no CctpChainTokenInfo match is found</ID>
    <ID>MaxLineLength:StateManagerAdaptor.kt$StateManagerAdaptor$if</ID>
    <ID>MaxLineLength:StateManagerAdaptor.kt$StateManagerAdaptor$it.amount == transfer.amount &amp;&amp; it.timestampInMilliseconds &lt; transfer.updatedAtMilliseconds</ID>
    <ID>MaxLineLength:StateManagerAdaptor.kt$StateManagerAdaptor$private</ID>
    <ID>MaxLineLength:StateManagerAdaptor.kt$StateManagerAdaptor$val duration = GoodTil.duration(TradeInputGoodUntil(TRIGGER_ORDER_DEFAULT_DURATION_DAYS, "D")) ?: throw Exception("invalid duration")</ID>
    <ID>MaxLineLength:StateResponse.kt$StateResponse$val mergedChanges = this.changes?.merge(earlierResponse.changes ?: StateChanges(iListOf&lt;Changes&gt;())) ?: earlierResponse.changes</ID>
    <ID>MaxLineLength:StateResponse.kt$StateResponse$val mergedErrors = this.errors?.toSet()?.union(earlierResponse.errors?.toSet() ?: setOf())?.toIList() ?: earlierResponse.errors</ID>
    <ID>MaxLineLength:StringHelper.kt$StringHelper.Companion$beforeDecimal + afterDecimal + StringHelper.zeros(shift - afterDecimal.length)</ID>
    <ID>MaxLineLength:StringHelper.kt$StringHelper.Companion$string.substring(0, string.length - decimals.toInt()) + StringHelper.decimals(string.substring(string.length - decimals.toInt()))</ID>
    <ID>MaxLineLength:SubaccountCalculator.kt$SubaccountCalculator$if (positionEntryValue &gt; Numeric.double.ZERO) realizedPnl / positionEntryValue else null</ID>
    <ID>MaxLineLength:SubaccountCalculator.kt$SubaccountCalculator$if (size &gt; Numeric.double.ZERO) (size - size * maintenanceMarginFraction) else (size + size * maintenanceMarginFraction)</ID>
    <ID>MaxLineLength:SubaccountSupervisor.kt$SubaccountSupervisor$if (isCancel) AnalyticsEvent.TradeCancelOrderClick.rawValue else AnalyticsEvent.TradePlaceOrderClick.rawValue</ID>
    <ID>MaxLineLength:SubaccountSupervisor.kt$SubaccountSupervisor$if (isCancel) AnalyticsEvent.TradeCancelOrderSubmissionConfirmed.rawValue else AnalyticsEvent.TradePlaceOrderSubmissionConfirmed.rawValue</ID>
    <ID>MaxLineLength:SubaccountSupervisor.kt$SubaccountSupervisor$if (isCancel) AnalyticsEvent.TradeCancelOrderSubmissionFailed.rawValue else AnalyticsEvent.TradePlaceOrderSubmissionFailed.rawValue</ID>
    <ID>MaxLineLength:SubaccountSupervisor.kt$SubaccountSupervisor$if (isShortTermOrder(trade.type.rawValue, trade.timeInForce)) currentHeight?.plus(SHORT_TERM_ORDER_DURATION) else null</ID>
    <ID>MaxLineLength:SubaccountSupervisor.kt$SubaccountSupervisor$internal</ID>
    <ID>MaxLineLength:SubaccountSupervisor.kt$SubaccountSupervisor$it.amount == transfer.amount &amp;&amp; it.timestampInMilliseconds &lt; transfer.updatedAtMilliseconds</ID>
    <ID>MaxLineLength:SubaccountSupervisor.kt$SubaccountSupervisor$private</ID>
    <ID>MaxLineLength:SubaccountSupervisor.kt$SubaccountSupervisor$val duration = GoodTil.duration(TradeInputGoodUntil(TRIGGER_ORDER_DEFAULT_DURATION_DAYS, "D")) ?: throw Exception("invalid duration")</ID>
    <ID>MaxLineLength:SystemSupervisor.kt$SystemSupervisor$"{\"operationName\":\"TradingSeasons\",\"variables\":{},\"query\":\"query TradingSeasons {tradingSeasons {startTimestamp label __typename }}\"}"</ID>
    <ID>MaxLineLength:TradeInputCalculator.kt$TradeInputCalculator$/* leverage = (size * oracle_price) / account_equity leverage and size are signed new_account_equity = old_account_equity + order_size * (oracle_price - market_price) - abs(order_size) * market_price * fee rate order_size is signed (old_size + order_size) * oracle_price = leverage * (old_account_equity + order_size * (oracle_price - market_price) - abs(order_size) * market_price * fee_rate) X = order_size SZ = old_size OR = oracle_price AE = account_equity MP = market price FR = fee rate LV = leverage PS = positionSign LONG ? 1 : -1 OS = orderSign BUY ? 1 : -1 (SZ + X) * OR = LV * (AE + X * (OR - MP) - OS * X * MP * FR) SZ * OR + OR * X = LV * AE + LV * X * (OR - MP) - OS * LV * MP * FR * X OR * X + OS * LV * MP * FR * X - LV * X * (OR - MP) = LV * AE - SZ * OR X = (LV * AE - SZ * OR) / (OR + OS * LV * MP * FR - LV * (OR - MP)) X = (LV * AE - SZ * OR) / (OR + OS * LV * MP * FR - LV * (OR - MP)) new(AE) = AE + X * (OR - MP) - abs(X) * MP * FR */</ID>
    <ID>MaxLineLength:TradeInputCalculator.kt$TradeInputCalculator$// TODO: When the collateral of child subaccounts is implemented, return from here. The below code is the CROSS implementation.</ID>
    <ID>MaxLineLength:TradeInputCalculator.kt$TradeInputCalculator$if</ID>
    <ID>MaxLineLength:TradeInputDataValidator.kt$TradeInputDataValidator$(status == "OPEN" || status == "PENDING" || status == "UNTRIGGERED" || status == "PARTIALLY_FILLED")</ID>
    <ID>MaxLineLength:TradingStateMachine+HistoricalPnl.kt$internal</ID>
    <ID>MaxLineLength:TradingStateMachine+HistoricalTradingRewards.kt$internal</ID>
    <ID>MaxLineLength:TradingStateMachine+ParentSubaccount.kt$val groupedFills = parser.asNativeList(parser.value(account, "groupedSubaccounts.$parentSubaccountNumber.fills"))</ID>
    <ID>MaxLineLength:TradingStateMachine+ParentSubaccount.kt$val groupedTransfers = parser.asNativeList(parser.value(account, "groupedSubaccounts.$parentSubaccountNumber.transfers"))</ID>
    <ID>MaxLineLength:TradingStateMachine+TransferInput.kt$changes = StateChanges(iListOf(Changes.wallet, Changes.subaccount, Changes.input), null, iListOf(subaccountNumber))</ID>
    <ID>MaxLineLength:TransferStatus.kt$TransferStatus.Companion$TransferStatus(status, gasStatus, axelarTransactionUrl, fromChainStatus, toChainStatus, routeStatuses, error, squidTransactionStatus)</ID>
    <ID>MaxLineLength:TriggerOrdersInputCalculator.kt$TriggerOrdersInputCalculator$"long" -&gt; entryPrice.minus(percentDiff.times(scaledNotionalTotal).div(leverage.times(size)))</ID>
    <ID>MaxLineLength:TriggerOrdersInputCalculator.kt$TriggerOrdersInputCalculator$"long" -&gt; entryPrice.plus(percentDiff.times(scaledNotionalTotal).div(leverage.times(size)))</ID>
    <ID>MaxLineLength:TriggerOrdersInputCalculator.kt$TriggerOrdersInputCalculator$"long" -&gt; size.times(leverage.times(entryPrice.minus(triggerPrice))).div(scaledNotionalTotal).times(100)</ID>
    <ID>MaxLineLength:TriggerOrdersInputCalculator.kt$TriggerOrdersInputCalculator$"long" -&gt; size.times(leverage.times(triggerPrice.minus(entryPrice))).div(scaledNotionalTotal).times(100)</ID>
    <ID>MaxLineLength:TriggerOrdersInputCalculator.kt$TriggerOrdersInputCalculator$"short" -&gt; entryPrice.minus(percentDiff.times(scaledNotionalTotal).div(leverage.times(size)))</ID>
    <ID>MaxLineLength:TriggerOrdersInputCalculator.kt$TriggerOrdersInputCalculator$"short" -&gt; entryPrice.plus(percentDiff.times(scaledNotionalTotal).div(leverage.times(size)))</ID>
    <ID>MaxLineLength:TriggerOrdersInputCalculator.kt$TriggerOrdersInputCalculator$"short" -&gt; size.times(leverage.times(entryPrice.minus(triggerPrice))).div(scaledNotionalTotal).times(100)</ID>
    <ID>MaxLineLength:TriggerOrdersInputCalculator.kt$TriggerOrdersInputCalculator$"short" -&gt; size.times(leverage.times(triggerPrice.minus(entryPrice))).div(scaledNotionalTotal).times(100)</ID>
    <ID>MaxLineLength:TriggerOrdersInputCalculator.kt$TriggerOrdersInputCalculator$if</ID>
    <ID>MaxLineLength:TriggerOrdersInputCalculator.kt$TriggerOrdersInputCalculator$private</ID>
    <ID>MaxLineLength:TriggerOrdersInputCalculator.kt$TriggerOrdersInputCalculator$val triggerPrices = parser.asNativeMap(triggerOrder["price"])?.let { calculateTriggerPrices(it, position, absSize) }</ID>
    <ID>MaxLineLength:TriggerOrdersInputValidator.kt$TriggerOrdersInputValidator$(status == "OPEN" || status == "PENDING" || status == "UNTRIGGERED" || status == "PARTIALLY_FILLED")</ID>
    <ID>MaxLineLength:TriggerOrdersInputValidator.kt$TriggerOrdersInputValidator$if</ID>
    <ID>MaxLineLength:TriggerOrdersInputValidator.kt$TriggerOrdersInputValidator$if (type == "STOP_LIMIT" || type == "STOP_MARKET") "ERRORS.TRIGGERS_FORM.STOP_LOSS_TRIGGER_MUST_ABOVE_INDEX_PRICE" else "ERRORS.TRIGGERS_FORM.TAKE_PROFIT_TRIGGER_MUST_ABOVE_INDEX_PRICE"</ID>
    <ID>MaxLineLength:TriggerOrdersInputValidator.kt$TriggerOrdersInputValidator$if (type == "STOP_LIMIT" || type == "STOP_MARKET") "ERRORS.TRIGGERS_FORM.STOP_LOSS_TRIGGER_MUST_BELOW_INDEX_PRICE" else "ERRORS.TRIGGERS_FORM.TAKE_PROFIT_TRIGGER_MUST_BELOW_INDEX_PRICE"</ID>
    <ID>MaxLineLength:TriggerOrdersInputValidator.kt$TriggerOrdersInputValidator$if (type == "STOP_LIMIT" || type == "STOP_MARKET") "ERRORS.TRIGGERS_FORM_TITLE.STOP_LOSS_TRIGGER_MUST_ABOVE_INDEX_PRICE" else "ERRORS.TRIGGERS_FORM_TITLE.TAKE_PROFIT_TRIGGER_MUST_ABOVE_INDEX_PRICE"</ID>
    <ID>MaxLineLength:TriggerOrdersInputValidator.kt$TriggerOrdersInputValidator$if (type == "STOP_LIMIT" || type == "STOP_MARKET") "ERRORS.TRIGGERS_FORM_TITLE.STOP_LOSS_TRIGGER_MUST_BELOW_INDEX_PRICE" else "ERRORS.TRIGGERS_FORM_TITLE.TAKE_PROFIT_TRIGGER_MUST_BELOW_INDEX_PRICE"</ID>
    <ID>MaxLineLength:TriggerOrdersInputValidator.kt$TriggerOrdersInputValidator$if (type == "STOP_LIMIT") "ERRORS.TRIGGERS_FORM.STOP_LOSS_LIMIT_MUST_ABOVE_TRIGGER_PRICE" else "ERRORS.TRIGGERS_FORM.TAKE_PROFIT_LIMIT_MUST_ABOVE_TRIGGER_PRICE"</ID>
    <ID>MaxLineLength:TriggerOrdersInputValidator.kt$TriggerOrdersInputValidator$if (type == "STOP_LIMIT") "ERRORS.TRIGGERS_FORM.STOP_LOSS_LIMIT_MUST_BELOW_TRIGGER_PRICE" else "ERRORS.TRIGGERS_FORM.TAKE_PROFIT_LIMIT_MUST_BELOW_TRIGGER_PRICE"</ID>
    <ID>MaxLineLength:TriggerOrdersInputValidator.kt$TriggerOrdersInputValidator$if (type == "STOP_LIMIT") "ERRORS.TRIGGERS_FORM_TITLE.STOP_LOSS_LIMIT_MUST_ABOVE_TRIGGER_PRICE" else "ERRORS.TRIGGERS_FORM_TITLE.TAKE_PROFIT_LIMIT_MUST_ABOVE_TRIGGER_PRICE"</ID>
    <ID>MaxLineLength:TriggerOrdersInputValidator.kt$TriggerOrdersInputValidator$if (type == "STOP_LIMIT") "ERRORS.TRIGGERS_FORM_TITLE.STOP_LOSS_LIMIT_MUST_BELOW_TRIGGER_PRICE" else "ERRORS.TRIGGERS_FORM_TITLE.TAKE_PROFIT_LIMIT_MUST_BELOW_TRIGGER_PRICE"</ID>
    <ID>MaxLineLength:TriggerOrdersInputValidator.kt$TriggerOrdersInputValidator$}</ID>
    <ID>MaxLineLength:V4StateManagerAdaptor.kt$V4StateManagerAdaptor$"{\"operationName\":\"TradingSeasons\",\"variables\":{},\"query\":\"query TradingSeasons {tradingSeasons {startTimestamp label __typename }}\"}"</ID>
    <ID>MaxLineLength:V4StateManagerAdaptor.kt$V4StateManagerAdaptor$if (isCancel) AnalyticsEvent.TradeCancelOrderClick.rawValue else AnalyticsEvent.TradePlaceOrderClick.rawValue</ID>
    <ID>MaxLineLength:V4StateManagerAdaptor.kt$V4StateManagerAdaptor$if (isCancel) AnalyticsEvent.TradeCancelOrderSubmissionConfirmed.rawValue else AnalyticsEvent.TradePlaceOrderSubmissionConfirmed.rawValue</ID>
    <ID>MaxLineLength:V4StateManagerAdaptor.kt$V4StateManagerAdaptor$if (isCancel) AnalyticsEvent.TradeCancelOrderSubmissionFailed.rawValue else AnalyticsEvent.TradePlaceOrderSubmissionFailed.rawValue</ID>
    <ID>MaxLineLength:V4StateManagerAdaptor.kt$V4StateManagerAdaptor$latestBlockAndTime.block + (lapsedTime.inWholeMilliseconds / averageMillisecondsPerBlock).toInt()</ID>
    <ID>MaxLineLength:WithdrawalCapacityValidator.kt$WithdrawalCapacityValidator$val maxWithdrawalCapacity = parser.asDecimal(parser.value(withdrawalCapacity, "maxWithdrawalCapacity")) ?: BigDecimal.fromLong(Long.MAX_VALUE)</ID>
    <ID>MaxLineLength:WithdrawalGatingValidator.kt$WithdrawalGatingValidator$"WARNINGS.ACCOUNT_FUND_MANAGEMENT.${if (type == TransferType.withdrawal.rawValue) "WITHDRAWAL_PAUSED_ACTION" else "TRANSFERS_PAUSED_ACTION"}"</ID>
    <ID>MaxLineLength:WithdrawalGatingValidator.kt$WithdrawalGatingValidator$"WARNINGS.ACCOUNT_FUND_MANAGEMENT.${if (type == TransferType.withdrawal.rawValue) "WITHDRAWAL_PAUSED_DESCRIPTION" else "TRANSFERS_PAUSED_DESCRIPTION"}"</ID>
    <ID>MaxLineLength:WithdrawalGatingValidator.kt$WithdrawalGatingValidator$"WARNINGS.ACCOUNT_FUND_MANAGEMENT.${if (type == TransferType.withdrawal.rawValue) "WITHDRAWAL_PAUSED_TITLE" else "TRANSFERS_PAUSED_TITLE"}"</ID>
    <ID>MaxLineLength:WithdrawalGatingValidator.kt$WithdrawalGatingValidator$val currentBlock = currentBlockAndHeight?.block ?: Int.MAX_VALUE // parser.asInt(parser.value(environment, "currentBlock"))</ID>
    <ID>MaxLineLength:WithdrawalGatingValidator.kt$WithdrawalGatingValidator$val secondsUntilUnblock = ((withdrawalsAndTransfersUnblockedAtBlock - currentBlock) * blockDurationSeconds).toInt()</ID>
    <ID>MaxLineLength:WithdrawalGatingValidator.kt$WithdrawalGatingValidator$val withdrawalsAndTransfersUnblockedAtBlock = parser.asInt(withdrawalGating?.get("withdrawalsAndTransfersUnblockedAtBlock")) ?: 0</ID>
    <ID>MemberNameEqualsClassName:Market.kt$PerpetualMarketSummary.Companion$private fun perpetualMarketSummary( existing: PerpetualMarketSummary?, parser: ParserProtocol, data: Map&lt;String, Any&gt;, newMarkets: IMutableMap&lt;String, PerpetualMarket&gt;, ): PerpetualMarketSummary?</ID>
    <ID>NestedBlockDepth:Account.kt$Account.Companion$internal fun create( existing: Account?, parser: ParserProtocol, data: Map&lt;String, Any&gt;, tokensInfo: Map&lt;String, TokenInfo&gt;, localizer: LocalizerProtocol?, ): Account</ID>
    <ID>NestedBlockDepth:Account.kt$SubaccountOrderResources.Companion$internal fun create( existing: SubaccountOrderResources?, parser: ParserProtocol, data: Map&lt;*, *&gt;?, localizer: LocalizerProtocol?, ): SubaccountOrderResources?</ID>
    <ID>NestedBlockDepth:Account.kt$TradingRewards.Companion$private fun createHistoricalTradingRewardsPerPeriod( objs: IList&lt;HistoricalTradingReward&gt;?, data: List&lt;Any&gt;?, parser: ParserProtocol, period: String, ): IList&lt;HistoricalTradingReward&gt;</ID>
    <ID>NestedBlockDepth:AccountCalculator.kt$AccountCalculator$private fun groupSubaccounts( existing: Map&lt;String, Any&gt;, markets: Map&lt;String, Any&gt;? ): MutableMap&lt;String, Any&gt;</ID>
    <ID>NestedBlockDepth:AccountProcessor.kt$SubaccountProcessor$private fun modify( positions: Map&lt;String, Any&gt;?, orders: List&lt;*&gt;?, state: String, ): Map&lt;String, Any&gt;</ID>
    <ID>NestedBlockDepth:AccountProcessor.kt$V4AccountBalancesProcessor$fun receivedBalances( existing: Map&lt;String, Any&gt;?, payload: List&lt;Any&gt;?, ): Map&lt;String, Any&gt;?</ID>
    <ID>NestedBlockDepth:AccountProcessor.kt$V4AccountDelegationsProcessor$fun received( existing: Map&lt;String, Any&gt;?, payload: List&lt;Any&gt;?, ): Map&lt;String, Any&gt;?</ID>
    <ID>NestedBlockDepth:AccountProcessor.kt$V4AccountProcessor$private fun subscribedParentSubaccount( existing: Map&lt;String, Any&gt;, content: Map&lt;String, Any&gt;, height: BlockAndTime?, ): Map&lt;String, Any&gt;</ID>
    <ID>NestedBlockDepth:AccountProcessor.kt$V4SubaccountsProcessor$internal fun receivedSubaccounts( existing: Map&lt;String, Any&gt;?, payload: List&lt;Any&gt;?, ): Map&lt;String, Any&gt;?</ID>
    <ID>NestedBlockDepth:AssetPositionsProcessor.kt$AssetPositionsProcessor$internal fun receivedChanges( existing: Map&lt;String, Any&gt;?, payload: List&lt;Any&gt;? ): Map&lt;String, Any&gt;?</ID>
    <ID>NestedBlockDepth:BaseInputValidator.kt$BaseInputValidator$private fun localize(stringKey: String?, params: Map&lt;String, Any&gt;? = null): String?</ID>
    <ID>NestedBlockDepth:BaseProcessor.kt$BaseProcessor$internal fun transform( existing: Map&lt;String, Any&gt;?, input: Map&lt;*, *&gt;?, keymap: Map&lt;String, Map&lt;String, String&gt;&gt; ): MutableMap&lt;String, Any&gt;</ID>
    <ID>NestedBlockDepth:Configs.kt$FeeDiscount.Companion$internal fun create( existing: IList&lt;FeeDiscount&gt;?, parser: ParserProtocol, data: List&lt;*&gt;?, localizer: LocalizerProtocol?, ): IList&lt;FeeDiscount&gt;?</ID>
    <ID>NestedBlockDepth:Configs.kt$FeeTier.Companion$internal fun create( existing: IList&lt;FeeTier&gt;?, parser: ParserProtocol, data: List&lt;*&gt;?, localizer: LocalizerProtocol?, ): IList&lt;FeeTier&gt;?</ID>
    <ID>NestedBlockDepth:Configs.kt$WithdrawalCapacity.Companion$internal fun create( existing: WithdrawalCapacity?, parser: ParserProtocol, data: Map&lt;*, *&gt;? ): WithdrawalCapacity?</ID>
    <ID>NestedBlockDepth:ConnectionStats.kt$ConnectionStats$private fun apiState( apiState: ApiState?, indexerState: NetworkState, validatorState: NetworkState, ): ApiState</ID>
    <ID>NestedBlockDepth:ConnectionsSupervisor.kt$ConnectionsSupervisor$internal fun calculateCurrentHeight(): Int?</ID>
    <ID>NestedBlockDepth:DynamicLocalizer.kt$DynamicLocalizer$override fun setLanguage( language: String, callback: (successful: Boolean, error: ParsingError?) -&gt; Unit, )</ID>
    <ID>NestedBlockDepth:DynamicLocalizer.kt$DynamicLocalizer$private fun localize( path: String, params: Map&lt;String, Any&gt;?, data: Map&lt;String, Any&gt;, ): String?</ID>
    <ID>NestedBlockDepth:Enviroment.kt$V4Environment.Companion$private fun parseTokens( item: Map&lt;String, Any&gt;?, parser: ParserProtocol, deploymentUri: String, ): IMap&lt;String, TokenInfo&gt;</ID>
    <ID>NestedBlockDepth:EquityTiersProcessor.kt$EquityTiersProcessor$internal fun received( payload: Map&lt;String, Map&lt;String, List&lt;Any&gt;&gt;&gt;? ): Map&lt;String, Any&gt;?</ID>
    <ID>NestedBlockDepth:FieldsInputValidator.kt$FieldsInputValidator$override fun validate( wallet: Map&lt;String, Any&gt;?, user: Map&lt;String, Any&gt;?, subaccount: Map&lt;String, Any&gt;?, markets: Map&lt;String, Any&gt;?, configs: Map&lt;String, Any&gt;?, currentBlockAndHeight: BlockAndTime?, transaction: Map&lt;String, Any&gt;, transactionType: String, environment: V4Environment?, ): List&lt;Any&gt;?</ID>
    <ID>NestedBlockDepth:Market.kt$CandleOption.Companion$fun create( existing: IList&lt;CandleOption&gt;?, parser: ParserProtocol, data: List&lt;Map&lt;String, Any&gt;&gt;? ): IList&lt;CandleOption&gt;?</ID>
    <ID>NestedBlockDepth:Market.kt$MarketCandle.Companion$internal fun create( existing: MarketCandle?, parser: ParserProtocol, data: Map&lt;*, *&gt;?, ): MarketCandle?</ID>
    <ID>NestedBlockDepth:MarketProcessor.kt$MarketProcessor$internal fun receivedCandles( market: Map&lt;String, Any&gt;, payload: List&lt;Any&gt;, ): Map&lt;String, Any&gt;</ID>
    <ID>NestedBlockDepth:MarketProcessor.kt$MarketProcessor$private fun line(market: Map&lt;String, Any&gt;): List&lt;Double&gt;?</ID>
    <ID>NestedBlockDepth:MarketsProcessor.kt$MarketsProcessor$internal fun receivedCandles( existing: Map&lt;String, Any&gt;?, payload: Map&lt;String, Any&gt; ): Map&lt;String, Any&gt;?</ID>
    <ID>NestedBlockDepth:MarketsProcessor.kt$MarketsProcessor$internal fun receivedSparklines( existing: Map&lt;String, Any&gt;?, payload: Map&lt;String, Any&gt; ): Map&lt;String, Any&gt;</ID>
    <ID>NestedBlockDepth:NetworkHelper.kt$NetworkHelper$internal fun retrieveTimed( url: String, items: List&lt;Any&gt;?, timeField: String, sampleDuration: Duration, maxDuration: Duration, beforeParam: String, afterParam: String? = null, additionalParams: Map&lt;String, String&gt;? = null, previousUrl: String?, callback: RestCallbackWithUrl, )</ID>
    <ID>NestedBlockDepth:NetworkHelper.kt$NetworkHelper$internal fun updateStateChanges( stateMachine: TradingStateMachine, changes: StateChanges?, oldState: PerpetualState?, )</ID>
    <ID>NestedBlockDepth:NotificationsProvider.kt$NotificationsProvider$private fun buildFillsNotifications( stateMachine: TradingStateMachine, subaccountNumber: Int ): Map&lt;String, Notification&gt;</ID>
    <ID>NestedBlockDepth:OnboardingSupervisor.kt$OnboardingSupervisor$private fun didUpdateStateForTransfer( data: String?, type: TransferInputField?, accountAddress: String, sourceAddress: String, subaccountNumber: Int? )</ID>
    <ID>NestedBlockDepth:OrderProcessor.kt$OrderProcessor$override fun received( existing: Map&lt;String, Any&gt;?, payload: Map&lt;String, Any&gt;, height: BlockAndTime?, ): Map&lt;String, Any&gt;?</ID>
    <ID>NestedBlockDepth:OrderbookProcessor.kt$OrderbookProcessor$fun consolidate(orderbook: Map&lt;String, Any&gt;?, stepSize: Double): Map&lt;String, Any&gt;?</ID>
    <ID>NestedBlockDepth:OrderbookProcessor.kt$OrderbookProcessor$fun group(orderbook: List&lt;Any&gt;?, grouping: Double): List&lt;Any&gt;?</ID>
    <ID>NestedBlockDepth:OrderbookProcessor.kt$OrderbookProcessor$private fun receiveChangeBinary( existing: List&lt;Map&lt;String, Any&gt;&gt;, change: Any, offset: Long?, comparator: Comparator&lt;Map&lt;String, Any&gt;&gt; ): MutableList&lt;Map&lt;String, Any&gt;&gt;</ID>
    <ID>NestedBlockDepth:OrderbookProcessor.kt$OrderbookProcessor$private fun receivedChangesLinear( existing: List&lt;Map&lt;String, Any&gt;&gt;?, changes: List&lt;Any&gt;, offset: Long?, ascending: Boolean ): List&lt;Map&lt;String, Any&gt;&gt;</ID>
    <ID>NestedBlockDepth:OrdersProcessor.kt$OrdersProcessor$internal fun received( existing: Map&lt;String, Any&gt;?, payload: List&lt;Any&gt;?, height: BlockAndTime? ): Map&lt;String, Any&gt;?</ID>
    <ID>NestedBlockDepth:Parser.kt$Parser$private fun value(data: Any?, path: IMutableList&lt;String&gt;): Any?</ID>
    <ID>NestedBlockDepth:ParsingHelper.kt$ParsingHelper.Companion$internal fun &lt;T : Any&gt; merge( parser: ParserProtocol, existing: List&lt;T&gt;?, data: List&lt;*&gt;?, comparison: ObjectAndDataComparisonBlock, createObject: ObjectCreationBlock, syncItems: Boolean = false, includesObjectBlock: IncludesObjectBlock? = null, includesDataBlock: IncludesDataBlock? = null, ): List&lt;T&gt;?</ID>
    <ID>NestedBlockDepth:ParsingHelper.kt$ParsingHelper.Companion$internal fun compare( value1: Instant?, value2: Instant?, ascending: Boolean, ): ComparisonOrder</ID>
    <ID>NestedBlockDepth:ParsingHelper.kt$ParsingHelper.Companion$internal inline fun &lt;reified T : Any&gt; transform( parser: ParserProtocol, existing: List&lt;T&gt;?, data: Map&lt;*, *&gt;?, key: ObjectKeyBlock, changed: ObjectAndDataChangedBlock, crossinline comparison: ObjectComparisonBlock, createObject: ObjectCreationBlock, ): List&lt;T&gt;?</ID>
    <ID>NestedBlockDepth:ParsingHelper.kt$ParsingHelper.Companion$private fun mergeMap( existing: Map&lt;String, Any&gt;?, incoming: Map&lt;String, Any&gt;?, ): Map&lt;String, Any&gt;?</ID>
    <ID>NestedBlockDepth:PerpetualPositionsProcessor.kt$PerpetualPositionsProcessor$internal fun receivedChanges( existing: Map&lt;String, Any&gt;?, payload: List&lt;Any&gt;?, ): Map&lt;String, Any&gt;?</ID>
    <ID>NestedBlockDepth:SquidProcessor.kt$SquidProcessor$internal fun tokenOptions(chainId: String?): List&lt;Any&gt;</ID>
    <ID>NestedBlockDepth:SquidProcessor.kt$SquidProcessor$private fun chainOptions(): List&lt;Any&gt;</ID>
    <ID>NestedBlockDepth:SquidProcessor.kt$SquidProcessor$private fun filteredTokens(chainId: String?): List&lt;Any&gt;?</ID>
    <ID>NestedBlockDepth:StateManagerAdaptor.kt$StateManagerAdaptor$internal fun retrieveTimed( url: String, items: List&lt;Any&gt;?, timeField: String, sampleDuration: Duration, maxDuration: Duration, beforeParam: String, afterParam: String? = null, additionalParams: Map&lt;String, String&gt;? = null, previousUrl: String?, callback: (url: String, response: String?, httpCode: Int, headers: Map&lt;String, Any&gt;?) -&gt; Unit, )</ID>
    <ID>NestedBlockDepth:StateManagerAdaptor.kt$StateManagerAdaptor$internal open fun didSetSubaccount(subaccount: Subaccount?, oldValue: Subaccount?)</ID>
    <ID>NestedBlockDepth:StateManagerAdaptor.kt$StateManagerAdaptor$private fun parseTransfersToMatchFaucetRecords()</ID>
    <ID>NestedBlockDepth:StateManagerAdaptor.kt$StateManagerAdaptor$private fun updateStateChanges( state: PerpetualState?, changes: StateChanges?, oldState: PerpetualState?, )</ID>
    <ID>NestedBlockDepth:SubaccountCalculator.kt$SubaccountCalculator$private fun calculatePositionLiquidationPrice( equity: Double, market: String, positions: Map&lt;String, MutableMap&lt;String, Any&gt;&gt;?, markets: Map&lt;String, Any&gt;?, period: CalculationPeriod, ): Double?</ID>
    <ID>NestedBlockDepth:SubaccountCalculator.kt$SubaccountCalculator$private fun calculatePositionRisk( position: Map&lt;String, Any&gt;, market: Map&lt;String, Any&gt;?, period: CalculationPeriod, ): Double</ID>
    <ID>NestedBlockDepth:SubaccountCalculator.kt$SubaccountCalculator$private fun calculatePositionValues( position: Map&lt;String, Any&gt;, market: Map&lt;String, Any&gt;?, subaccount: Map&lt;String, Any&gt;, price: Double?, periods: Set&lt;CalculationPeriod&gt;, ): MutableMap&lt;String, Any&gt;</ID>
    <ID>NestedBlockDepth:SubaccountCalculator.kt$SubaccountCalculator$private fun calculatePositionsValues( positions: Map&lt;String, Any&gt;?, markets: Map&lt;String, Any&gt;?, subaccount: Map&lt;String, Any&gt;, price: Map&lt;String, Any&gt;?, periods: Set&lt;CalculationPeriod&gt;, ): MutableMap&lt;String, MutableMap&lt;String, Any&gt;&gt;?</ID>
    <ID>NestedBlockDepth:SubaccountCalculator.kt$SubaccountCalculator$private fun calculateSubaccountEquity( subaccount: MutableMap&lt;String, Any&gt;, positions: Map&lt;String, Map&lt;String, Any&gt;&gt;?, periods: Set&lt;CalculationPeriod&gt;, )</ID>
    <ID>NestedBlockDepth:SubaccountSupervisor.kt$SubaccountSupervisor$private fun parseTransfersToMatchFaucetRecords()</ID>
    <ID>NestedBlockDepth:SubaccountTransformer.kt$SubaccountTransformer$private fun deltaFromTrade( parser: ParserProtocol, trade: Map&lt;String, Any&gt;, market: Map&lt;String, Any&gt;?, usePessimisticCollateralCheck: Boolean, useOptimisticCollateralCheck: Boolean, ): Map&lt;String, Any&gt;?</ID>
    <ID>NestedBlockDepth:SubaccountTransformer.kt$SubaccountTransformer$private fun executionPrice( oraclePrice: Double?, limitPrice: Double?, isBuying: Boolean, usePessimisticPrice: Boolean, useOptimisticPrice: Boolean, ): Double?</ID>
    <ID>NestedBlockDepth:TradeAccountStateValidator.kt$TradeAccountStateValidator$private fun validateSubaccountPostOrders( parser: ParserProtocol, subaccount: Map&lt;String, Any&gt;, trade: Map&lt;String, Any&gt;, change: PositionChange, ): Map&lt;String, Any&gt;?</ID>
    <ID>NestedBlockDepth:TradeInput.kt$SelectionOption.Companion$internal fun create( existing: SelectionOption?, parser: ParserProtocol, data: Map&lt;*, *&gt;?, ): SelectionOption?</ID>
    <ID>NestedBlockDepth:TradeInput.kt$TradeInputMarketOrder.Companion$internal fun create( existing: TradeInputMarketOrder?, parser: ParserProtocol, data: Map&lt;*, *&gt;?, ): TradeInputMarketOrder?</ID>
    <ID>NestedBlockDepth:TradeInput.kt$TradeInputOptions.Companion$internal fun create( existing: TradeInputOptions?, parser: ParserProtocol, data: Map&lt;*, *&gt;?, ): TradeInputOptions?</ID>
    <ID>NestedBlockDepth:TradeInputCalculator.kt$TradeInputCalculator$private fun calculateMarketOrderFromLeverage( equity: Double, oraclePrice: Double, positionSize: Double?, isBuying: Boolean, feeRate: Double, leverage: Double, stepSize: Double, orderbook: List&lt;Map&lt;String, Any&gt;&gt;, ): Map&lt;String, Any&gt;?</ID>
    <ID>NestedBlockDepth:TradeInputCalculator.kt$TradeInputCalculator$private fun calculateMarketOrderFromSize( size: Double?, orderbook: List&lt;Map&lt;String, Any&gt;&gt;?, ): Map&lt;String, Any&gt;?</ID>
    <ID>NestedBlockDepth:TradeInputCalculator.kt$TradeInputCalculator$private fun calculateMarketOrderFromUsdcSize( usdcSize: Double?, orderbook: List&lt;Map&lt;String, Any&gt;&gt;?, stepSize: Double, ): Map&lt;String, Any&gt;?</ID>
    <ID>NestedBlockDepth:TradeInputCalculator.kt$TradeInputCalculator$private fun calculatePositionMargin( trade: Map&lt;String, Any&gt;, subaccount: Map&lt;String, Any&gt;?, market: Map&lt;String, Any&gt;? ): Double?</ID>
    <ID>NestedBlockDepth:TradeInputCalculator.kt$TradeInputCalculator$private fun calculatedOptionsFromFields( fields: List&lt;Any&gt;?, trade: Map&lt;String, Any&gt;, position: Map&lt;String, Any&gt;?, market: Map&lt;String, Any&gt;?, ): Map&lt;String, Any&gt;?</ID>
    <ID>NestedBlockDepth:TradeInputCalculator.kt$TradeInputCalculator$private fun found(data: String?, options: List&lt;Any&gt;): Boolean</ID>
    <ID>NestedBlockDepth:TradeInputCalculator.kt$TradeInputCalculator$private fun marketOrderBestPrice(marketOrder: Map&lt;String, Any&gt;): Double?</ID>
    <ID>NestedBlockDepth:TradeInputCalculator.kt$TradeInputCalculator$private fun nonMarketOrderPrice( prices: Map&lt;String, Any&gt;?, market: Map&lt;String, Any&gt;?, type: String, isBuying: Boolean, ): Double?</ID>
    <ID>NestedBlockDepth:TradeInputCalculator.kt$TradeInputCalculator$private fun summaryForType( trade: Map&lt;String, Any&gt;, subaccount: Map&lt;String, Any&gt;?, user: Map&lt;String, Any&gt;?, market: Map&lt;String, Any&gt;?, rewardsParams: Map&lt;String, Any&gt;?, feeTiers: List&lt;Any&gt;?, type: String, ): Map&lt;String, Any&gt;</ID>
    <ID>NestedBlockDepth:TradeInputDataValidator.kt$TradeInputDataValidator$private fun equityTier( isStatefulOrder: Boolean, subaccount: Map&lt;String, Any&gt;?, configs: Map&lt;String, Any&gt;? ): EquityTier?</ID>
    <ID>NestedBlockDepth:TradeInputDataValidator.kt$TradeInputDataValidator$private fun orderCount( shouldCountStatefulOrders: Boolean, subaccount: Map&lt;String, Any&gt;?, ): Int</ID>
    <ID>NestedBlockDepth:TradeInputDataValidator.kt$TradeInputDataValidator$private fun validateLimitPrice( trade: Map&lt;String, Any&gt;, market: Map&lt;String, Any&gt;?, ): List&lt;Any&gt;?</ID>
    <ID>NestedBlockDepth:TradeInputDataValidator.kt$TradeInputDataValidator$private fun validateSize( trade: Map&lt;String, Any&gt;, market: Map&lt;String, Any&gt;?, ): List&lt;Any&gt;?</ID>
    <ID>NestedBlockDepth:TradeInputValidator.kt$TradeInputValidator$private fun change( parser: ParserProtocol, subaccount: Map&lt;String, Any&gt;?, trade: Map&lt;String, Any&gt;, ): PositionChange</ID>
    <ID>NestedBlockDepth:TradeTriggerPriceValidator.kt$TradeTriggerPriceValidator$override fun validateTrade( subaccount: Map&lt;String, Any&gt;?, market: Map&lt;String, Any&gt;?, configs: Map&lt;String, Any&gt;?, trade: Map&lt;String, Any&gt;, change: PositionChange, restricted: Boolean, environment: V4Environment?, ): List&lt;Any&gt;?</ID>
    <ID>NestedBlockDepth:TradingStateMachine+ClosePositionInput.kt$fun TradingStateMachine.closePosition( data: String?, type: ClosePositionInputField, subaccountNumber: Int ): StateResponse</ID>
    <ID>NestedBlockDepth:TradingStateMachine+TradeInput.kt$fun TradingStateMachine.trade( data: String?, type: TradeInputField?, subaccountNumber: Int, ): StateResponse</ID>
    <ID>NestedBlockDepth:TradingStateMachine+TransferInput.kt$fun TradingStateMachine.transfer( data: String?, type: TransferInputField?, subaccountNumber: Int = 0 ): StateResponse</ID>
    <ID>NestedBlockDepth:TradingStateMachine.kt$TradingStateMachine$private fun maxSubaccountNumber(): Int?</ID>
    <ID>NestedBlockDepth:TradingStateMachine.kt$TradingStateMachine$private fun recalculateStates(changes: StateChanges)</ID>
    <ID>NestedBlockDepth:TradingStateMachine.kt$TradingStateMachine$private fun update( state: PerpetualState?, changes: StateChanges, tokensInfo: Map&lt;String, TokenInfo&gt;, localizer: LocalizerProtocol?, ): PerpetualState</ID>
    <ID>NestedBlockDepth:TransferInput.kt$DepositInputOptions.Companion$internal fun create( existing: DepositInputOptions?, parser: ParserProtocol, data: Map&lt;*, *&gt;? ): DepositInputOptions?</ID>
    <ID>NestedBlockDepth:TransferInput.kt$WithdrawalInputOptions.Companion$internal fun create( existing: WithdrawalInputOptions?, parser: ParserProtocol, data: Map&lt;*, *&gt;? ): WithdrawalInputOptions?</ID>
    <ID>NestedBlockDepth:TransferInputCalculator.kt$TransferInputCalculator$private fun calculatedOptionsFromFields(fields: List&lt;Any&gt;?): Map&lt;String, Any&gt;?</ID>
    <ID>NestedBlockDepth:TriggerOrdersInputValidator.kt$TriggerOrdersInputValidator$private fun equityTier( subaccount: Map&lt;String, Any&gt;?, configs: Map&lt;String, Any&gt;? ): EquityTier?</ID>
    <ID>NestedBlockDepth:TriggerOrdersInputValidator.kt$TriggerOrdersInputValidator$private fun orderCount( subaccount: Map&lt;String, Any&gt;?, ): Int</ID>
    <ID>NestedBlockDepth:TriggerOrdersInputValidator.kt$TriggerOrdersInputValidator$private fun validateLimitPrice( triggerOrder: Map&lt;String, Any&gt;, ): List&lt;Any&gt;?</ID>
    <ID>NestedBlockDepth:TriggerOrdersInputValidator.kt$TriggerOrdersInputValidator$private fun validateSize( orderSize: Double?, market: Map&lt;String, Any&gt;?, ): List&lt;Any&gt;?</ID>
    <ID>NestedBlockDepth:V4StateManagerAdaptor.kt$V4StateManagerAdaptor$override fun calculateCurrentHeight(): Int?</ID>
    <ID>NestedBlockDepth:V4StateManagerAdaptor.kt$V4StateManagerAdaptor$override fun didUpdateStateForTransfer(data: String?, type: TransferInputField?)</ID>
    <ID>NestedBlockDepth:V4StateManagerAdaptor.kt$V4StateManagerAdaptor$private fun apiState( apiState: ApiState?, indexerState: NetworkState, validatorState: NetworkState, ): ApiState</ID>
    <ID>NestedBlockDepth:ValidationError.kt$ErrorString.Companion$internal fun create( existing: ErrorString?, parser: ParserProtocol, data: Map&lt;*, *&gt;? ): ErrorString?</ID>
    <ID>NestedBlockDepth:ValidationError.kt$ValidationError.Companion$internal fun create( existing: IList&lt;ValidationError&gt;?, parser: ParserProtocol, data: List&lt;Any&gt;? ): IList&lt;ValidationError&gt;?</ID>
    <ID>NestedBlockDepth:ValidationError.kt$ValidationError.Companion$internal fun create( existing: ValidationError?, parser: ParserProtocol, data: Map&lt;*, *&gt;? ): ValidationError?</ID>
    <ID>NestedBlockDepth:Wallet.kt$LaunchIncentivePoints.Companion$internal fun create( existing: LaunchIncentivePoints?, parser: ParserProtocol, data: Map&lt;String, Any&gt;? ): LaunchIncentivePoints?</ID>
    <ID>ReturnCount:Account.kt$SubaccountPendingPosition.Companion$internal fun create( existing: SubaccountPendingPosition?, parser: ParserProtocol, data: Map&lt;String, Any&gt;?, ): SubaccountPendingPosition?</ID>
    <ID>ReturnCount:Account.kt$SubaccountTransfer.Companion$internal fun create( existing: SubaccountTransfer?, parser: ParserProtocol, data: Map&lt;*, *&gt;?, ): SubaccountTransfer?</ID>
    <ID>ReturnCount:AsyncAbacusStateManager.kt$AsyncAbacusStateManager$private fun parseEnvironments(response: String): Boolean</ID>
    <ID>ReturnCount:AsyncAbacusStateManagerV2.kt$AsyncAbacusStateManagerV2$private fun parseEnvironments(response: String): Boolean</ID>
    <ID>ReturnCount:BaseProcessor.kt$BaseProcessor$private fun value(input: Map&lt;*, *&gt;, key: String, type: String): Any?</ID>
    <ID>ReturnCount:Configs.kt$WithdrawalCapacity.Companion$internal fun create( existing: WithdrawalCapacity?, parser: ParserProtocol, data: Map&lt;*, *&gt;? ): WithdrawalCapacity?</ID>
    <ID>ReturnCount:ConnectionsSupervisor.kt$ConnectionsSupervisor$private fun connectChain(validatorUrl: String, callback: (successful: Boolean) -&gt; Unit)</ID>
    <ID>ReturnCount:DynamicLocalizer.kt$DynamicLocalizer$override fun localize( path: String, paramsAsJson: String?, ): String</ID>
    <ID>ReturnCount:Enviroment.kt$AppRequirements.Companion$fun parse( data: Map&lt;String, Any&gt;?, parser: ParserProtocol, localizer: LocalizerProtocol? ): AppRequirements?</ID>
    <ID>ReturnCount:Enviroment.kt$EnvironmentEndpoints.Companion$fun parse( data: Map&lt;String, Any&gt;, parser: ParserProtocol, ): EnvironmentEndpoints?</ID>
    <ID>ReturnCount:Enviroment.kt$EnvironmentGovernance.Companion$fun parse( data: Map&lt;String, Any&gt;?, parser: ParserProtocol, ): EnvironmentGovernance?</ID>
    <ID>ReturnCount:Enviroment.kt$EnvironmentGovernanceNewMarketProposal.Companion$fun parse( data: Map&lt;String, Any&gt;?, parser: ParserProtocol, ): EnvironmentGovernanceNewMarketProposal?</ID>
    <ID>ReturnCount:Enviroment.kt$IndexerURIs.Companion$fun parse( data: Map&lt;String, Any&gt;, parser: ParserProtocol, ): IndexerURIs?</ID>
    <ID>ReturnCount:Enviroment.kt$TokenInfo.Companion$fun parse( data: Map&lt;String, Any&gt;, parser: ParserProtocol, defaultDecimals: Int, ): TokenInfo?</ID>
    <ID>ReturnCount:Enviroment.kt$V4Environment.Companion$fun parse( id: String, data: Map&lt;String, Any&gt;, parser: ParserProtocol, deploymentUri: String, localizer: LocalizerProtocol?, tokensData: Map&lt;String, Any&gt;?, linksData: Map&lt;String, Any&gt;?, walletsData: Map&lt;String, Any&gt;?, governanceData: Map&lt;String, Any&gt;?, ): V4Environment?</ID>
    <ID>ReturnCount:Enviroment.kt$WalletConnectClient.Companion$fun parse( data: Map&lt;String, Any&gt;?, parser: ParserProtocol, deploymentUri: String, ): WalletConnectClient?</ID>
    <ID>ReturnCount:Formatter.kt$Formatter$private fun defaultPrice(value: Double?, tickSize: String?): String?</ID>
    <ID>ReturnCount:GoodTil.kt$GoodTil.Companion$internal fun duration(goodTil: Map&lt;String, Any&gt;?, parser: ParserProtocol): Duration?</ID>
    <ID>ReturnCount:GoodTil.kt$GoodTil.Companion$internal fun duration(goodTil: TradeInputGoodUntil?): Duration?</ID>
    <ID>ReturnCount:InputValidator.kt$InputValidator$fun validate( wallet: Map&lt;String, Any&gt;?, user: Map&lt;String, Any&gt;?, subaccount: Map&lt;String, Any&gt;?, markets: Map&lt;String, Any&gt;?, input: Map&lt;String, Any&gt;?, configs: Map&lt;String, Any&gt;?, currentBlockAndHeight: BlockAndTime?, environment: V4Environment?, ): Map&lt;String, Any&gt;?</ID>
    <ID>ReturnCount:JsonEncoder.kt$JsonEncoder$internal fun encode(element: Any?): String</ID>
    <ID>ReturnCount:JsonEncoder.kt$JsonEncoder$private fun string(element: Any): String?</ID>
    <ID>ReturnCount:LaunchIncentive.kt$LaunchIncentive.Companion$internal fun create( existing: LaunchIncentive?, parser: ParserProtocol, data: Map&lt;String, Any&gt;?, ): LaunchIncentive?</ID>
    <ID>ReturnCount:LaunchIncentive.kt$LaunchIncentiveSeason.Companion$internal fun create( existing: LaunchIncentiveSeason?, parser: ParserProtocol, data: Map&lt;String, Any&gt;?, ): LaunchIncentiveSeason?</ID>
    <ID>ReturnCount:LaunchIncentiveProcessor.kt$LaunchIncentiveProcessor$internal fun receivedSeasons( existing: Map&lt;String, Any&gt;?, payload: Map&lt;String, Any&gt; ): Map&lt;String, Any&gt;?</ID>
    <ID>ReturnCount:Market.kt$MarketConfigs.Companion$internal fun create( existing: MarketConfigs?, parser: ParserProtocol, data: Map&lt;String, Any&gt;, ): MarketConfigs?</ID>
    <ID>ReturnCount:Market.kt$MarketConfigsV4.Companion$internal fun create( existing: MarketConfigsV4?, parser: ParserProtocol, data: Map&lt;String, Any&gt;?, ): MarketConfigsV4?</ID>
    <ID>ReturnCount:Market.kt$MarketOrderbook.Companion$internal fun create( existing: MarketOrderbook?, parser: ParserProtocol, data: Map&lt;*, *&gt;?, ): MarketOrderbook?</ID>
    <ID>ReturnCount:Market.kt$PerpetualMarket.Companion$internal fun create( existing: PerpetualMarket?, parser: ParserProtocol, data: Map&lt;String, Any&gt;, assets: Map&lt;String, Any&gt;?, resetOrderbook: Boolean, resetTrades: Boolean, ): PerpetualMarket?</ID>
    <ID>ReturnCount:MarketCalculator.kt$MarketCalculator$private fun calculateMarketCaps( market: Map&lt;String, Any&gt;, assets: Map&lt;String, Any&gt; ): Map&lt;String, Any&gt;</ID>
    <ID>ReturnCount:MarketProcessor.kt$MarketProcessor$internal fun receivedCandles( market: Map&lt;String, Any&gt;, payload: List&lt;Any&gt;, ): Map&lt;String, Any&gt;</ID>
    <ID>ReturnCount:MarketSupervisor.kt$MarketSupervisor$private fun retrieveCandles()</ID>
    <ID>ReturnCount:MarketsProcessor.kt$MarketsProcessor$internal fun receivedCandles( existing: Map&lt;String, Any&gt;?, payload: Map&lt;String, Any&gt; ): Map&lt;String, Any&gt;?</ID>
    <ID>ReturnCount:NetworkHelper.kt$NetworkHelper$internal fun parseTransactionResponse(response: String?): ParsingError?</ID>
    <ID>ReturnCount:NotificationsProvider.kt$NotificationsProvider$private fun createFillNotification( stateMachine: TradingStateMachine, fillsForOrder: IList&lt;SubaccountFill&gt;, order: SubaccountOrder, ): Notification?</ID>
    <ID>ReturnCount:NotificationsProvider.kt$NotificationsProvider$private fun createNotificationForFill( stateMachine: TradingStateMachine, fill: SubaccountFill, ): Notification?</ID>
    <ID>ReturnCount:NotificationsProvider.kt$NotificationsProvider$private fun createOrderStatusNotification( stateMachine: TradingStateMachine, order: SubaccountOrder, ): Notification?</ID>
    <ID>ReturnCount:OrderProcessor.kt$OrderProcessor$private fun shouldUpdate(existing: Map&lt;String, Any&gt;?, payload: Map&lt;String, Any&gt;): Boolean</ID>
    <ID>ReturnCount:Parser.kt$Parser$override fun asBool(data: Any?): Boolean?</ID>
    <ID>ReturnCount:Parser.kt$Parser$override fun asDecimal(data: Any?): BigDecimal?</ID>
    <ID>ReturnCount:Parser.kt$Parser$override fun asDouble(data: Any?): Double?</ID>
    <ID>ReturnCount:Parser.kt$Parser$override fun asInt(data: Any?): Int?</ID>
    <ID>ReturnCount:Parser.kt$Parser$override fun asList(data: Any?): IList&lt;Any&gt;?</ID>
    <ID>ReturnCount:Parser.kt$Parser$override fun asLong(data: Any?): Long?</ID>
    <ID>ReturnCount:Parser.kt$Parser$override fun asMap(data: Any?): IMap&lt;String, Any&gt;?</ID>
    <ID>ReturnCount:Parser.kt$Parser$override fun asNativeList(data: Any?): List&lt;Any&gt;?</ID>
    <ID>ReturnCount:Parser.kt$Parser$override fun asNativeMap(data: Any?): Map&lt;String, Any&gt;?</ID>
    <ID>ReturnCount:Parser.kt$Parser$override fun asString(data: Any?): String?</ID>
    <ID>ReturnCount:Parser.kt$Parser$override fun asStrings(data: Any?): IList&lt;String&gt;?</ID>
    <ID>ReturnCount:Parser.kt$Parser$private fun value(data: Any?, path: IMutableList&lt;String&gt;): Any?</ID>
    <ID>ReturnCount:PerpetualPositionProcessor.kt$PerpetualPositionProcessor$private fun side(size: Double?): String</ID>
    <ID>ReturnCount:StateManagerAdaptor.kt$StateManagerAdaptor$@Throws(Exception::class) private fun socket( payload: IMap&lt;String, Any&gt;, )</ID>
    <ID>ReturnCount:StateManagerAdaptor.kt$StateManagerAdaptor$private fun maybeRetrieveMarketCandles()</ID>
    <ID>ReturnCount:StateManagerConfigs.kt$StateManagerConfigs$fun privateApiUrl(type: String): String?</ID>
    <ID>ReturnCount:StateManagerConfigs.kt$StateManagerConfigs$fun publicApiUrl(type: String): String?</ID>
    <ID>ReturnCount:StateManagerConfigs.kt$StateManagerConfigs$fun websocketUrl(): String?</ID>
    <ID>ReturnCount:String+Utils.kt$fun String.toDydxAddress(): String?</ID>
    <ID>ReturnCount:String+Utils.kt$fun String.toNobleAddress(): String?</ID>
    <ID>ReturnCount:StringHelper.kt$StringHelper.Companion$private fun formatNumericString(string: String, decimals: Int? = null): String</ID>
    <ID>ReturnCount:SubaccountSupervisor.kt$SubaccountSupervisor$internal fun getChildSubaccountNumberForIsolatedMarginTrade(marketId: String): Int</ID>
    <ID>ReturnCount:SubaccountSupervisor.kt$SubaccountSupervisor$private fun marketInfo(marketId: String): PlaceOrderMarketInfo?</ID>
    <ID>ReturnCount:SubaccountTransformer.kt$SubaccountTransformer$private fun deltaFromTrade( parser: ParserProtocol, trade: Map&lt;String, Any&gt;, market: Map&lt;String, Any&gt;?, usePessimisticCollateralCheck: Boolean, useOptimisticCollateralCheck: Boolean, ): Map&lt;String, Any&gt;?</ID>
    <ID>ReturnCount:SubaccountTransformer.kt$SubaccountTransformer$private fun executionPrice( oraclePrice: Double?, limitPrice: Double?, isBuying: Boolean, usePessimisticPrice: Boolean, useOptimisticPrice: Boolean, ): Double?</ID>
    <ID>ReturnCount:TradeAccountStateValidator.kt$TradeAccountStateValidator$private fun fillsExistingOrder( parser: ParserProtocol, trade: Map&lt;String, Any&gt;, orders: Map&lt;String, Any&gt;?, ): Boolean</ID>
    <ID>ReturnCount:TradeAccountStateValidator.kt$TradeAccountStateValidator$private fun positionOverleveragedPostAllOrders( parser: ParserProtocol, position: Map&lt;String, Any&gt;?, ): Boolean</ID>
    <ID>ReturnCount:TradeBracketOrdersValidator.kt$TradeBracketOrdersValidator$override fun validateTrade( subaccount: Map&lt;String, Any&gt;?, market: Map&lt;String, Any&gt;?, configs: Map&lt;String, Any&gt;?, trade: Map&lt;String, Any&gt;, change: PositionChange, restricted: Boolean, environment: V4Environment?, ): List&lt;Any&gt;?</ID>
    <ID>ReturnCount:TradeInputCalculator.kt$TradeInputCalculator$private fun calculateMarketOrder( trade: Map&lt;String, Any&gt;, market: Map&lt;String, Any&gt;?, subaccount: Map&lt;String, Any&gt;?, user: Map&lt;String, Any&gt;, isBuying: Boolean, input: String, ): Map&lt;String, Any&gt;?</ID>
    <ID>ReturnCount:TradeInputCalculator.kt$TradeInputCalculator$private fun calculateMarketOrderFromLeverage( leverage: Double, market: Map&lt;String, Any&gt;?, subaccount: Map&lt;String, Any&gt;?, user: Map&lt;String, Any&gt;, ): Map&lt;String, Any&gt;?</ID>
    <ID>ReturnCount:TradeInputCalculator.kt$TradeInputCalculator$private fun calculatePositionMargin( trade: Map&lt;String, Any&gt;, subaccount: Map&lt;String, Any&gt;?, market: Map&lt;String, Any&gt;? ): Double?</ID>
    <ID>ReturnCount:TradeInputCalculator.kt$TradeInputCalculator$private fun calculateSize( trade: Map&lt;String, Any&gt;, subaccount: Map&lt;String, Any&gt;?, market: Map&lt;String, Any&gt;?, ): MutableMap&lt;String, Any&gt;</ID>
    <ID>ReturnCount:TradeInputCalculator.kt$TradeInputCalculator$private fun maxLeverage( subaccount: Map&lt;String, Any&gt;?, market: Map&lt;String, Any&gt;? ): Double?</ID>
    <ID>ReturnCount:TradeInputCalculator.kt$TradeInputCalculator$private fun maxLeverageFromPosition( position: Map&lt;String, Any&gt;?, market: Map&lt;String, Any&gt;?, ): Double?</ID>
    <ID>ReturnCount:TradeInputCalculator.kt$TradeInputCalculator$private fun nonMarketOrderPrice( prices: Map&lt;String, Any&gt;?, market: Map&lt;String, Any&gt;?, type: String, isBuying: Boolean, ): Double?</ID>
    <ID>ReturnCount:TradeInputCalculator.kt$TradeInputCalculator$private fun side(marketOrder: Map&lt;String, Any&gt;, orderbook: Map&lt;String, Any&gt;): String?</ID>
    <ID>ReturnCount:TradeInputDataValidator.kt$TradeInputDataValidator$private fun equityTier( isStatefulOrder: Boolean, subaccount: Map&lt;String, Any&gt;?, configs: Map&lt;String, Any&gt;? ): EquityTier?</ID>
    <ID>ReturnCount:TradeInputDataValidator.kt$TradeInputDataValidator$private fun validateLimitPrice( trade: Map&lt;String, Any&gt;, market: Map&lt;String, Any&gt;?, ): List&lt;Any&gt;?</ID>
    <ID>ReturnCount:TradeInputDataValidator.kt$TradeInputDataValidator$private fun validateSize( trade: Map&lt;String, Any&gt;, market: Map&lt;String, Any&gt;?, ): List&lt;Any&gt;?</ID>
    <ID>ReturnCount:TradeInputValidator.kt$TradeInputValidator$override fun validate( wallet: Map&lt;String, Any&gt;?, user: Map&lt;String, Any&gt;?, subaccount: Map&lt;String, Any&gt;?, markets: Map&lt;String, Any&gt;?, configs: Map&lt;String, Any&gt;?, currentBlockAndHeight: BlockAndTime?, transaction: Map&lt;String, Any&gt;, transactionType: String, environment: V4Environment?, ): List&lt;Any&gt;?</ID>
    <ID>ReturnCount:TradeInputValidator.kt$TradeInputValidator$private fun change( parser: ParserProtocol, subaccount: Map&lt;String, Any&gt;?, trade: Map&lt;String, Any&gt;, ): PositionChange</ID>
    <ID>ReturnCount:TradeMarketOrderInputValidator.kt$TradeMarketOrderInputValidator$private fun orderbookSlippage( trade: Map&lt;String, Any&gt;, restricted: Boolean ): Map&lt;String, Any&gt;?</ID>
    <ID>ReturnCount:TradePositionStateValidator.kt$TradePositionStateValidator$private fun validatePositionSize( position: Map&lt;String, Any&gt;?, market: Map&lt;String, Any&gt;?, ): Map&lt;String, Any&gt;?</ID>
    <ID>ReturnCount:TradeTriggerPriceValidator.kt$TradeTriggerPriceValidator$override fun validateTrade( subaccount: Map&lt;String, Any&gt;?, market: Map&lt;String, Any&gt;?, configs: Map&lt;String, Any&gt;?, trade: Map&lt;String, Any&gt;, change: PositionChange, restricted: Boolean, environment: V4Environment?, ): List&lt;Any&gt;?</ID>
    <ID>ReturnCount:TradingStateMachine+Account.kt$internal fun TradingStateMachine.findOrder( clientId: Int, subaccountNumber: Int, ): SubaccountOrder?</ID>
    <ID>ReturnCount:TradingStateMachine+Account.kt$internal fun TradingStateMachine.findOrder( orderId: String, subaccountNumber: Int, ): SubaccountOrder?</ID>
    <ID>ReturnCount:TradingStateMachine+Account.kt$internal fun TradingStateMachine.findOrderInData( orderId: String, subaccountNumber: Int, ): SubaccountOrder?</ID>
    <ID>ReturnCount:TradingStateMachine+TradeInput.kt$internal fun TradingStateMachine.tradeInMarket( marketId: String, subaccountNumber: Int, ): StateResponse</ID>
    <ID>ReturnCount:TradingStateMachine.kt$TradingStateMachine$fun setHistoricalPnlDays(days: Int, subaccountNumber: Int): StateResponse</ID>
    <ID>ReturnCount:TradingStateMachine.kt$TradingStateMachine$private fun calculateReceipt(input: Map&lt;String, Any&gt;): List&lt;String&gt;?</ID>
    <ID>ReturnCount:TriggerOrdersInputCalculator.kt$TriggerOrdersInputCalculator$private fun calculateTriggerPrices( triggerPrices: Map&lt;String, Any&gt;, position: Map&lt;String, Any&gt;, size: Double?, ): MutableMap&lt;String, Any&gt;</ID>
    <ID>ReturnCount:TriggerOrdersInputValidator.kt$TriggerOrdersInputValidator$override fun validate( wallet: Map&lt;String, Any&gt;?, user: Map&lt;String, Any&gt;?, subaccount: Map&lt;String, Any&gt;?, markets: Map&lt;String, Any&gt;?, configs: Map&lt;String, Any&gt;?, currentBlockAndHeight: BlockAndTime?, transaction: Map&lt;String, Any&gt;, transactionType: String, environment: V4Environment? ): List&lt;Any&gt;?</ID>
    <ID>ReturnCount:TriggerOrdersInputValidator.kt$TriggerOrdersInputValidator$private fun equityTier( subaccount: Map&lt;String, Any&gt;?, configs: Map&lt;String, Any&gt;? ): EquityTier?</ID>
    <ID>ReturnCount:TriggerOrdersInputValidator.kt$TriggerOrdersInputValidator$private fun validateLimitPrice( triggerOrder: Map&lt;String, Any&gt;, ): List&lt;Any&gt;?</ID>
    <ID>ReturnCount:TriggerOrdersInputValidator.kt$TriggerOrdersInputValidator$private fun validateSize( orderSize: Double?, market: Map&lt;String, Any&gt;?, ): List&lt;Any&gt;?</ID>
    <ID>ReturnCount:TriggerOrdersInputValidator.kt$TriggerOrdersInputValidator$private fun validateTriggerPrice( triggerOrder: Map&lt;String, Any&gt;, oraclePrice: Double, tickSize: String, ): List&lt;Any&gt;?</ID>
    <ID>ReturnCount:V4StateManagerAdaptor.kt$V4StateManagerAdaptor$override fun marketInfo(market: String): PlaceOrderMarketInfo?</ID>
    <ID>ReturnCount:V4StateManagerAdaptor.kt$V4StateManagerAdaptor$override fun parseTransactionResponse(response: String?): ParsingError?</ID>
    <ID>ReturnCount:V4StateManagerAdaptor.kt$V4StateManagerAdaptor$private fun connectChain(validatorUrl: String, callback: (successful: Boolean) -&gt; Unit)</ID>
    <ID>ReturnCount:V4StateManagerConfigs.kt$V4StateManagerConfigs$fun launchIncentiveUrl(type: String): String?</ID>
    <ID>ReturnCount:Wallet.kt$LaunchIncentivePoints.Companion$internal fun create( existing: LaunchIncentivePoints?, parser: ParserProtocol, data: Map&lt;String, Any&gt;? ): LaunchIncentivePoints?</ID>
    <ID>SwallowedException:Parser.kt$Parser$e: Exception</ID>
    <ID>SwallowedException:String+Utils.kt$e: Exception</ID>
    <ID>SwallowedException:TradingStateMachine+Wallet.kt$e: Exception</ID>
    <ID>ThrowingExceptionsWithoutMessageOrCause:OrderbookProcessor.kt$OrderbookProcessor$Exception()</ID>
    <ID>ThrowsCount:AccountsSupervisor.kt$AccountsSupervisor$private fun splitAddressAndSubaccountNumber(id: String?): Pair&lt;String, Int&gt;</ID>
    <ID>ThrowsCount:Bech32.kt$Bech32$fun decode(str: String): Bech32Data</ID>
    <ID>ThrowsCount:MarketSupervisor.kt$MarketSupervisor$internal fun receiveMarketCandlesChannelSocketData( info: SocketInfo, resolution: String, payload: IMap&lt;String, Any&gt; )</ID>
    <ID>ThrowsCount:MarketSupervisor.kt$MarketSupervisor$internal fun receiveMarketOrderbooksChannelSocketData( info: SocketInfo, payload: IMap&lt;String, Any&gt;, subaccountNumber: Int?, )</ID>
    <ID>ThrowsCount:MarketSupervisor.kt$MarketSupervisor$internal fun receiveMarketTradesChannelSocketData( info: SocketInfo, payload: IMap&lt;String, Any&gt;, )</ID>
    <ID>ThrowsCount:MarketsSupervisor.kt$MarketsSupervisor$internal fun receiveMarketsChannelSocketData( info: SocketInfo, payload: IMap&lt;String, Any&gt;, subaccountNumber: Int?, )</ID>
    <ID>ThrowsCount:OnboardingSupervisor.kt$OnboardingSupervisor$@Throws(Exception::class) fun subaccountTransferPayload(subaccountNumber: Int?): HumanReadableSubaccountTransferPayload</ID>
    <ID>ThrowsCount:OnboardingSupervisor.kt$OnboardingSupervisor$@Throws(Exception::class) fun transferNativeTokenPayload(subaccountNumber: Int?): HumanReadableTransferPayload</ID>
    <ID>ThrowsCount:StateManagerAdaptor.kt$StateManagerAdaptor$@Throws(Exception::class) fun cancelOrderPayload(orderId: String): HumanReadableCancelOrderPayload</ID>
    <ID>ThrowsCount:StateManagerAdaptor.kt$StateManagerAdaptor$@Throws(Exception::class) fun closePositionPayload(): HumanReadablePlaceOrderPayload</ID>
    <ID>ThrowsCount:StateManagerAdaptor.kt$StateManagerAdaptor$@Throws(Exception::class) fun depositPayload(): HumanReadableDepositPayload</ID>
    <ID>ThrowsCount:StateManagerAdaptor.kt$StateManagerAdaptor$@Throws(Exception::class) fun placeOrderPayload(): HumanReadablePlaceOrderPayload</ID>
    <ID>ThrowsCount:StateManagerAdaptor.kt$StateManagerAdaptor$@Throws(Exception::class) fun subaccountTransferPayload(): HumanReadableSubaccountTransferPayload</ID>
    <ID>ThrowsCount:StateManagerAdaptor.kt$StateManagerAdaptor$@Throws(Exception::class) fun transferNativeTokenPayload(): HumanReadableTransferPayload</ID>
    <ID>ThrowsCount:StateManagerAdaptor.kt$StateManagerAdaptor$@Throws(Exception::class) fun triggerOrdersPayload(): HumanReadableTriggerOrdersPayload</ID>
    <ID>ThrowsCount:StateManagerAdaptor.kt$StateManagerAdaptor$@Throws(Exception::class) fun withdrawPayload(): HumanReadableWithdrawPayload</ID>
    <ID>ThrowsCount:StateManagerAdaptor.kt$StateManagerAdaptor$@Throws(Exception::class) private fun socket( payload: IMap&lt;String, Any&gt;, )</ID>
    <ID>ThrowsCount:StateManagerAdaptor.kt$StateManagerAdaptor$private fun triggerOrderPayload(triggerOrder: TriggerOrder, subaccountNumber: Int, marketId: String): HumanReadablePlaceOrderPayload</ID>
    <ID>ThrowsCount:SubaccountSupervisor.kt$SubaccountSupervisor$@Throws(Exception::class) fun closePositionPayload(currentHeight: Int?): HumanReadablePlaceOrderPayload</ID>
    <ID>ThrowsCount:SubaccountSupervisor.kt$SubaccountSupervisor$@Throws(Exception::class) fun placeOrderPayload(currentHeight: Int?): HumanReadablePlaceOrderPayload</ID>
    <ID>ThrowsCount:SubaccountSupervisor.kt$SubaccountSupervisor$@Throws(Exception::class) fun subaccountTransferPayload(): HumanReadableSubaccountTransferPayload</ID>
    <ID>ThrowsCount:SubaccountSupervisor.kt$SubaccountSupervisor$internal fun receiveSubaccountChannelSocketData( info: SocketInfo, payload: IMap&lt;String, Any&gt;, height: BlockAndTime?, )</ID>
    <ID>ThrowsCount:SubaccountSupervisor.kt$SubaccountSupervisor$private fun triggerOrderPayload(triggerOrder: TriggerOrder, marketId: String, currentHeight: Int?): HumanReadablePlaceOrderPayload</ID>
    <ID>ThrowsCount:TradingStateMachine.kt$TradingStateMachine$@Throws(Exception::class) private fun socket( url: AbUrl, payload: Map&lt;String, Any&gt;, subaccountNumber: Int, height: BlockAndTime?, ): StateResponse</ID>
    <ID>TooGenericExceptionCaught:AsyncAbacusStateManager.kt$AsyncAbacusStateManager$e: Exception</ID>
    <ID>TooGenericExceptionCaught:AsyncAbacusStateManagerV2.kt$AsyncAbacusStateManagerV2$e: Exception</ID>
    <ID>TooGenericExceptionCaught:NetworkHelper.kt$NetworkHelper$e: Exception</ID>
    <ID>TooGenericExceptionCaught:Parser.kt$Parser$e: Exception</ID>
    <ID>TooGenericExceptionCaught:StateManagerAdaptor.kt$StateManagerAdaptor$e: Exception</ID>
    <ID>TooGenericExceptionCaught:String+Utils.kt$e: Exception</ID>
    <ID>TooGenericExceptionCaught:TradingStateMachine+Wallet.kt$e: Exception</ID>
    <ID>TooGenericExceptionCaught:TradingStateMachine.kt$TradingStateMachine$e: Exception</ID>
    <ID>TooGenericExceptionThrown:AccountSupervisor.kt$AccountSupervisor$throw Exception("Unexpected restriction value")</ID>
    <ID>TooGenericExceptionThrown:AsyncAbacusStateManager.kt$AsyncAbacusStateManager$throw Error("Either stateNotification or dataNotification need to be set")</ID>
    <ID>TooGenericExceptionThrown:AsyncAbacusStateManager.kt$AsyncAbacusStateManager$throw Error("IOImplementations.chain is not set")</ID>
    <ID>TooGenericExceptionThrown:AsyncAbacusStateManager.kt$AsyncAbacusStateManager$throw Error("IOImplementations.fileSystem is not set, used by Abacus localizer")</ID>
    <ID>TooGenericExceptionThrown:AsyncAbacusStateManager.kt$AsyncAbacusStateManager$throw Error("IOImplementations.rest is not set")</ID>
    <ID>TooGenericExceptionThrown:AsyncAbacusStateManager.kt$AsyncAbacusStateManager$throw Error("IOImplementations.threading is not set")</ID>
    <ID>TooGenericExceptionThrown:AsyncAbacusStateManager.kt$AsyncAbacusStateManager$throw Error("IOImplementations.timer is not set")</ID>
    <ID>TooGenericExceptionThrown:AsyncAbacusStateManager.kt$AsyncAbacusStateManager$throw Error("IOImplementations.webSocket is not set")</ID>
    <ID>TooGenericExceptionThrown:AsyncAbacusStateManager.kt$AsyncAbacusStateManager$throw Error("UIImplementations.localizer is not set")</ID>
    <ID>TooGenericExceptionThrown:AsyncAbacusStateManagerV2.kt$AsyncAbacusStateManagerV2$throw Error("Either stateNotification or dataNotification need to be set")</ID>
    <ID>TooGenericExceptionThrown:AsyncAbacusStateManagerV2.kt$AsyncAbacusStateManagerV2$throw Error("IOImplementations.chain is not set")</ID>
    <ID>TooGenericExceptionThrown:AsyncAbacusStateManagerV2.kt$AsyncAbacusStateManagerV2$throw Error("IOImplementations.fileSystem is not set, used by Abacus localizer")</ID>
    <ID>TooGenericExceptionThrown:AsyncAbacusStateManagerV2.kt$AsyncAbacusStateManagerV2$throw Error("IOImplementations.rest is not set")</ID>
    <ID>TooGenericExceptionThrown:AsyncAbacusStateManagerV2.kt$AsyncAbacusStateManagerV2$throw Error("IOImplementations.threading is not set")</ID>
    <ID>TooGenericExceptionThrown:AsyncAbacusStateManagerV2.kt$AsyncAbacusStateManagerV2$throw Error("IOImplementations.timer is not set")</ID>
    <ID>TooGenericExceptionThrown:AsyncAbacusStateManagerV2.kt$AsyncAbacusStateManagerV2$throw Error("IOImplementations.webSocket is not set")</ID>
    <ID>TooGenericExceptionThrown:AsyncAbacusStateManagerV2.kt$AsyncAbacusStateManagerV2$throw Error("UIImplementations.localizer is not set")</ID>
    <ID>TooGenericExceptionThrown:MarketSupervisor.kt$MarketSupervisor$throw Exception("candlesChannel is null")</ID>
    <ID>TooGenericExceptionThrown:MarketSupervisor.kt$MarketSupervisor$throw Exception("orderbook channel is null")</ID>
    <ID>TooGenericExceptionThrown:MarketSupervisor.kt$MarketSupervisor$throw Exception("trades channel is null")</ID>
    <ID>TooGenericExceptionThrown:MarketsSupervisor.kt$MarketsSupervisor$throw Exception("markets channel is null")</ID>
    <ID>TooGenericExceptionThrown:NetworkHelper.kt$NetworkHelper$throw Exception("chain is not DYDXChainTransactionsProtocol")</ID>
    <ID>TooGenericExceptionThrown:NetworkHelper.kt$NetworkHelper$throw Exception("chain query is null")</ID>
    <ID>TooGenericExceptionThrown:OnboardingSupervisor.kt$OnboardingSupervisor$throw Exception("Transfer is null")</ID>
    <ID>TooGenericExceptionThrown:OnboardingSupervisor.kt$OnboardingSupervisor$throw Exception("address is null")</ID>
    <ID>TooGenericExceptionThrown:OnboardingSupervisor.kt$OnboardingSupervisor$throw Exception("destination address is null")</ID>
    <ID>TooGenericExceptionThrown:OnboardingSupervisor.kt$OnboardingSupervisor$throw Exception("size is null")</ID>
    <ID>TooGenericExceptionThrown:OnboardingSupervisor.kt$OnboardingSupervisor$throw Exception("usdcSize is null")</ID>
    <ID>TooGenericExceptionThrown:OrderbookProcessor.kt$OrderbookProcessor$throw Exception()</ID>
    <ID>TooGenericExceptionThrown:StateManagerAdaptor.kt$StateManagerAdaptor$throw Exception("Transfer is null")</ID>
    <ID>TooGenericExceptionThrown:StateManagerAdaptor.kt$StateManagerAdaptor$throw Exception("Unexpected restriction value")</ID>
    <ID>TooGenericExceptionThrown:StateManagerAdaptor.kt$StateManagerAdaptor$throw Exception("address is null")</ID>
    <ID>TooGenericExceptionThrown:StateManagerAdaptor.kt$StateManagerAdaptor$throw Exception("clientId is null")</ID>
    <ID>TooGenericExceptionThrown:StateManagerAdaptor.kt$StateManagerAdaptor$throw Exception("clobPairId is null")</ID>
    <ID>TooGenericExceptionThrown:StateManagerAdaptor.kt$StateManagerAdaptor$throw Exception("destination address is null")</ID>
    <ID>TooGenericExceptionThrown:StateManagerAdaptor.kt$StateManagerAdaptor$throw Exception("goodTil is null")</ID>
    <ID>TooGenericExceptionThrown:StateManagerAdaptor.kt$StateManagerAdaptor$throw Exception("invalid duration")</ID>
    <ID>TooGenericExceptionThrown:StateManagerAdaptor.kt$StateManagerAdaptor$throw Exception("invalid triggerOrderType")</ID>
    <ID>TooGenericExceptionThrown:StateManagerAdaptor.kt$StateManagerAdaptor$throw Exception("market is null")</ID>
    <ID>TooGenericExceptionThrown:StateManagerAdaptor.kt$StateManagerAdaptor$throw Exception("marketId is null")</ID>
    <ID>TooGenericExceptionThrown:StateManagerAdaptor.kt$StateManagerAdaptor$throw Exception("order is null")</ID>
    <ID>TooGenericExceptionThrown:StateManagerAdaptor.kt$StateManagerAdaptor$throw Exception("orderFlags is null")</ID>
    <ID>TooGenericExceptionThrown:StateManagerAdaptor.kt$StateManagerAdaptor$throw Exception("orderbook channel is null")</ID>
    <ID>TooGenericExceptionThrown:StateManagerAdaptor.kt$StateManagerAdaptor$throw Exception("price is null")</ID>
    <ID>TooGenericExceptionThrown:StateManagerAdaptor.kt$StateManagerAdaptor$throw Exception("side is null")</ID>
    <ID>TooGenericExceptionThrown:StateManagerAdaptor.kt$StateManagerAdaptor$throw Exception("size is null")</ID>
    <ID>TooGenericExceptionThrown:StateManagerAdaptor.kt$StateManagerAdaptor$throw Exception("subaccount channel is null")</ID>
    <ID>TooGenericExceptionThrown:StateManagerAdaptor.kt$StateManagerAdaptor$throw Exception("subaccount is null")</ID>
    <ID>TooGenericExceptionThrown:StateManagerAdaptor.kt$StateManagerAdaptor$throw Exception("subaccountNumber is null")</ID>
    <ID>TooGenericExceptionThrown:StateManagerAdaptor.kt$StateManagerAdaptor$throw Exception("summary is null")</ID>
    <ID>TooGenericExceptionThrown:StateManagerAdaptor.kt$StateManagerAdaptor$throw Exception("summary.price is null")</ID>
    <ID>TooGenericExceptionThrown:StateManagerAdaptor.kt$StateManagerAdaptor$throw Exception("trades channel is null")</ID>
    <ID>TooGenericExceptionThrown:StateManagerAdaptor.kt$StateManagerAdaptor$throw Exception("triggerPrice is null")</ID>
    <ID>TooGenericExceptionThrown:StateManagerAdaptor.kt$StateManagerAdaptor$throw Exception("type is null")</ID>
    <ID>TooGenericExceptionThrown:StateManagerAdaptor.kt$StateManagerAdaptor$throw Exception("usdcSize is null")</ID>
    <ID>TooGenericExceptionThrown:SubaccountSupervisor.kt$SubaccountSupervisor$throw Exception("Transfer is null")</ID>
    <ID>TooGenericExceptionThrown:SubaccountSupervisor.kt$SubaccountSupervisor$throw Exception("destination address is null")</ID>
    <ID>TooGenericExceptionThrown:SubaccountSupervisor.kt$SubaccountSupervisor$throw Exception("goodTil is null")</ID>
    <ID>TooGenericExceptionThrown:SubaccountSupervisor.kt$SubaccountSupervisor$throw Exception("invalid duration")</ID>
    <ID>TooGenericExceptionThrown:SubaccountSupervisor.kt$SubaccountSupervisor$throw Exception("invalid triggerOrderType")</ID>
    <ID>TooGenericExceptionThrown:SubaccountSupervisor.kt$SubaccountSupervisor$throw Exception("marginMode is null")</ID>
    <ID>TooGenericExceptionThrown:SubaccountSupervisor.kt$SubaccountSupervisor$throw Exception("marketId is null")</ID>
    <ID>TooGenericExceptionThrown:SubaccountSupervisor.kt$SubaccountSupervisor$throw Exception("order is null")</ID>
    <ID>TooGenericExceptionThrown:SubaccountSupervisor.kt$SubaccountSupervisor$throw Exception("price is null")</ID>
    <ID>TooGenericExceptionThrown:SubaccountSupervisor.kt$SubaccountSupervisor$throw Exception("side is null")</ID>
    <ID>TooGenericExceptionThrown:SubaccountSupervisor.kt$SubaccountSupervisor$throw Exception("size is null")</ID>
    <ID>TooGenericExceptionThrown:SubaccountSupervisor.kt$SubaccountSupervisor$throw Exception("subaccount channel is null")</ID>
    <ID>TooGenericExceptionThrown:SubaccountSupervisor.kt$SubaccountSupervisor$throw Exception("subaccount is null")</ID>
    <ID>TooGenericExceptionThrown:SubaccountSupervisor.kt$SubaccountSupervisor$throw Exception("summary is null")</ID>
    <ID>TooGenericExceptionThrown:SubaccountSupervisor.kt$SubaccountSupervisor$throw Exception("summary.price is null")</ID>
    <ID>TooGenericExceptionThrown:SubaccountSupervisor.kt$SubaccountSupervisor$throw Exception("triggerPrice is null")</ID>
    <ID>TooGenericExceptionThrown:SubaccountSupervisor.kt$SubaccountSupervisor$throw Exception("type is null")</ID>
    <ID>TooGenericExceptionThrown:SubaccountSupervisor.kt$SubaccountSupervisor$throw Exception("usdcSize is null")</ID>
    <ID>TooGenericExceptionThrown:V4StateManagerAdaptor.kt$V4StateManagerAdaptor$throw Exception("candlesChannel is null")</ID>
    <ID>TooGenericExceptionThrown:V4StateManagerAdaptor.kt$V4StateManagerAdaptor$throw Exception("chain is not DYDXChainTransactionsProtocol")</ID>
    <ID>TooGenericExceptionThrown:V4StateManagerAdaptor.kt$V4StateManagerAdaptor$throw Exception("chain query is null")</ID>
    <ID>TooManyFunctions:AccountProcessor.kt$SubaccountProcessor : BaseProcessor</ID>
    <ID>TooManyFunctions:AccountProcessor.kt$V4AccountProcessor : BaseProcessor</ID>
    <ID>TooManyFunctions:AccountSupervisor.kt$AccountSupervisor : DynamicNetworkSupervisor</ID>
    <ID>TooManyFunctions:AccountSupervisor.kt$exchange.dydx.abacus.state.v2.supervisor.AccountSupervisor.kt</ID>
    <ID>TooManyFunctions:AccountsSupervisor.kt$exchange.dydx.abacus.state.v2.supervisor.AccountsSupervisor.kt</ID>
    <ID>TooManyFunctions:AsyncAbacusStateManager.kt$AsyncAbacusStateManager : SingletonAsyncAbacusStateManagerProtocol</ID>
    <ID>TooManyFunctions:AsyncAbacusStateManagerProtocol.kt$AsyncAbacusStateManagerProtocol</ID>
    <ID>TooManyFunctions:AsyncAbacusStateManagerV2.kt$AsyncAbacusStateManagerV2 : SingletonAsyncAbacusStateManagerProtocol</ID>
    <ID>TooManyFunctions:BaseProcessor.kt$BaseProcessor</ID>
    <ID>TooManyFunctions:ConnectionsSupervisor.kt$ConnectionsSupervisor : NetworkSupervisorConnectionStatsDelegate</ID>
    <ID>TooManyFunctions:DynamicLocalizer.kt$DynamicLocalizer : AbacusLocalizerProtocol</ID>
    <ID>TooManyFunctions:Map+Utils.kt$exchange.dydx.abacus.utils.Map+Utils.kt</ID>
    <ID>TooManyFunctions:MarketProcessor.kt$MarketProcessor : BaseProcessor</ID>
    <ID>TooManyFunctions:MarketSupervisor.kt$MarketSupervisor : DynamicNetworkSupervisor</ID>
    <ID>TooManyFunctions:MarketsProcessor.kt$MarketsProcessor : BaseProcessor</ID>
    <ID>TooManyFunctions:MarketsSummaryProcessor.kt$MarketsSummaryProcessor : BaseProcessor</ID>
    <ID>TooManyFunctions:MarketsSupervisor.kt$MarketsSupervisor : NetworkSupervisor</ID>
    <ID>TooManyFunctions:NetworkHelper.kt$NetworkHelper</ID>
    <ID>TooManyFunctions:NetworkSupervisor.kt$NetworkSupervisor</ID>
    <ID>TooManyFunctions:NotificationsProvider.kt$NotificationsProvider</ID>
    <ID>TooManyFunctions:OnboardingSupervisor.kt$OnboardingSupervisor : NetworkSupervisor</ID>
    <ID>TooManyFunctions:OrderbookProcessor.kt$OrderbookProcessor : BaseProcessor</ID>
    <ID>TooManyFunctions:Parser.kt$Parser : ParserProtocol</ID>
    <ID>TooManyFunctions:ParserProtocol.kt$ParserProtocol</ID>
    <ID>TooManyFunctions:PerpetualState.kt$PerpetualState</ID>
    <ID>TooManyFunctions:PublicProtocols.kt$DataNotificationProtocol</ID>
    <ID>TooManyFunctions:SquidProcessor.kt$SquidProcessor : BaseProcessor</ID>
    <ID>TooManyFunctions:StateManagerAdaptor.kt$StateManagerAdaptor</ID>
    <ID>TooManyFunctions:StateManagerAdaptorV2.kt$StateManagerAdaptorV2 : ConnectionDelegate</ID>
    <ID>TooManyFunctions:StateManagerConfigs.kt$StateManagerConfigs</ID>
    <ID>TooManyFunctions:SubaccountCalculator.kt$SubaccountCalculator</ID>
    <ID>TooManyFunctions:SubaccountSupervisor.kt$SubaccountSupervisor : DynamicNetworkSupervisor</ID>
    <ID>TooManyFunctions:SubaccountTransformer.kt$SubaccountTransformer</ID>
    <ID>TooManyFunctions:SystemSupervisor.kt$SystemSupervisor : NetworkSupervisor</ID>
    <ID>TooManyFunctions:TradeBracketOrdersValidator.kt$TradeBracketOrdersValidator : BaseInputValidatorTradeValidatorProtocol</ID>
    <ID>TooManyFunctions:TradeInputCalculator.kt$TradeInputCalculator</ID>
    <ID>TooManyFunctions:TradingStateMachine+Wallet.kt$exchange.dydx.abacus.state.model.TradingStateMachine+Wallet.kt</ID>
    <ID>TooManyFunctions:TradingStateMachine.kt$TradingStateMachine</ID>
    <ID>TooManyFunctions:TriggerOrdersInputValidator.kt$TriggerOrdersInputValidator : BaseInputValidatorValidatorProtocol</ID>
    <ID>TooManyFunctions:V4StateManagerAdaptor+Transfer.kt$exchange.dydx.abacus.state.manager.V4StateManagerAdaptor+Transfer.kt</ID>
    <ID>TooManyFunctions:V4StateManagerAdaptor.kt$V4StateManagerAdaptor : StateManagerAdaptor</ID>
    <ID>TooManyFunctions:V4StateManagerConfigs.kt$V4StateManagerConfigs : StateManagerConfigs</ID>
    <ID>TooManyFunctions:WalletProcessor.kt$WalletProcessor : BaseProcessor</ID>
    <ID>UnusedParameter:AccountCalculator.kt$AccountCalculator$childSubaccountNumber: Int</ID>
    <ID>UnusedParameter:AccountInputValidator.kt$AccountInputValidator$parser: ParserProtocol</ID>
    <ID>UnusedParameter:AccountProcessor.kt$V4AccountDelegationsProcessor$existing: Map&lt;String, Any&gt;?</ID>
    <ID>UnusedParameter:AccountSupervisor.kt$AccountSupervisor$accountAddressRestriction: Restriction?</ID>
    <ID>UnusedParameter:AccountSupervisor.kt$AccountSupervisor$addressRestriction: UsageRestriction?</ID>
    <ID>UnusedParameter:AccountSupervisor.kt$AccountSupervisor$oldValue: String?</ID>
    <ID>UnusedParameter:AccountSupervisor.kt$AccountSupervisor$sourceAddressRestriction: Restriction?</ID>
    <ID>UnusedParameter:ConnectionStats.kt$ConnectionStats$indexerRestriction: UsageRestriction?</ID>
    <ID>UnusedParameter:Double+Utils.kt$ignore: Boolean</ID>
    <ID>UnusedParameter:LaunchIncentive.kt$LaunchIncentive.Companion$existing: LaunchIncentive?</ID>
    <ID>UnusedParameter:Market.kt$MarketOrderbook.Companion$ascending: Boolean</ID>
    <ID>UnusedParameter:Market.kt$MarketOrderbook.Companion$existing: IList&lt;OrderbookLine&gt;?</ID>
    <ID>UnusedParameter:Market.kt$PerpetualMarket.Companion$assets: Map&lt;String, Any&gt;?</ID>
    <ID>UnusedParameter:Market.kt$PerpetualMarket.Companion$resetOrderbook: Boolean</ID>
    <ID>UnusedParameter:Market.kt$PerpetualMarket.Companion$resetTrades: Boolean</ID>
    <ID>UnusedParameter:MarketCalculator.kt$MarketCalculator$keys: Set&lt;String&gt;? = null</ID>
    <ID>UnusedParameter:MarketsSupervisor.kt$MarketsSupervisor$oldValue: String</ID>
    <ID>UnusedParameter:NetworkHelper.kt$NetworkHelper$indexerRestriction: UsageRestriction?</ID>
    <ID>UnusedParameter:NotificationsProvider.kt$NotificationsProvider$stateMachine: TradingStateMachine</ID>
    <ID>UnusedParameter:OnboardingSupervisor.kt$OnboardingSupervisor$data: String?</ID>
    <ID>UnusedParameter:OnboardingSupervisor.kt$OnboardingSupervisor$requestId: String?</ID>
    <ID>UnusedParameter:OnboardingSupervisor.kt$OnboardingSupervisor$sourceAddress: String</ID>
    <ID>UnusedParameter:OrderbookProcessor.kt$OrderbookProcessor$stepSize: Double</ID>
    <ID>UnusedParameter:StateManagerAdaptor.kt$StateManagerAdaptor$accountAddressRestriction: Restriction?</ID>
    <ID>UnusedParameter:StateManagerAdaptor.kt$StateManagerAdaptor$addressRestriction: UsageRestriction?</ID>
    <ID>UnusedParameter:StateManagerAdaptor.kt$StateManagerAdaptor$oldValue: String?</ID>
    <ID>UnusedParameter:StateManagerAdaptor.kt$StateManagerAdaptor$sourceAddressRestriction: Restriction?</ID>
    <ID>UnusedParameter:SubaccountCalculator.kt$SubaccountCalculator$configs: Map&lt;String, Any&gt;?</ID>
    <ID>UnusedParameter:SubaccountCalculator.kt$SubaccountCalculator$notional: Double</ID>
    <ID>UnusedParameter:SubaccountCalculator.kt$SubaccountCalculator$size: Double?</ID>
    <ID>UnusedParameter:SubaccountCalculator.kt$SubaccountCalculator$subaccount: Map&lt;String, Any&gt;</ID>
    <ID>UnusedParameter:TradeAccountStateValidator.kt$TradeAccountStateValidator$parser: ParserProtocol</ID>
    <ID>UnusedParameter:TradeAccountStateValidator.kt$TradeAccountStateValidator$subaccount: Map&lt;String, Any&gt;</ID>
    <ID>UnusedParameter:TradeInputDataValidator.kt$TradeInputDataValidator$market: Map&lt;String, Any&gt;?</ID>
    <ID>UnusedParameter:TradeInputValidator.kt$TradeInputValidator$subaccount: Map&lt;String, Any&gt;?</ID>
    <ID>UnusedParameter:TradeInputValidator.kt$TradeInputValidator$trade: Map&lt;String, Any&gt;</ID>
    <ID>UnusedParameter:TradeMarketOrderInputValidator.kt$TradeMarketOrderInputValidator$markets: Map&lt;String, Any&gt;?</ID>
    <ID>UnusedParameter:TradePositionStateValidator.kt$TradePositionStateValidator$restricted: Boolean</ID>
    <ID>UnusedParameter:TradeTriggerPriceValidator.kt$TradeTriggerPriceValidator$parser: ParserProtocol</ID>
    <ID>UnusedParameter:TradingStateMachine+Orderbook.kt$payload: Map&lt;String, Any&gt;</ID>
    <ID>UnusedParameter:TradingStateMachine+TriggerOrdersInput.kt$triggerOrders: Map&lt;String, Any&gt;</ID>
    <ID>UnusedParameter:TradingStateMachine+TriggerOrdersInput.kt$typeText: String?</ID>
    <ID>UnusedParameter:TradingStateMachine.kt$TradingStateMachine$height: Int?</ID>
    <ID>UnusedParameter:TradingStateMachine.kt$TradingStateMachine$markets: Map&lt;String, Any&gt;</ID>
    <ID>UnusedParameter:TradingStateMachine.kt$TradingStateMachine$markets: Map&lt;String, Any&gt;?</ID>
    <ID>UnusedParameter:TradingStateMachine.kt$TradingStateMachine$period: String? = null</ID>
    <ID>UnusedParameter:TradingStateMachine.kt$TradingStateMachine$url: AbUrl</ID>
    <ID>UnusedParameter:TransferInputValidator.kt$TransferInputValidator$subaccount: Map&lt;String, Any&gt;?</ID>
    <ID>UnusedParameter:TransferInputValidator.kt$TransferInputValidator$trade: Map&lt;String, Any&gt;</ID>
    <ID>UnusedParameter:V4StateManagerAdaptor.kt$V4StateManagerAdaptor$indexerRestriction: UsageRestriction?</ID>
    <ID>UnusedPrivateMember:Account.kt$Subaccount.Companion$private fun fundingPayments( parser: ParserProtocol, existing: IList&lt;SubaccountFundingPayment&gt;?, data: List&lt;*&gt;?, ): IList&lt;SubaccountFundingPayment&gt;?</ID>
    <ID>UnusedPrivateMember:Account.kt$Subaccount.Companion$private fun transfers( parser: ParserProtocol, existing: IList&lt;SubaccountTransfer&gt;?, data: List&lt;*&gt;?, ): IList&lt;SubaccountTransfer&gt;?</ID>
    <ID>UnusedPrivateMember:AsyncAbacusStateManager.kt$AsyncAbacusStateManager.Companion$private fun createIOImplementions(_nativeImplementations: ProtocolNativeImpFactory): IOImplementations</ID>
    <ID>UnusedPrivateMember:AsyncAbacusStateManager.kt$AsyncAbacusStateManager.Companion$private fun createUIImplemention(_nativeImplementations: ProtocolNativeImpFactory): UIImplementations</ID>
    <ID>UnusedPrivateMember:AsyncAbacusStateManagerV2.kt$AsyncAbacusStateManagerV2.Companion$private fun createIOImplementions(_nativeImplementations: ProtocolNativeImpFactory): IOImplementations</ID>
    <ID>UnusedPrivateMember:AsyncAbacusStateManagerV2.kt$AsyncAbacusStateManagerV2.Companion$private fun createUIImplemention(_nativeImplementations: ProtocolNativeImpFactory): UIImplementations</ID>
    <ID>UnusedPrivateMember:JsonEncoder.kt$JsonEncoder$private fun boolean(element: Any): Boolean?</ID>
    <ID>UnusedPrivateMember:OnboardingSupervisor.kt$OnboardingSupervisor$private fun transferNobleBalance(accountAddress: String, amount: BigDecimal)</ID>
    <ID>UnusedPrivateMember:OrderbookProcessor.kt$OrderbookProcessor$@Throws(Exception::class) private fun compareResults( result1: List&lt;Map&lt;String, Any&gt;&gt;, result2: List&lt;Map&lt;String, Any&gt;&gt; )</ID>
    <ID>UnusedPrivateMember:OrderbookProcessor.kt$OrderbookProcessor$private fun receivedChangesLinear( existing: List&lt;Map&lt;String, Any&gt;&gt;?, changes: List&lt;Any&gt;, offset: Long?, ascending: Boolean ): List&lt;Map&lt;String, Any&gt;&gt;</ID>
    <ID>UnusedPrivateMember:StateManagerAdaptor.kt$StateManagerAdaptor$private fun nextMinute(): Instant</ID>
    <ID>UnusedPrivateMember:StateManagerConfigs.kt$StateManagerConfigs$private fun faucetApiPath(type: String): String?</ID>
    <ID>UnusedPrivateMember:SubaccountSupervisor.kt$SubaccountSupervisor$private fun faucetBody(amount: Double): String?</ID>
    <ID>UnusedPrivateMember:SubaccountTransformer.kt$SubaccountTransformer$private fun adjustDeltaSize( size: Double, deltaSize: Double, reduceOnly: Boolean ): Double</ID>
    <ID>UnusedPrivateMember:TradeInputCalculator.kt$TradeInputCalculator$private fun marketOrderUsdcSize(marketOrder: Map&lt;String, Any&gt;): Double?</ID>
    <ID>UnusedPrivateMember:TradeInputCalculator.kt$TradeInputCalculator$private fun maxLeverage( subaccount: Map&lt;String, Any&gt;?, market: Map&lt;String, Any&gt;? ): Double?</ID>
    <ID>UnusedPrivateMember:TradeMarketOrderInputValidator.kt$TradeMarketOrderInputValidator$private fun accountRestricted(): Boolean</ID>
    <ID>UnusedPrivateMember:TradingStateMachine.kt$TradingStateMachine$private fun calculateAccount(subaccountNumbers: IList&lt;Int&gt;, period: CalculationPeriod)</ID>
    <ID>UnusedPrivateMember:TradingStateMachine.kt$TradingStateMachine$private fun groupedSubaccountFills(subaccountNumber: Int): IList&lt;Any&gt;?</ID>
    <ID>UnusedPrivateMember:TradingStateMachine.kt$TradingStateMachine$private fun groupedSubaccountFundingPayments(subaccountNumber: Int): IList&lt;Any&gt;?</ID>
    <ID>UnusedPrivateMember:TradingStateMachine.kt$TradingStateMachine$private fun groupedSubaccountHistoricalPnl(subaccountNumber: Int): IList&lt;Any&gt;?</ID>
    <ID>UnusedPrivateMember:TradingStateMachine.kt$TradingStateMachine$private fun groupedSubaccountTransfers(subaccountNumber: Int): IList&lt;Any&gt;?</ID>
    <ID>UnusedPrivateMember:TransferInputCalculator.kt$TransferInputCalculator$private fun calculatedOptions(type: String): Map&lt;String, Any&gt;?</ID>
    <ID>UnusedPrivateMember:TransferInputValidator.kt$TransferInputValidator$private fun validateClosingOnly( subaccount: Map&lt;String, Any&gt;?, market: Map&lt;String, Any&gt;?, trade: Map&lt;String, Any&gt;, change: PositionChange, restricted: Boolean, ): Map&lt;String, Any&gt;?</ID>
    <ID>UnusedPrivateProperty:Account.kt$Subaccount.Companion$val ethereumeAddress = parser.asString(data["ethereumeAddress"])</ID>
    <ID>UnusedPrivateProperty:AccountProcessor.kt$V4AccountProcessor$val test = parser.value(payload, "subaccounts.0.tradingRewards")</ID>
    <ID>UnusedPrivateProperty:AsyncAbacusStateManager.kt$AsyncAbacusStateManager$private val documentationFile = ConfigFile.DOCUMENTATION</ID>
    <ID>UnusedPrivateProperty:AsyncAbacusStateManager.kt$AsyncAbacusStateManager$private val environmentsFile = ConfigFile.ENV</ID>
    <ID>UnusedPrivateProperty:AsyncAbacusStateManagerV2.kt$AsyncAbacusStateManagerV2$private val documentationFile = ConfigFile.DOCUMENTATION</ID>
    <ID>UnusedPrivateProperty:AsyncAbacusStateManagerV2.kt$AsyncAbacusStateManagerV2$private val environmentsFile = ConfigFile.ENV</ID>
    <ID>UnusedPrivateProperty:ConnectionStats.kt$ConnectionStats$private var indexerRestriction: UsageRestriction? = null set(value) { if (field !== value) { field = value didSetIndexerRestriction(field) } }</ID>
    <ID>UnusedPrivateProperty:Double+Utils.kt$i</ID>
    <ID>UnusedPrivateProperty:InputValidator.kt$InputValidator$private val errorTypeLookup = mapOf&lt;String, Int&gt;( "ERROR" to 0, "REQUIRED" to 1, "WARNING" to 2, )</ID>
    <ID>UnusedPrivateProperty:LaunchIncentiveProcessor.kt$LaunchIncentiveProcessor$private val pointsProcessor = LaunchIncentivePointsProcessor(parser = parser)</ID>
    <ID>UnusedPrivateProperty:OrderProcessor.kt$OrderProcessor$val status = parser.asString(existing["status"])</ID>
    <ID>UnusedPrivateProperty:Rounder.kt$Rounder.Companion$i</ID>
    <ID>UnusedPrivateProperty:StateManagerAdaptor.kt$StateManagerAdaptor$val transferType = transfer.type</ID>
    <ID>UnusedPrivateProperty:StringHelper.kt$StringHelper.Companion$i</ID>
    <ID>UnusedPrivateProperty:SubaccountSupervisor.kt$SubaccountSupervisor$val transferType = transfer.type</ID>
    <ID>UnusedPrivateProperty:TradeInput.kt$TradeInputOptions.Companion$private val typeOptionsArray = iListOf( SelectionOption( OrderType.limit.rawValue, null, "APP.TRADE.LIMIT_ORDER_SHORT", null, ), SelectionOption( OrderType.market.rawValue, null, "APP.TRADE.MARKET_ORDER_SHORT", null, ), SelectionOption(OrderType.stopLimit.rawValue, null, "APP.TRADE.STOP_LIMIT", null), SelectionOption(OrderType.stopMarket.rawValue, null, "APP.TRADE.STOP_MARKET", null), SelectionOption( OrderType.trailingStop.rawValue, null, "APP.TRADE.TRAILING_STOP", null, ), SelectionOption( OrderType.takeProfitLimit.rawValue, null, "APP.TRADE.TAKE_PROFIT", null, ), SelectionOption( OrderType.takeProfitMarket.rawValue, null, "APP.TRADE.TAKE_PROFIT_MARKET", null, ), )</ID>
    <ID>UnusedPrivateProperty:TradeInputCalculator.kt$TradeInputCalculator$@Suppress("LocalVariableName", "PropertyName") private val MARKET_ORDER_SLIPPAGE_WARNING_THRESHOLD = 0.01</ID>
    <ID>UnusedPrivateProperty:TradePositionStateValidator.kt$TradePositionStateValidator$val closeOnlyError = validateCloseOnly( market, change, )</ID>
    <ID>UnusedPrivateProperty:TradingStateMachine.kt$TradingStateMachine$val startTime = now - days.days</ID>
    <ID>UtilityClassWithPublicConstructor:AbacusHelper.kt$AbacusHelper</ID>
    <ID>UtilityClassWithPublicConstructor:GoodTil.kt$GoodTil</ID>
    <ID>UtilityClassWithPublicConstructor:MarketId.kt$MarketId</ID>
    <ID>UtilityClassWithPublicConstructor:Numeric.kt$Numeric</ID>
    <ID>UtilityClassWithPublicConstructor:OrderTypeProcessor.kt$OrderTypeProcessor</ID>
    <ID>UtilityClassWithPublicConstructor:ParsingHelper.kt$ParsingHelper</ID>
    <ID>UtilityClassWithPublicConstructor:ServerTime.kt$ServerTime</ID>
    <ID>UtilityClassWithPublicConstructor:StringHelper.kt$StringHelper</ID>
    <ID>UtilityClassWithPublicConstructor:SystemUtils.kt$SystemUtils</ID>
    <ID>UtilityClassWithPublicConstructor:V4TransactionErrors.kt$V4TransactionErrors</ID>
    <ID>VariableNaming:ConnectionStats.kt$ConnectionStats$@Suppress("PropertyName") private val MAX_NUM_BLOCK_DELAY = 15</ID>
    <ID>VariableNaming:Numeric.kt$Decimals$@Suppress("PropertyName") val NEGATIVE = (-1.0).toBigDecimal(null, mode)</ID>
    <ID>VariableNaming:Numeric.kt$Decimals$@Suppress("PropertyName") val ONE = (1.0).toBigDecimal(null, mode)</ID>
    <ID>VariableNaming:Numeric.kt$Decimals$@Suppress("PropertyName") val POSITIVE = (1.0).toBigDecimal(null, mode)</ID>
    <ID>VariableNaming:Numeric.kt$Decimals$@Suppress("PropertyName") val TEN = (10.0).toBigDecimal(null, mode)</ID>
    <ID>VariableNaming:Numeric.kt$Decimals$@Suppress("PropertyName") val ZERO = (0.0).toBigDecimal(null, mode)</ID>
    <ID>VariableNaming:Numeric.kt$Doubles$@Suppress("PropertyName") val NEGATIVE = -1.0</ID>
    <ID>VariableNaming:Numeric.kt$Doubles$@Suppress("PropertyName") val ONE = 1.0</ID>
    <ID>VariableNaming:Numeric.kt$Doubles$@Suppress("PropertyName") val POSITIVE = 1.0</ID>
    <ID>VariableNaming:Numeric.kt$Doubles$@Suppress("PropertyName") val TEN = 10.0</ID>
    <ID>VariableNaming:Numeric.kt$Doubles$@Suppress("PropertyName") val ZERO = 0.0</ID>
    <ID>VariableNaming:StateManagerAdaptor.kt$StateManagerAdaptor$@Suppress("LocalVariableName", "PropertyName") private val TRIGGER_ORDER_DEFAULT_DURATION_DAYS = 28.0</ID>
    <ID>VariableNaming:SubaccountSupervisor.kt$SubaccountSupervisor$@Suppress("LocalVariableName", "PropertyName") private val TRIGGER_ORDER_DEFAULT_DURATION_DAYS = 28.0</ID>
    <ID>VariableNaming:TradeInputCalculator.kt$TradeInputCalculator$@Suppress("LocalVariableName", "PropertyName") private val MARKET_ORDER_MAX_SLIPPAGE = 0.05</ID>
    <ID>VariableNaming:TradeInputCalculator.kt$TradeInputCalculator$@Suppress("LocalVariableName", "PropertyName") private val MARKET_ORDER_SLIPPAGE_WARNING_THRESHOLD = 0.01</ID>
    <ID>VariableNaming:TradeInputCalculator.kt$TradeInputCalculator$@Suppress("LocalVariableName", "PropertyName") private val STOP_MARKET_ORDER_SLIPPAGE_BUFFER = 0.1</ID>
    <ID>VariableNaming:TradeInputCalculator.kt$TradeInputCalculator$@Suppress("LocalVariableName", "PropertyName") private val STOP_MARKET_ORDER_SLIPPAGE_BUFFER_MAJOR_MARKET = 0.05</ID>
    <ID>VariableNaming:TradeInputCalculator.kt$TradeInputCalculator$@Suppress("LocalVariableName", "PropertyName") private val TAKE_PROFIT_MARKET_ORDER_SLIPPAGE_BUFFER = 0.2</ID>
    <ID>VariableNaming:TradeInputCalculator.kt$TradeInputCalculator$@Suppress("LocalVariableName", "PropertyName") private val TAKE_PROFIT_MARKET_ORDER_SLIPPAGE_BUFFER_MAJOR_MARKET = 0.1</ID>
    <ID>VariableNaming:TradeInputCalculator.kt$TradeInputCalculator$@Suppress("LocalVariableName", "PropertyName") val FR = parser.asDouble(feeRate)!!</ID>
    <ID>VariableNaming:TradeInputCalculator.kt$TradeInputCalculator$@Suppress("LocalVariableName", "PropertyName") val LV = parser.asDouble(leverage)!!</ID>
    <ID>VariableNaming:TradeInputCalculator.kt$TradeInputCalculator$@Suppress("LocalVariableName", "PropertyName") val MP = entryPrice</ID>
    <ID>VariableNaming:TradeInputCalculator.kt$TradeInputCalculator$@Suppress("LocalVariableName", "PropertyName") val OR = parser.asDouble(oraclePrice)!!</ID>
    <ID>VariableNaming:TradeInputCalculator.kt$TradeInputCalculator$@Suppress("LocalVariableName", "PropertyName") val OS: Double = if (isBuying) Numeric.double.POSITIVE else Numeric.double.NEGATIVE</ID>
    <ID>VariableNaming:TradeInputCalculator.kt$TradeInputCalculator$@Suppress("LocalVariableName", "PropertyName") val X = ((LV * AE) - (SZ * OR)) / (OR + (OS * LV * MP * FR) - (LV * (OR - MP)))</ID>
    <ID>VariableNaming:TradeInputCalculator.kt$TradeInputCalculator$@Suppress("LocalVariableName", "PropertyName") var AE = parser.asDouble(equity)!!</ID>
    <ID>VariableNaming:TradeInputCalculator.kt$TradeInputCalculator$@Suppress("LocalVariableName", "PropertyName") var SZ = parser.asDouble(positionSize) ?: Numeric.double.ZERO</ID>
    <ID>VariableNaming:TradeInputDataValidator.kt$TradeInputDataValidator$@Suppress("PropertyName") private val MAX_NUM_OPEN_UNTRIGGERED_ORDERS: Int = 20</ID>
    <ID>VariableNaming:TradeMarketOrderInputValidator.kt$TradeMarketOrderInputValidator$@Suppress("LocalVariableName", "PropertyName") private val MARKET_ORDER_ERROR_SLIPPAGE = 0.1</ID>
    <ID>VariableNaming:TradeMarketOrderInputValidator.kt$TradeMarketOrderInputValidator$@Suppress("LocalVariableName", "PropertyName") private val MARKET_ORDER_WARNING_SLIPPAGE = 0.05</ID>
    <ID>VariableNaming:TradesProcessor.kt$TradesProcessor$@Suppress("PropertyName") private val LIMIT = 500</ID>
    <ID>VariableNaming:TriggerOrdersInputCalculator.kt$TriggerOrdersInputCalculator$@Suppress("LocalVariableName", "PropertyName") private val STOP_MARKET_ORDER_SLIPPAGE_BUFFER = 0.1</ID>
    <ID>VariableNaming:TriggerOrdersInputCalculator.kt$TriggerOrdersInputCalculator$@Suppress("LocalVariableName", "PropertyName") private val STOP_MARKET_ORDER_SLIPPAGE_BUFFER_MAJOR_MARKET = 0.05</ID>
    <ID>VariableNaming:TriggerOrdersInputCalculator.kt$TriggerOrdersInputCalculator$@Suppress("LocalVariableName", "PropertyName") private val TAKE_PROFIT_MARKET_ORDER_SLIPPAGE_BUFFER = 0.2</ID>
    <ID>VariableNaming:TriggerOrdersInputCalculator.kt$TriggerOrdersInputCalculator$@Suppress("LocalVariableName", "PropertyName") private val TAKE_PROFIT_MARKET_ORDER_SLIPPAGE_BUFFER_MAJOR_MARKET = 0.1</ID>
    <ID>VariableNaming:TriggerOrdersInputValidator.kt$TriggerOrdersInputValidator$@Suppress("PropertyName") private val MAX_NUM_OPEN_UNTRIGGERED_ORDERS: Int = 20</ID>
  </CurrentIssues>
</SmellBaseline>
