<?xml version="1.0" ?>
<SmellBaseline>
  <ManuallySuppressedIssues></ManuallySuppressedIssues>
  <CurrentIssues>
    <ID>EmptyDefaultConstructor:AccountTransformer.kt$AccountTransformer$()</ID>
    <ID>EmptyDefaultConstructor:Network.kt$NetworkState$()</ID>
    <ID>EmptyDefaultConstructor:Timer.kt$LocalTimer$()</ID>
    <ID>EmptyFunctionBlock:TradingStateMachine.kt$TradingStateMachine${ }</ID>
    <ID>EnumNaming:AbacusHelper.kt$RiskLevel$high : RiskLevel</ID>
    <ID>EnumNaming:AbacusHelper.kt$RiskLevel$low : RiskLevel</ID>
    <ID>EnumNaming:AbacusHelper.kt$RiskLevel$medium : RiskLevel</ID>
    <ID>EnumNaming:Account.kt$FillLiquidity$maker : FillLiquidity</ID>
    <ID>EnumNaming:Account.kt$FillLiquidity$taker : FillLiquidity</ID>
    <ID>EnumNaming:ApiUtils.kt$HttpVerb$delete : HttpVerb</ID>
    <ID>EnumNaming:ApiUtils.kt$HttpVerb$get : HttpVerb</ID>
    <ID>EnumNaming:ApiUtils.kt$HttpVerb$post : HttpVerb</ID>
    <ID>EnumNaming:ApiUtils.kt$HttpVerb$put : HttpVerb</ID>
    <ID>EnumNaming:BaseProcessor.kt$ComparisonOrder$ascending</ID>
    <ID>EnumNaming:BaseProcessor.kt$ComparisonOrder$descending</ID>
    <ID>EnumNaming:BaseProcessor.kt$ComparisonOrder$same</ID>
    <ID>EnumNaming:PublicProtocols.kt$ThreadingType$abacus</ID>
    <ID>EnumNaming:PublicProtocols.kt$ThreadingType$main</ID>
    <ID>EnumNaming:PublicProtocols.kt$ThreadingType$network</ID>
    <ID>EnumNaming:PublicProtocols.kt$TransactionType$simulateTransferNativeToken : TransactionType</ID>
    <ID>EnumNaming:PublicProtocols.kt$TransactionType$simulateWithdraw : TransactionType</ID>
    <ID>EnumNaming:Settings.kt$OrderbookGrouping$none : OrderbookGrouping</ID>
    <ID>EnumNaming:Settings.kt$OrderbookGrouping$x10 : OrderbookGrouping</ID>
    <ID>EnumNaming:Settings.kt$OrderbookGrouping$x100 : OrderbookGrouping</ID>
    <ID>EnumNaming:Settings.kt$OrderbookGrouping$x1000 : OrderbookGrouping</ID>
    <ID>EnumNaming:StateChanges.kt$Changes$accountBalances : Changes</ID>
    <ID>EnumNaming:StateChanges.kt$Changes$assets : Changes</ID>
    <ID>EnumNaming:StateChanges.kt$Changes$candles : Changes</ID>
    <ID>EnumNaming:StateChanges.kt$Changes$compliance : Changes</ID>
    <ID>EnumNaming:StateChanges.kt$Changes$configs : Changes</ID>
    <ID>EnumNaming:StateChanges.kt$Changes$fills : Changes</ID>
    <ID>EnumNaming:StateChanges.kt$Changes$fundingPayments : Changes</ID>
    <ID>EnumNaming:StateChanges.kt$Changes$historicalFundings : Changes</ID>
    <ID>EnumNaming:StateChanges.kt$Changes$historicalPnl : Changes</ID>
    <ID>EnumNaming:StateChanges.kt$Changes$input : Changes</ID>
    <ID>EnumNaming:StateChanges.kt$Changes$launchIncentive : Changes</ID>
    <ID>EnumNaming:StateChanges.kt$Changes$markets : Changes</ID>
    <ID>EnumNaming:StateChanges.kt$Changes$orderbook : Changes</ID>
    <ID>EnumNaming:StateChanges.kt$Changes$restriction : Changes</ID>
    <ID>EnumNaming:StateChanges.kt$Changes$sparklines : Changes</ID>
    <ID>EnumNaming:StateChanges.kt$Changes$subaccount : Changes</ID>
    <ID>EnumNaming:StateChanges.kt$Changes$trades : Changes</ID>
    <ID>EnumNaming:StateChanges.kt$Changes$tradingRewards : Changes</ID>
    <ID>EnumNaming:StateChanges.kt$Changes$transferStatuses : Changes</ID>
    <ID>EnumNaming:StateChanges.kt$Changes$transfers : Changes</ID>
    <ID>EnumNaming:StateChanges.kt$Changes$wallet : Changes</ID>
    <ID>EnumNaming:SubaccountCalculator.kt$CalculationPeriod$current : CalculationPeriod</ID>
    <ID>EnumNaming:SubaccountCalculator.kt$CalculationPeriod$post : CalculationPeriod</ID>
    <ID>EnumNaming:SubaccountCalculator.kt$CalculationPeriod$settled : CalculationPeriod</ID>
    <ID>EnumNaming:SystemUtils.kt$Platform$android : Platform</ID>
    <ID>EnumNaming:SystemUtils.kt$Platform$ios : Platform</ID>
    <ID>EnumNaming:SystemUtils.kt$Platform$web : Platform</ID>
    <ID>EnumNaming:TradeInput.kt$MarginMode$cross : MarginMode</ID>
    <ID>EnumNaming:TradeInput.kt$MarginMode$isolated : MarginMode</ID>
    <ID>EnumNaming:TradeInput.kt$OrderSide$buy : OrderSide</ID>
    <ID>EnumNaming:TradeInput.kt$OrderSide$sell : OrderSide</ID>
    <ID>EnumNaming:TradeInput.kt$OrderStatus$canceling : OrderStatus</ID>
    <ID>EnumNaming:TradeInput.kt$OrderStatus$cancelled : OrderStatus</ID>
    <ID>EnumNaming:TradeInput.kt$OrderStatus$filled : OrderStatus</ID>
    <ID>EnumNaming:TradeInput.kt$OrderStatus$open : OrderStatus</ID>
    <ID>EnumNaming:TradeInput.kt$OrderStatus$partiallyFilled : OrderStatus</ID>
    <ID>EnumNaming:TradeInput.kt$OrderStatus$pending : OrderStatus</ID>
    <ID>EnumNaming:TradeInput.kt$OrderStatus$untriggered : OrderStatus</ID>
    <ID>EnumNaming:TradeInput.kt$OrderType$deleveraged : OrderType</ID>
    <ID>EnumNaming:TradeInput.kt$OrderType$finalSettlement : OrderType</ID>
    <ID>EnumNaming:TradeInput.kt$OrderType$limit : OrderType</ID>
    <ID>EnumNaming:TradeInput.kt$OrderType$liquidated : OrderType</ID>
    <ID>EnumNaming:TradeInput.kt$OrderType$liquidation : OrderType</ID>
    <ID>EnumNaming:TradeInput.kt$OrderType$market : OrderType</ID>
    <ID>EnumNaming:TradeInput.kt$OrderType$offsetting : OrderType</ID>
    <ID>EnumNaming:TradeInput.kt$OrderType$stopLimit : OrderType</ID>
    <ID>EnumNaming:TradeInput.kt$OrderType$stopMarket : OrderType</ID>
    <ID>EnumNaming:TradeInput.kt$OrderType$takeProfitLimit : OrderType</ID>
    <ID>EnumNaming:TradeInput.kt$OrderType$takeProfitMarket : OrderType</ID>
    <ID>EnumNaming:TradeInput.kt$OrderType$trailingStop : OrderType</ID>
    <ID>EnumNaming:TradeInput.kt$ReceiptLine$bridgeFee : ReceiptLine</ID>
    <ID>EnumNaming:TradeInput.kt$ReceiptLine$buyingPower : ReceiptLine</ID>
    <ID>EnumNaming:TradeInput.kt$ReceiptLine$equity : ReceiptLine</ID>
    <ID>EnumNaming:TradeInput.kt$ReceiptLine$exchangeRate : ReceiptLine</ID>
    <ID>EnumNaming:TradeInput.kt$ReceiptLine$exchangeReceived : ReceiptLine</ID>
    <ID>EnumNaming:TradeInput.kt$ReceiptLine$expectedPrice : ReceiptLine</ID>
    <ID>EnumNaming:TradeInput.kt$ReceiptLine$fee : ReceiptLine</ID>
    <ID>EnumNaming:TradeInput.kt$ReceiptLine$gasFee : ReceiptLine</ID>
    <ID>EnumNaming:TradeInput.kt$ReceiptLine$marginUsage : ReceiptLine</ID>
    <ID>EnumNaming:TradeInput.kt$ReceiptLine$reward : ReceiptLine</ID>
    <ID>EnumNaming:TradeInput.kt$ReceiptLine$slippage : ReceiptLine</ID>
    <ID>EnumNaming:TradeInput.kt$ReceiptLine$total : ReceiptLine</ID>
    <ID>EnumNaming:TradeInput.kt$ReceiptLine$transferRouteEstimatedDuration : ReceiptLine</ID>
    <ID>EnumNaming:TradeInput.kt$ReceiptLine$walletBalance : ReceiptLine</ID>
    <ID>EnumNaming:TradeInputCalculator.kt$TradeCalculation$closePosition : TradeCalculation</ID>
    <ID>EnumNaming:TradeInputCalculator.kt$TradeCalculation$trade : TradeCalculation</ID>
    <ID>EnumNaming:TradingStateMachine+ClosePositionInput.kt$ClosePositionInputField$market : ClosePositionInputField</ID>
    <ID>EnumNaming:TradingStateMachine+ClosePositionInput.kt$ClosePositionInputField$percent : ClosePositionInputField</ID>
    <ID>EnumNaming:TradingStateMachine+ClosePositionInput.kt$ClosePositionInputField$size : ClosePositionInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TradeInput.kt$TradeInputField$bracketsExecution : TradeInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TradeInput.kt$TradeInputField$bracketsGoodUntilDuration : TradeInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TradeInput.kt$TradeInputField$bracketsGoodUntilUnit : TradeInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TradeInput.kt$TradeInputField$bracketsStopLossPercent : TradeInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TradeInput.kt$TradeInputField$bracketsStopLossPrice : TradeInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TradeInput.kt$TradeInputField$bracketsStopLossReduceOnly : TradeInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TradeInput.kt$TradeInputField$bracketsTakeProfitPercent : TradeInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TradeInput.kt$TradeInputField$bracketsTakeProfitPrice : TradeInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TradeInput.kt$TradeInputField$bracketsTakeProfitReduceOnly : TradeInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TradeInput.kt$TradeInputField$execution : TradeInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TradeInput.kt$TradeInputField$goodTilDuration : TradeInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TradeInput.kt$TradeInputField$goodTilUnit : TradeInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TradeInput.kt$TradeInputField$leverage : TradeInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TradeInput.kt$TradeInputField$limitPrice : TradeInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TradeInput.kt$TradeInputField$marginMode : TradeInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TradeInput.kt$TradeInputField$postOnly : TradeInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TradeInput.kt$TradeInputField$reduceOnly : TradeInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TradeInput.kt$TradeInputField$side : TradeInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TradeInput.kt$TradeInputField$size : TradeInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TradeInput.kt$TradeInputField$targetLeverage : TradeInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TradeInput.kt$TradeInputField$timeInForceType : TradeInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TradeInput.kt$TradeInputField$trailingPercent : TradeInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TradeInput.kt$TradeInputField$triggerPrice : TradeInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TradeInput.kt$TradeInputField$type : TradeInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TradeInput.kt$TradeInputField$usdcSize : TradeInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TransferInput.kt$TransferInputField$address : TransferInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TransferInput.kt$TransferInputField$chain : TransferInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TransferInput.kt$TransferInputField$exchange : TransferInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TransferInput.kt$TransferInputField$fastSpeed : TransferInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TransferInput.kt$TransferInputField$size : TransferInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TransferInput.kt$TransferInputField$token : TransferInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TransferInput.kt$TransferInputField$type : TransferInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TransferInput.kt$TransferInputField$usdcFee : TransferInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TransferInput.kt$TransferInputField$usdcSize : TransferInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TriggerOrdersInput.kt$TriggerOrdersInputField$marketId : TriggerOrdersInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TriggerOrdersInput.kt$TriggerOrdersInputField$size : TriggerOrdersInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TriggerOrdersInput.kt$TriggerOrdersInputField$stopLossLimitPrice : TriggerOrdersInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TriggerOrdersInput.kt$TriggerOrdersInputField$stopLossOrderId : TriggerOrdersInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TriggerOrdersInput.kt$TriggerOrdersInputField$stopLossOrderSize : TriggerOrdersInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TriggerOrdersInput.kt$TriggerOrdersInputField$stopLossOrderType : TriggerOrdersInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TriggerOrdersInput.kt$TriggerOrdersInputField$stopLossPercentDiff : TriggerOrdersInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TriggerOrdersInput.kt$TriggerOrdersInputField$stopLossPrice : TriggerOrdersInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TriggerOrdersInput.kt$TriggerOrdersInputField$stopLossUsdcDiff : TriggerOrdersInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TriggerOrdersInput.kt$TriggerOrdersInputField$takeProfitLimitPrice : TriggerOrdersInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TriggerOrdersInput.kt$TriggerOrdersInputField$takeProfitOrderId : TriggerOrdersInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TriggerOrdersInput.kt$TriggerOrdersInputField$takeProfitOrderSize : TriggerOrdersInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TriggerOrdersInput.kt$TriggerOrdersInputField$takeProfitOrderType : TriggerOrdersInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TriggerOrdersInput.kt$TriggerOrdersInputField$takeProfitPercentDiff : TriggerOrdersInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TriggerOrdersInput.kt$TriggerOrdersInputField$takeProfitPrice : TriggerOrdersInputField</ID>
    <ID>EnumNaming:TradingStateMachine+TriggerOrdersInput.kt$TriggerOrdersInputField$takeProfitUsdcDiff : TriggerOrdersInputField</ID>
    <ID>EnumNaming:TransferInput.kt$TransferType$deposit : TransferType</ID>
    <ID>EnumNaming:TransferInput.kt$TransferType$transferOut : TransferType</ID>
    <ID>EnumNaming:TransferInput.kt$TransferType$withdrawal : TransferType</ID>
    <ID>EnumNaming:ValidationError.kt$ErrorType$error : ErrorType</ID>
    <ID>EnumNaming:ValidationError.kt$ErrorType$required : ErrorType</ID>
    <ID>EnumNaming:ValidationError.kt$ErrorType$warning : ErrorType</ID>
    <ID>ExplicitItLambdaParameter:AccountProcessor.kt$SubaccountProcessor${ it -&gt; val data = parser.asNativeMap(it) parser.asString(data?.get("status")) == "OPEN" }</ID>
    <ID>ExplicitItLambdaParameter:AccountSupervisor.kt$AccountSupervisor${ it -&gt; helper.send(error, it, hash) }</ID>
    <ID>ExplicitItLambdaParameter:AccountSupervisor.kt$AccountSupervisor${ it -&gt; helper.send(null, it, hash) }</ID>
    <ID>ExplicitItLambdaParameter:AsyncAbacusStateManager.kt$AsyncAbacusStateManager${ it -&gt; it.id == environment }</ID>
    <ID>ExplicitItLambdaParameter:AsyncAbacusStateManagerV2.kt$AsyncAbacusStateManagerV2${ it -&gt; it.id == environment }</ID>
    <ID>ExplicitItLambdaParameter:EquityTiersProcessor.kt$EquityTiersProcessor${ it -&gt; itemProcessor.received(null, it)?.let { received -&gt; modified["shortTermOrderEquityTiers"]?.add(received) } }</ID>
    <ID>ExplicitItLambdaParameter:EquityTiersProcessor.kt$EquityTiersProcessor${ it -&gt; itemProcessor.received(null, it)?.let { received -&gt; modified["statefulOrderEquityTiers"]?.add(received) } }</ID>
    <ID>ExplicitItLambdaParameter:FeeDiscountsProcessor.kt$FeeDiscountsProcessor${ it -&gt; itemProcessor.received(null, it)?.let { received -&gt; modified.add(received) } }</ID>
    <ID>ExplicitItLambdaParameter:FeeTiersProcessor.kt$FeeTiersProcessor${ it -&gt; itemProcessor.received(null, it)?.let { received -&gt; modified.add(received) } }</ID>
    <ID>ExplicitItLambdaParameter:LaunchIncentiveSeasonsProcessor.kt$LaunchIncentiveSeasonsProcessor${ it -&gt; itemProcessor.received(null, it)?.let { received -&gt; modified.add(received) } }</ID>
    <ID>ExplicitItLambdaParameter:LimiterCapacitiesProcessor.kt$LimiterCapacitiesProcessor${ it -&gt; itemProcessor.received(null, it)?.let { received -&gt; modified.add(received) } }</ID>
    <ID>ExplicitItLambdaParameter:MarketProcessor.kt$MarketProcessor${ it -&gt; candles = candlesProcessor.channel_data(candles, resolution, it) }</ID>
    <ID>ExplicitItLambdaParameter:MarketProcessor.kt$MarketProcessor${ it -&gt; trades = tradesProcessor.channel_data(trades, it) }</ID>
    <ID>ExplicitItLambdaParameter:SquidProcessor.kt$SquidProcessor${ it -&gt; for (chain in it) { parser.asNativeMap(chain)?.let { chain -&gt; if (parser.asString(chain.get("chainType")) != "cosmos") { options.add(chainProcessor.received(null, chain)) } } } }</ID>
    <ID>ExplicitItLambdaParameter:V4StateManagerAdaptor.kt$V4StateManagerAdaptor${ it -&gt; send(error, it, hash) }</ID>
    <ID>ExplicitItLambdaParameter:V4StateManagerAdaptor.kt$V4StateManagerAdaptor${ it -&gt; send(null, it, hash) }</ID>
    <ID>ForbiddenComment:Account.kt$SubaccountOrder.Companion$// TODO: Remove default to 0 for subaccountNumber once new indexer response is consumed. Prevents breaking change</ID>
    <ID>ForbiddenComment:TradeInputCalculator.kt$TradeInputCalculator$// TODO: When Child Subaccounts are added to Subaccount data class, return the child subaccount's leverage</ID>
    <ID>ForbiddenComment:TradeInputCalculator.kt$TradeInputCalculator$// TODO: When the collateral of child subaccounts is implemented, return from here. The below code is the CROSS implementation.</ID>
    <ID>ForbiddenComment:TradingStateMachine.kt$TradingStateMachine$// TODO: update price diffs based on price.input</ID>
    <ID>FunctionOnlyReturningConstant:MarketsSupervisor.kt$MarketsSupervisor$private fun shouldBatchMarketsChannelData(): Boolean</ID>
    <ID>FunctionOnlyReturningConstant:StateManagerAdaptorV2.kt$StateManagerAdaptorV2$private fun height(): BlockAndTime?</ID>
    <ID>FunctionOnlyReturningConstant:TradeAccountStateValidator.kt$TradeAccountStateValidator$private fun validateSubaccountOrders( parser: ParserProtocol, subaccount: Map&lt;String, Any&gt;, ): Map&lt;String, Any&gt;?</ID>
    <ID>FunctionOnlyReturningConstant:TradeMarketOrderInputValidator.kt$TradeMarketOrderInputValidator$private fun accountRestricted(): Boolean</ID>
    <ID>FunctionOnlyReturningConstant:TradingStateMachine+TriggerOrdersInput.kt$fun TradingStateMachine.validTriggerOrdersInput( triggerOrders: Map&lt;String, Any&gt;, typeText: String? ): Boolean</ID>
    <ID>FunctionOnlyReturningConstant:TradingStateMachine.kt$TradingStateMachine$private fun priceOverwrite(markets: Map&lt;String, Any&gt;): Map&lt;String, Any&gt;?</ID>
    <ID>FunctionOnlyReturningConstant:V4StateManagerConfigs.kt$V4StateManagerConfigs$fun nobleDenom(): String?</ID>
    <ID>FunctionParameterNaming:AsyncAbacusStateManager.kt$AsyncAbacusStateManager.Companion$_nativeImplementations: ProtocolNativeImpFactory</ID>
    <ID>FunctionParameterNaming:AsyncAbacusStateManagerV2.kt$AsyncAbacusStateManagerV2.Companion$_nativeImplementations: ProtocolNativeImpFactory</ID>
    <ID>LargeClass:OnboardingSupervisor.kt$OnboardingSupervisor : NetworkSupervisor</ID>
    <ID>LargeClass:StateManagerAdaptor.kt$StateManagerAdaptor</ID>
    <ID>LargeClass:SubaccountSupervisor.kt$SubaccountSupervisor : DynamicNetworkSupervisor</ID>
    <ID>LargeClass:TradeInputCalculator.kt$TradeInputCalculator</ID>
    <ID>LargeClass:TradingStateMachine.kt$TradingStateMachine</ID>
    <ID>LargeClass:V4StateManagerAdaptor.kt$V4StateManagerAdaptor : StateManagerAdaptor</ID>
    <ID>LongMethod:Account.kt$Subaccount.Companion$internal fun create( existing: Subaccount?, parser: ParserProtocol, data: Map&lt;*, *&gt;?, localizer: LocalizerProtocol?, ): Subaccount?</ID>
    <ID>LongMethod:Account.kt$SubaccountOrder.Companion$internal fun create( existing: SubaccountOrder?, parser: ParserProtocol, data: Map&lt;*, *&gt;?, localizer: LocalizerProtocol?, ): SubaccountOrder?</ID>
    <ID>LongMethod:Account.kt$SubaccountPosition.Companion$internal fun create( existing: SubaccountPosition?, parser: ParserProtocol, data: Map&lt;String, Any&gt;?, ): SubaccountPosition?</ID>
    <ID>LongMethod:NetworkHelper.kt$NetworkHelper$internal fun updateStateChanges( stateMachine: TradingStateMachine, changes: StateChanges?, oldState: PerpetualState?, )</ID>
    <ID>LongMethod:StateManagerAdaptor.kt$StateManagerAdaptor$private fun updateStateChanges( state: PerpetualState?, changes: StateChanges?, oldState: PerpetualState?, )</ID>
    <ID>LongMethod:SubaccountCalculator.kt$SubaccountCalculator$private fun calculatePositionValues( position: Map&lt;String, Any&gt;, market: Map&lt;String, Any&gt;?, subaccount: Map&lt;String, Any&gt;, price: Double?, periods: Set&lt;CalculationPeriod&gt;, ): MutableMap&lt;String, Any&gt;</ID>
    <ID>LongMethod:TradeInput.kt$TradeInputOptions.Companion$internal fun create( existing: TradeInputOptions?, parser: ParserProtocol, data: Map&lt;*, *&gt;?, ): TradeInputOptions?</ID>
    <ID>LongMethod:TradeInputCalculator.kt$TradeInputCalculator$private fun summaryForType( trade: Map&lt;String, Any&gt;, subaccount: Map&lt;String, Any&gt;?, user: Map&lt;String, Any&gt;?, market: Map&lt;String, Any&gt;?, rewardsParams: Map&lt;String, Any&gt;?, feeTiers: List&lt;Any&gt;?, type: String, ): Map&lt;String, Any&gt;</ID>
    <ID>LongMethod:TradingStateMachine+TradeInput.kt$fun TradingStateMachine.trade( data: String?, type: TradeInputField?, subaccountNumber: Int, ): StateResponse</ID>
    <ID>LongMethod:TradingStateMachine+TransferInput.kt$fun TradingStateMachine.transfer( data: String?, type: TransferInputField?, subaccountNumber: Int = 0 ): StateResponse</ID>
    <ID>LongMethod:TradingStateMachine+TriggerOrdersInput.kt$fun TradingStateMachine.triggerOrders( data: String?, type: TriggerOrdersInputField?, subaccountNumber: Int, ): StateResponse</ID>
    <ID>LongMethod:TradingStateMachine.kt$TradingStateMachine$@Throws(Exception::class) private fun socket( url: AbUrl, payload: Map&lt;String, Any&gt;, subaccountNumber: Int, height: BlockAndTime?, ): StateResponse</ID>
    <ID>LongMethod:TradingStateMachine.kt$TradingStateMachine$private fun update( state: PerpetualState?, changes: StateChanges, tokensInfo: Map&lt;String, TokenInfo&gt;, localizer: LocalizerProtocol?, ): PerpetualState</ID>
    <ID>LongMethod:TransferInput.kt$TransferInput.Companion$internal fun create( existing: TransferInput?, parser: ParserProtocol, data: Map&lt;*, *&gt;?, environment: V4Environment? ): TransferInput?</ID>
    <ID>LongMethod:TriggerOrdersInputCalculator.kt$TriggerOrdersInputCalculator$private fun calculateTriggerPrices( triggerPrices: Map&lt;String, Any&gt;, position: Map&lt;String, Any&gt;, size: Double?, ): MutableMap&lt;String, Any&gt;</ID>
    <ID>LoopWithTooManyJumpStatements:AccountCalculator.kt$AccountCalculator$for</ID>
    <ID>LoopWithTooManyJumpStatements:AsyncAbacusStateManager.kt$AsyncAbacusStateManager$for</ID>
    <ID>LoopWithTooManyJumpStatements:AsyncAbacusStateManagerV2.kt$AsyncAbacusStateManagerV2$for</ID>
    <ID>LoopWithTooManyJumpStatements:Enviroment.kt$V4Environment.Companion$for</ID>
    <ID>LoopWithTooManyJumpStatements:NotificationsProvider.kt$NotificationsProvider$for</ID>
    <ID>LoopWithTooManyJumpStatements:StateManagerAdaptor.kt$StateManagerAdaptor$for</ID>
    <ID>LoopWithTooManyJumpStatements:SubaccountSupervisor.kt$SubaccountSupervisor$for</ID>
    <ID>MagicNumber:AbacusHelper.kt$AbacusHelper.Companion$0.2</ID>
    <ID>MagicNumber:AbacusHelper.kt$AbacusHelper.Companion$0.4</ID>
    <ID>MagicNumber:AbacusHelper.kt$AbacusHelper.Companion$5</ID>
    <ID>MagicNumber:Account.kt$12</ID>
    <ID>MagicNumber:AccountSupervisor.kt$AccountSupervisor$10.0</ID>
    <ID>MagicNumber:AccountSupervisor.kt$AccountSupervisor$15.0</ID>
    <ID>MagicNumber:AccountSupervisor.kt$AccountSupervisor$5000</ID>
    <ID>MagicNumber:AccountSupervisor.kt$AccountSupervisor$60.0</ID>
    <ID>MagicNumber:AccountsSupervisor.kt$AccountsSupervisor$30</ID>
    <ID>MagicNumber:AccountsSupervisor.kt$AccountsSupervisor$7</ID>
    <ID>MagicNumber:AccountsSupervisor.kt$AccountsSupervisor$90</ID>
    <ID>MagicNumber:ApiUtils.kt$AbUrl$443</ID>
    <ID>MagicNumber:ApiUtils.kt$AbUrl$80</ID>
    <ID>MagicNumber:AsyncAbacusStateManager.kt$AsyncAbacusStateManager$200</ID>
    <ID>MagicNumber:AsyncAbacusStateManager.kt$AsyncAbacusStateManager$299</ID>
    <ID>MagicNumber:AsyncAbacusStateManagerV2.kt$AsyncAbacusStateManagerV2$200</ID>
    <ID>MagicNumber:AsyncAbacusStateManagerV2.kt$AsyncAbacusStateManagerV2$299</ID>
    <ID>MagicNumber:Bech32.kt$Bech32$0x07</ID>
    <ID>MagicNumber:Bech32.kt$Bech32$0x1ea119fa</ID>
    <ID>MagicNumber:Bech32.kt$Bech32$0x1ffffff</ID>
    <ID>MagicNumber:Bech32.kt$Bech32$0x26508e6d</ID>
    <ID>MagicNumber:Bech32.kt$Bech32$0x2a1462b3</ID>
    <ID>MagicNumber:Bech32.kt$Bech32$0x3b6a57b2</ID>
    <ID>MagicNumber:Bech32.kt$Bech32$0x3d4233dd</ID>
    <ID>MagicNumber:Bech32.kt$Bech32$0x7f</ID>
    <ID>MagicNumber:Bech32.kt$Bech32$0xff</ID>
    <ID>MagicNumber:Bech32.kt$Bech32$10</ID>
    <ID>MagicNumber:Bech32.kt$Bech32$11</ID>
    <ID>MagicNumber:Bech32.kt$Bech32$12</ID>
    <ID>MagicNumber:Bech32.kt$Bech32$126</ID>
    <ID>MagicNumber:Bech32.kt$Bech32$13</ID>
    <ID>MagicNumber:Bech32.kt$Bech32$14</ID>
    <ID>MagicNumber:Bech32.kt$Bech32$15</ID>
    <ID>MagicNumber:Bech32.kt$Bech32$16</ID>
    <ID>MagicNumber:Bech32.kt$Bech32$17</ID>
    <ID>MagicNumber:Bech32.kt$Bech32$18</ID>
    <ID>MagicNumber:Bech32.kt$Bech32$19</ID>
    <ID>MagicNumber:Bech32.kt$Bech32$20</ID>
    <ID>MagicNumber:Bech32.kt$Bech32$21</ID>
    <ID>MagicNumber:Bech32.kt$Bech32$22</ID>
    <ID>MagicNumber:Bech32.kt$Bech32$23</ID>
    <ID>MagicNumber:Bech32.kt$Bech32$24</ID>
    <ID>MagicNumber:Bech32.kt$Bech32$25</ID>
    <ID>MagicNumber:Bech32.kt$Bech32$26</ID>
    <ID>MagicNumber:Bech32.kt$Bech32$27</ID>
    <ID>MagicNumber:Bech32.kt$Bech32$28</ID>
    <ID>MagicNumber:Bech32.kt$Bech32$29</ID>
    <ID>MagicNumber:Bech32.kt$Bech32$3</ID>
    <ID>MagicNumber:Bech32.kt$Bech32$30</ID>
    <ID>MagicNumber:Bech32.kt$Bech32$31</ID>
    <ID>MagicNumber:Bech32.kt$Bech32$33</ID>
    <ID>MagicNumber:Bech32.kt$Bech32$4</ID>
    <ID>MagicNumber:Bech32.kt$Bech32$5</ID>
    <ID>MagicNumber:Bech32.kt$Bech32$6</ID>
    <ID>MagicNumber:Bech32.kt$Bech32$7</ID>
    <ID>MagicNumber:Bech32.kt$Bech32$8</ID>
    <ID>MagicNumber:Bech32.kt$Bech32$83</ID>
    <ID>MagicNumber:Bech32.kt$Bech32$9</ID>
    <ID>MagicNumber:Bech32.kt$Bech32$90</ID>
    <ID>MagicNumber:ConnectionStats.kt$ConnectionStats$1.5</ID>
    <ID>MagicNumber:ConnectionStats.kt$ConnectionStats$10.0</ID>
    <ID>MagicNumber:ConnectionStats.kt$ConnectionStats$15</ID>
    <ID>MagicNumber:ConnectionsSupervisor.kt$ConnectionsSupervisor$10.0</ID>
    <ID>MagicNumber:Double+Utils.kt$10</ID>
    <ID>MagicNumber:DynamicLocalizer.kt$DynamicLocalizer$200</ID>
    <ID>MagicNumber:DynamicLocalizer.kt$DynamicLocalizer$299</ID>
    <ID>MagicNumber:Enviroment.kt$V4Environment.Companion$18</ID>
    <ID>MagicNumber:Enviroment.kt$V4Environment.Companion$6</ID>
    <ID>MagicNumber:Formatter.kt$10</ID>
    <ID>MagicNumber:Formatter.kt$Formatter$10</ID>
    <ID>MagicNumber:Formatter.kt$Formatter$100</ID>
    <ID>MagicNumber:GoodTil.kt$GoodTil.Companion$7</ID>
    <ID>MagicNumber:InputValidator.kt$InputValidator$1000</ID>
    <ID>MagicNumber:InputValidator.kt$InputValidator$1001</ID>
    <ID>MagicNumber:InputValidator.kt$InputValidator$1002</ID>
    <ID>MagicNumber:InputValidator.kt$InputValidator$1010</ID>
    <ID>MagicNumber:InputValidator.kt$InputValidator$1020</ID>
    <ID>MagicNumber:InputValidator.kt$InputValidator$1021</ID>
    <ID>MagicNumber:InputValidator.kt$InputValidator$1022</ID>
    <ID>MagicNumber:InputValidator.kt$InputValidator$1030</ID>
    <ID>MagicNumber:InputValidator.kt$InputValidator$1031</ID>
    <ID>MagicNumber:InputValidator.kt$InputValidator$1032</ID>
    <ID>MagicNumber:InputValidator.kt$InputValidator$1033</ID>
    <ID>MagicNumber:InputValidator.kt$InputValidator$1034</ID>
    <ID>MagicNumber:InputValidator.kt$InputValidator$1040</ID>
    <ID>MagicNumber:InputValidator.kt$InputValidator$1041</ID>
    <ID>MagicNumber:InputValidator.kt$InputValidator$1042</ID>
    <ID>MagicNumber:InputValidator.kt$InputValidator$1043</ID>
    <ID>MagicNumber:InputValidator.kt$InputValidator$1044</ID>
    <ID>MagicNumber:InputValidator.kt$InputValidator$1051</ID>
    <ID>MagicNumber:InputValidator.kt$InputValidator$1052</ID>
    <ID>MagicNumber:InputValidator.kt$InputValidator$1053</ID>
    <ID>MagicNumber:InputValidator.kt$InputValidator$1060</ID>
    <ID>MagicNumber:InputValidator.kt$InputValidator$1061</ID>
    <ID>MagicNumber:InputValidator.kt$InputValidator$1070</ID>
    <ID>MagicNumber:InputValidator.kt$InputValidator$1071</ID>
    <ID>MagicNumber:InputValidator.kt$InputValidator$1080</ID>
    <ID>MagicNumber:InputValidator.kt$InputValidator$1081</ID>
    <ID>MagicNumber:InputValidator.kt$InputValidator$1082</ID>
    <ID>MagicNumber:InputValidator.kt$InputValidator$1083</ID>
    <ID>MagicNumber:InputValidator.kt$InputValidator$1090</ID>
    <ID>MagicNumber:InputValidator.kt$InputValidator$1091</ID>
    <ID>MagicNumber:InputValidator.kt$InputValidator$1092</ID>
    <ID>MagicNumber:InputValidator.kt$InputValidator$1093</ID>
    <ID>MagicNumber:InputValidator.kt$InputValidator$1100</ID>
    <ID>MagicNumber:InputValidator.kt$InputValidator$1200</ID>
    <ID>MagicNumber:InputValidator.kt$InputValidator$1201</ID>
    <ID>MagicNumber:InputValidator.kt$InputValidator$1202</ID>
    <ID>MagicNumber:InputValidator.kt$InputValidator$1203</ID>
    <ID>MagicNumber:InputValidator.kt$InputValidator$1204</ID>
    <ID>MagicNumber:LaunchIncentive.kt$LaunchIncentiveSeason.Companion$1000.0</ID>
    <ID>MagicNumber:MarketProcessor.kt$MarketProcessor$0.0001</ID>
    <ID>MagicNumber:MarketProcessor.kt$MarketProcessor$0.01</ID>
    <ID>MagicNumber:MarketProcessor.kt$MarketProcessor$15</ID>
    <ID>MagicNumber:MarketProcessor.kt$MarketProcessor$24</ID>
    <ID>MagicNumber:MarketProcessor.kt$MarketProcessor$30</ID>
    <ID>MagicNumber:MarketProcessor.kt$MarketProcessor$3600</ID>
    <ID>MagicNumber:MarketProcessor.kt$MarketProcessor$4</ID>
    <ID>MagicNumber:MarketProcessor.kt$MarketProcessor$5</ID>
    <ID>MagicNumber:MarketProcessor.kt$MarketProcessor$60</ID>
    <ID>MagicNumber:MarketSupervisor.kt$MarketSupervisor$365</ID>
    <ID>MagicNumber:MarketsSupervisor.kt$MarketsSupervisor$60.0</ID>
    <ID>MagicNumber:Network.kt$NetworkState$3</ID>
    <ID>MagicNumber:Network.kt$NetworkState$6</ID>
    <ID>MagicNumber:NetworkHelper.kt$NetworkHelper$200</ID>
    <ID>MagicNumber:NetworkHelper.kt$NetworkHelper$299</ID>
    <ID>MagicNumber:NetworkHelper.kt$NetworkHelper$403</ID>
    <ID>MagicNumber:NetworkHelper.kt$NetworkHelper$429</ID>
    <ID>MagicNumber:NetworkHelper.kt$NetworkHelper$5.0</ID>
    <ID>MagicNumber:NetworkHelper.kt$NetworkHelper$99</ID>
    <ID>MagicNumber:Notification.kt$NotificationPriority.URGENT$5</ID>
    <ID>MagicNumber:Numeric.kt$Decimals$10.0</ID>
    <ID>MagicNumber:Numeric.kt$Decimals$24</ID>
    <ID>MagicNumber:Numeric.kt$Doubles$10.0</ID>
    <ID>MagicNumber:OnboardingSupervisor.kt$OnboardingSupervisor$18</ID>
    <ID>MagicNumber:OnboardingSupervisor.kt$OnboardingSupervisor$6</ID>
    <ID>MagicNumber:Settings.kt$OrderbookGrouping.x10$10</ID>
    <ID>MagicNumber:Settings.kt$OrderbookGrouping.x100$100</ID>
    <ID>MagicNumber:Settings.kt$OrderbookGrouping.x1000$1000</ID>
    <ID>MagicNumber:SquidRouteProcessor.kt$SquidRouteProcessor$6</ID>
    <ID>MagicNumber:SquidRouteV2Processor.kt$SquidRouteV2Processor$6</ID>
    <ID>MagicNumber:StateManagerAdaptor.kt$StateManagerAdaptor$10.0</ID>
    <ID>MagicNumber:StateManagerAdaptor.kt$StateManagerAdaptor$127</ID>
    <ID>MagicNumber:StateManagerAdaptor.kt$StateManagerAdaptor$15.0</ID>
    <ID>MagicNumber:StateManagerAdaptor.kt$StateManagerAdaptor$200</ID>
    <ID>MagicNumber:StateManagerAdaptor.kt$StateManagerAdaptor$28.0</ID>
    <ID>MagicNumber:StateManagerAdaptor.kt$StateManagerAdaptor$299</ID>
    <ID>MagicNumber:StateManagerAdaptor.kt$StateManagerAdaptor$30</ID>
    <ID>MagicNumber:StateManagerAdaptor.kt$StateManagerAdaptor$365</ID>
    <ID>MagicNumber:StateManagerAdaptor.kt$StateManagerAdaptor$60.0</ID>
    <ID>MagicNumber:StateManagerAdaptor.kt$StateManagerAdaptor$7</ID>
    <ID>MagicNumber:StateManagerAdaptor.kt$StateManagerAdaptor$90</ID>
    <ID>MagicNumber:StateManagerAdaptor.kt$StateManagerAdaptor$99</ID>
    <ID>MagicNumber:StateManagerAdaptorV2.kt$StateManagerAdaptorV2$127</ID>
    <ID>MagicNumber:SubaccountCalculator.kt$SubaccountCalculator$0.05</ID>
    <ID>MagicNumber:SubaccountSupervisor.kt$SubaccountSupervisor$202</ID>
    <ID>MagicNumber:SubaccountSupervisor.kt$SubaccountSupervisor$28.0</ID>
    <ID>MagicNumber:TradeInputCalculator.kt$TradeInputCalculator$0.00001</ID>
    <ID>MagicNumber:TradeInputCalculator.kt$TradeInputCalculator$0.001</ID>
    <ID>MagicNumber:TradeInputCalculator.kt$TradeInputCalculator$28</ID>
    <ID>MagicNumber:TradeMarketOrderInputValidator.kt$TradeMarketOrderInputValidator$0.05</ID>
    <ID>MagicNumber:TradeMarketOrderInputValidator.kt$TradeMarketOrderInputValidator$0.1</ID>
    <ID>MagicNumber:TradesProcessor.kt$TradesProcessor$500</ID>
    <ID>MagicNumber:TransferInputCalculator.kt$TransferInputCalculator$100.0</ID>
    <ID>MagicNumber:TriggerOrdersInputCalculator.kt$TriggerOrdersInputCalculator$100</ID>
    <ID>MagicNumber:TriggerOrdersInputCalculator.kt$TriggerOrdersInputCalculator$100.0</ID>
    <ID>MagicNumber:V4StateManagerAdaptor.kt$V4StateManagerAdaptor$1.5</ID>
    <ID>MagicNumber:V4StateManagerAdaptor.kt$V4StateManagerAdaptor$10.0</ID>
    <ID>MagicNumber:V4StateManagerAdaptor.kt$V4StateManagerAdaptor$18</ID>
    <ID>MagicNumber:V4StateManagerAdaptor.kt$V4StateManagerAdaptor$202</ID>
    <ID>MagicNumber:V4StateManagerAdaptor.kt$V4StateManagerAdaptor$403</ID>
    <ID>MagicNumber:V4StateManagerAdaptor.kt$V4StateManagerAdaptor$429</ID>
    <ID>MagicNumber:V4StateManagerAdaptor.kt$V4StateManagerAdaptor$5.0</ID>
    <ID>MagicNumber:V4StateManagerAdaptor.kt$V4StateManagerAdaptor$5000</ID>
    <ID>MagicNumber:V4StateManagerAdaptor.kt$V4StateManagerAdaptor$6</ID>
    <ID>MagicNumber:V4StateManagerAdaptor.kt$V4StateManagerAdaptor$60.0</ID>
    <ID>MagicNumber:WithdrawalCapacityProcessor.kt$WithdrawalCapacityProcessor$6</ID>
    <ID>MagicNumber:WithdrawalGatingValidator.kt$WithdrawalGatingValidator$1.1</ID>
    <ID>MagicNumber:WithdrawalGatingValidator.kt$WithdrawalGatingValidator$1.5</ID>
    <ID>MatchingDeclarationName:TradingStateMachine+ClosePositionInput.kt$ClosePositionInputField</ID>
    <ID>MatchingDeclarationName:TradingStateMachine+TradeInput.kt$TradeInputField</ID>
    <ID>MatchingDeclarationName:TradingStateMachine+TransferInput.kt$TransferInputField</ID>
    <ID>MatchingDeclarationName:TradingStateMachine+TriggerOrdersInput.kt$TriggerOrdersInputField</ID>
    <ID>MaxLineLength:Account.kt$SubaccountFundingPayment.Companion$if</ID>
    <ID>MaxLineLength:Account.kt$SubaccountOrder.Companion$// TODO: Remove default to 0 for subaccountNumber once new indexer response is consumed. Prevents breaking change</ID>
    <ID>MaxLineLength:Account.kt$SubaccountOrder.Companion$if</ID>
    <ID>MaxLineLength:AsyncAbacusStateManager.kt$AsyncAbacusStateManager$override</ID>
    <ID>MaxLineLength:BaseProcessor.kt$BaseProcessor$}</ID>
    <ID>MaxLineLength:Configs.kt$WithdrawalCapacity.Companion$return if (existing?.capacity != capacityAsString) WithdrawalCapacity(capacityAsString) else existing</ID>
    <ID>MaxLineLength:Configs.kt$WithdrawalGating.Companion$return</ID>
    <ID>MaxLineLength:ConnectionsSupervisor.kt$ConnectionsSupervisor$latestBlockAndTime.block + (lapsedTime.inWholeMilliseconds / averageMillisecondsPerBlock).toInt()</ID>
    <ID>MaxLineLength:Enviroment.kt$EnvironmentGovernance.Companion$val newMarketsMethodology = EnvironmentGovernanceNewMarketProposal.parse(newMarketsMethodologyData, parser) ?: return null</ID>
    <ID>MaxLineLength:Enviroment.kt$V4Environment.Companion$val governance = EnvironmentGovernance.parse(governanceData ?: parser.asNativeMap(data["governance"]) ?: return null, parser)</ID>
    <ID>MaxLineLength:EquityTierProcessor.kt$EquityTierProcessor$received["requiredTotalNetCollateralUSD"] = parser.asDouble(requiredTotalNetCollateralUSD / QUANTUM_MULTIPLIER)!!</ID>
    <ID>MaxLineLength:Network.kt$ApiState$return status == ApiStatus.INDEXER_DOWN || status == ApiStatus.INDEXER_HALTED || status == ApiStatus.VALIDATOR_DOWN || status == ApiStatus.VALIDATOR_HALTED</ID>
    <ID>MaxLineLength:NotificationsProvider.kt$NotificationsProvider$/* Short term orders should get filled/partially filled immediately, so we don't need to handle OPENED notification And it doesn't have a timestamp */</ID>
    <ID>MaxLineLength:NotificationsProvider.kt$NotificationsProvider$OrderType.stopLimit</ID>
    <ID>MaxLineLength:OnboardingSupervisor.kt$OnboardingSupervisor$OnboardingConfigs.SquidVersion.V1</ID>
    <ID>MaxLineLength:OrderProcessor.kt$/* { "subaccountNumber: 0, // new field "id": "3c5193d7a49805ffcf231af1ed446188f04aaa6756bf9df7b5913568b2763d7", "clientId": "69967309621008383", "market": "ETH-USD", "accountId": "dace1648-c854-5aed-9879-88899bf647a3", "side": "BUY", "size": "0.1", "remainingSize": "0.1", "limitFee": "0.002", "price": "1500", "triggerPrice": null, "trailingPercent": null, "type": "LIMIT", "status": "OPEN", "signature": "06f422ea494514293c6da82b70aca83f30718a01beb942f3e877a3ce8411d8f700d227caf5a57357df3dd66b38e2faff07147f29db539696e7d4799f32063172", "timeInForce": "GTT", "postOnly": false, "cancelReason": null, "expiresAt": "2022-08-29T22:45:30.776Z", "unfillableAt": null, "updatedAt": "2022-08-01T22:25:31.139Z", "createdAt": "2022-08-01T22:25:31.111Z", "reduceOnly": false, "country": "JP", "client": "01", "reduceOnlySize": null } to { "subaccountNumber": 0, "id": "45537274a3ef9afca657d9de73fb5fe5762f97336ce5502da0581e394dccdeb", "marketId": "ETH-USD", "price": 1192.5, "triggerPrice": null, "trailingPercent": null, "size": 2, "remainingSize": 2, "createdAtMilliseconds": 80092349090234, "unfillableAtMilliseconds": null, "expiresAtMilliseconds": 80092349090234, "postOnly": false, "reduceOnly": false, "cancelReason": null, "resources": { "sideStringKey": "BUY", "typeStringKey": "LIMIT", "statusStringKey": "OPEN", "timeInForceStringKey": "GTT" } } */</ID>
    <ID>MaxLineLength:Rounder.kt$Rounder.Companion$fun</ID>
    <ID>MaxLineLength:SquidProcessor.kt$SquidProcessor$// Fallback to the first token's address from the filtered list if no CctpChainTokenInfo match is found</ID>
    <ID>MaxLineLength:StateManagerAdaptor.kt$StateManagerAdaptor$if</ID>
    <ID>MaxLineLength:StateManagerAdaptor.kt$StateManagerAdaptor$it.amount == transfer.amount &amp;&amp; it.timestampInMilliseconds &lt; transfer.updatedAtMilliseconds</ID>
    <ID>MaxLineLength:StateManagerAdaptor.kt$StateManagerAdaptor$private</ID>
    <ID>MaxLineLength:StateManagerAdaptor.kt$StateManagerAdaptor$val duration = GoodTil.duration(TradeInputGoodUntil(TRIGGER_ORDER_DEFAULT_DURATION_DAYS, "D")) ?: throw Exception("invalid duration")</ID>
    <ID>MaxLineLength:StateResponse.kt$StateResponse$val mergedChanges = this.changes?.merge(earlierResponse.changes ?: StateChanges(iListOf&lt;Changes&gt;())) ?: earlierResponse.changes</ID>
    <ID>MaxLineLength:StateResponse.kt$StateResponse$val mergedErrors = this.errors?.toSet()?.union(earlierResponse.errors?.toSet() ?: setOf())?.toIList() ?: earlierResponse.errors</ID>
    <ID>MaxLineLength:StringHelper.kt$StringHelper.Companion$beforeDecimal + afterDecimal + StringHelper.zeros(shift - afterDecimal.length)</ID>
    <ID>MaxLineLength:StringHelper.kt$StringHelper.Companion$string.substring(0, string.length - decimals.toInt()) + StringHelper.decimals(string.substring(string.length - decimals.toInt()))</ID>
    <ID>MaxLineLength:SubaccountCalculator.kt$SubaccountCalculator$if (positionEntryValue &gt; Numeric.double.ZERO) realizedPnl / positionEntryValue else null</ID>
    <ID>MaxLineLength:SubaccountCalculator.kt$SubaccountCalculator$if (size &gt; Numeric.double.ZERO) (size - size * maintenanceMarginFraction) else (size + size * maintenanceMarginFraction)</ID>
    <ID>MaxLineLength:SubaccountSupervisor.kt$SubaccountSupervisor$if (isCancel) AnalyticsEvent.TradeCancelOrderClick.rawValue else AnalyticsEvent.TradePlaceOrderClick.rawValue</ID>
    <ID>MaxLineLength:SubaccountSupervisor.kt$SubaccountSupervisor$if (isCancel) AnalyticsEvent.TradeCancelOrderSubmissionConfirmed.rawValue else AnalyticsEvent.TradePlaceOrderSubmissionConfirmed.rawValue</ID>
    <ID>MaxLineLength:SubaccountSupervisor.kt$SubaccountSupervisor$if (isCancel) AnalyticsEvent.TradeCancelOrderSubmissionFailed.rawValue else AnalyticsEvent.TradePlaceOrderSubmissionFailed.rawValue</ID>
    <ID>MaxLineLength:SubaccountSupervisor.kt$SubaccountSupervisor$if (isShortTermOrder(trade.type.rawValue, trade.timeInForce)) currentHeight?.plus(SHORT_TERM_ORDER_DURATION) else null</ID>
    <ID>MaxLineLength:SubaccountSupervisor.kt$SubaccountSupervisor$internal</ID>
    <ID>MaxLineLength:SubaccountSupervisor.kt$SubaccountSupervisor$it.amount == transfer.amount &amp;&amp; it.timestampInMilliseconds &lt; transfer.updatedAtMilliseconds</ID>
    <ID>MaxLineLength:SubaccountSupervisor.kt$SubaccountSupervisor$private</ID>
    <ID>MaxLineLength:SubaccountSupervisor.kt$SubaccountSupervisor$val duration = GoodTil.duration(TradeInputGoodUntil(TRIGGER_ORDER_DEFAULT_DURATION_DAYS, "D")) ?: throw Exception("invalid duration")</ID>
    <ID>MaxLineLength:SystemSupervisor.kt$SystemSupervisor$"{\"operationName\":\"TradingSeasons\",\"variables\":{},\"query\":\"query TradingSeasons {tradingSeasons {startTimestamp label __typename }}\"}"</ID>
    <ID>MaxLineLength:TradeInputCalculator.kt$TradeInputCalculator$/* leverage = (size * oracle_price) / account_equity leverage and size are signed new_account_equity = old_account_equity + order_size * (oracle_price - market_price) - abs(order_size) * market_price * fee rate order_size is signed (old_size + order_size) * oracle_price = leverage * (old_account_equity + order_size * (oracle_price - market_price) - abs(order_size) * market_price * fee_rate) X = order_size SZ = old_size OR = oracle_price AE = account_equity MP = market price FR = fee rate LV = leverage PS = positionSign LONG ? 1 : -1 OS = orderSign BUY ? 1 : -1 (SZ + X) * OR = LV * (AE + X * (OR - MP) - OS * X * MP * FR) SZ * OR + OR * X = LV * AE + LV * X * (OR - MP) - OS * LV * MP * FR * X OR * X + OS * LV * MP * FR * X - LV * X * (OR - MP) = LV * AE - SZ * OR X = (LV * AE - SZ * OR) / (OR + OS * LV * MP * FR - LV * (OR - MP)) X = (LV * AE - SZ * OR) / (OR + OS * LV * MP * FR - LV * (OR - MP)) new(AE) = AE + X * (OR - MP) - abs(X) * MP * FR */</ID>
    <ID>MaxLineLength:TradeInputCalculator.kt$TradeInputCalculator$// TODO: When the collateral of child subaccounts is implemented, return from here. The below code is the CROSS implementation.</ID>
    <ID>MaxLineLength:TradeInputCalculator.kt$TradeInputCalculator$if</ID>
    <ID>MaxLineLength:TradeInputDataValidator.kt$TradeInputDataValidator$(status == "OPEN" || status == "PENDING" || status == "UNTRIGGERED" || status == "PARTIALLY_FILLED")</ID>
    <ID>MaxLineLength:TradingStateMachine+HistoricalPnl.kt$internal</ID>
    <ID>MaxLineLength:TradingStateMachine+HistoricalTradingRewards.kt$internal</ID>
    <ID>MaxLineLength:TradingStateMachine+ParentSubaccount.kt$val groupedFills = parser.asNativeList(parser.value(account, "groupedSubaccounts.$parentSubaccountNumber.fills"))</ID>
    <ID>MaxLineLength:TradingStateMachine+ParentSubaccount.kt$val groupedTransfers = parser.asNativeList(parser.value(account, "groupedSubaccounts.$parentSubaccountNumber.transfers"))</ID>
    <ID>MaxLineLength:TradingStateMachine+TransferInput.kt$changes = StateChanges(iListOf(Changes.wallet, Changes.subaccount, Changes.input), null, iListOf(subaccountNumber))</ID>
    <ID>MaxLineLength:TransferStatus.kt$TransferStatus.Companion$TransferStatus(status, gasStatus, axelarTransactionUrl, fromChainStatus, toChainStatus, routeStatuses, error, squidTransactionStatus)</ID>
    <ID>MaxLineLength:TriggerOrdersInputCalculator.kt$TriggerOrdersInputCalculator$"long" -&gt; entryPrice.minus(percentDiff.times(scaledNotionalTotal).div(leverage.times(size)))</ID>
    <ID>MaxLineLength:TriggerOrdersInputCalculator.kt$TriggerOrdersInputCalculator$"long" -&gt; entryPrice.plus(percentDiff.times(scaledNotionalTotal).div(leverage.times(size)))</ID>
    <ID>MaxLineLength:TriggerOrdersInputCalculator.kt$TriggerOrdersInputCalculator$"long" -&gt; size.times(leverage.times(entryPrice.minus(triggerPrice))).div(scaledNotionalTotal).times(100)</ID>
    <ID>MaxLineLength:TriggerOrdersInputCalculator.kt$TriggerOrdersInputCalculator$"long" -&gt; size.times(leverage.times(triggerPrice.minus(entryPrice))).div(scaledNotionalTotal).times(100)</ID>
    <ID>MaxLineLength:TriggerOrdersInputCalculator.kt$TriggerOrdersInputCalculator$"short" -&gt; entryPrice.minus(percentDiff.times(scaledNotionalTotal).div(leverage.times(size)))</ID>
    <ID>MaxLineLength:TriggerOrdersInputCalculator.kt$TriggerOrdersInputCalculator$"short" -&gt; entryPrice.plus(percentDiff.times(scaledNotionalTotal).div(leverage.times(size)))</ID>
    <ID>MaxLineLength:TriggerOrdersInputCalculator.kt$TriggerOrdersInputCalculator$"short" -&gt; size.times(leverage.times(entryPrice.minus(triggerPrice))).div(scaledNotionalTotal).times(100)</ID>
    <ID>MaxLineLength:TriggerOrdersInputCalculator.kt$TriggerOrdersInputCalculator$"short" -&gt; size.times(leverage.times(triggerPrice.minus(entryPrice))).div(scaledNotionalTotal).times(100)</ID>
    <ID>MaxLineLength:TriggerOrdersInputCalculator.kt$TriggerOrdersInputCalculator$if</ID>
    <ID>MaxLineLength:TriggerOrdersInputCalculator.kt$TriggerOrdersInputCalculator$private</ID>
    <ID>MaxLineLength:TriggerOrdersInputCalculator.kt$TriggerOrdersInputCalculator$val triggerPrices = parser.asNativeMap(triggerOrder["price"])?.let { calculateTriggerPrices(it, position, absSize) }</ID>
    <ID>MaxLineLength:TriggerOrdersInputValidator.kt$TriggerOrdersInputValidator$if</ID>
    <ID>MaxLineLength:TriggerOrdersInputValidator.kt$TriggerOrdersInputValidator$}</ID>
    <ID>MaxLineLength:V4StateManagerAdaptor.kt$V4StateManagerAdaptor$"{\"operationName\":\"TradingSeasons\",\"variables\":{},\"query\":\"query TradingSeasons {tradingSeasons {startTimestamp label __typename }}\"}"</ID>
    <ID>MaxLineLength:V4StateManagerAdaptor.kt$V4StateManagerAdaptor$if (isCancel) AnalyticsEvent.TradeCancelOrderClick.rawValue else AnalyticsEvent.TradePlaceOrderClick.rawValue</ID>
    <ID>MaxLineLength:V4StateManagerAdaptor.kt$V4StateManagerAdaptor$if (isCancel) AnalyticsEvent.TradeCancelOrderSubmissionConfirmed.rawValue else AnalyticsEvent.TradePlaceOrderSubmissionConfirmed.rawValue</ID>
    <ID>MaxLineLength:V4StateManagerAdaptor.kt$V4StateManagerAdaptor$if (isCancel) AnalyticsEvent.TradeCancelOrderSubmissionFailed.rawValue else AnalyticsEvent.TradePlaceOrderSubmissionFailed.rawValue</ID>
    <ID>MaxLineLength:V4StateManagerAdaptor.kt$V4StateManagerAdaptor$latestBlockAndTime.block + (lapsedTime.inWholeMilliseconds / averageMillisecondsPerBlock).toInt()</ID>
    <ID>MaxLineLength:WithdrawalCapacityValidator.kt$WithdrawalCapacityValidator$val maxWithdrawalCapacity = parser.asDecimal(parser.value(withdrawalCapacity, "maxWithdrawalCapacity")) ?: BigDecimal.fromLong(Long.MAX_VALUE)</ID>
    <ID>MaxLineLength:WithdrawalGatingValidator.kt$WithdrawalGatingValidator$"WARNINGS.ACCOUNT_FUND_MANAGEMENT.${if (type == TransferType.withdrawal.rawValue) "WITHDRAWAL_PAUSED_ACTION" else "TRANSFERS_PAUSED_ACTION"}"</ID>
    <ID>MaxLineLength:WithdrawalGatingValidator.kt$WithdrawalGatingValidator$"WARNINGS.ACCOUNT_FUND_MANAGEMENT.${if (type == TransferType.withdrawal.rawValue) "WITHDRAWAL_PAUSED_DESCRIPTION" else "TRANSFERS_PAUSED_DESCRIPTION"}"</ID>
    <ID>MaxLineLength:WithdrawalGatingValidator.kt$WithdrawalGatingValidator$"WARNINGS.ACCOUNT_FUND_MANAGEMENT.${if (type == TransferType.withdrawal.rawValue) "WITHDRAWAL_PAUSED_TITLE" else "TRANSFERS_PAUSED_TITLE"}"</ID>
    <ID>MaxLineLength:WithdrawalGatingValidator.kt$WithdrawalGatingValidator$val currentBlock = currentBlockAndHeight?.block ?: Int.MAX_VALUE // parser.asInt(parser.value(environment, "currentBlock"))</ID>
    <ID>MaxLineLength:WithdrawalGatingValidator.kt$WithdrawalGatingValidator$val secondsUntilUnblock = ((withdrawalsAndTransfersUnblockedAtBlock - currentBlock) * blockDurationSeconds).toInt()</ID>
    <ID>MaxLineLength:WithdrawalGatingValidator.kt$WithdrawalGatingValidator$val withdrawalsAndTransfersUnblockedAtBlock = parser.asInt(withdrawalGating?.get("withdrawalsAndTransfersUnblockedAtBlock")) ?: 0</ID>
    <ID>MemberNameEqualsClassName:Market.kt$PerpetualMarketSummary.Companion$private fun perpetualMarketSummary( existing: PerpetualMarketSummary?, parser: ParserProtocol, data: Map&lt;String, Any&gt;, newMarkets: IMutableMap&lt;String, PerpetualMarket&gt;, ): PerpetualMarketSummary?</ID>
    <ID>NestedBlockDepth:Account.kt$Account.Companion$internal fun create( existing: Account?, parser: ParserProtocol, data: Map&lt;String, Any&gt;, tokensInfo: Map&lt;String, TokenInfo&gt;, localizer: LocalizerProtocol?, ): Account</ID>
    <ID>NestedBlockDepth:Account.kt$SubaccountOrderResources.Companion$internal fun create( existing: SubaccountOrderResources?, parser: ParserProtocol, data: Map&lt;*, *&gt;?, localizer: LocalizerProtocol?, ): SubaccountOrderResources?</ID>
    <ID>NestedBlockDepth:Account.kt$TradingRewards.Companion$private fun createHistoricalTradingRewardsPerPeriod( objs: IList&lt;HistoricalTradingReward&gt;?, data: List&lt;Any&gt;?, parser: ParserProtocol, period: String, ): IList&lt;HistoricalTradingReward&gt;</ID>
    <ID>NestedBlockDepth:AccountCalculator.kt$AccountCalculator$private fun groupSubaccounts( existing: Map&lt;String, Any&gt;, markets: Map&lt;String, Any&gt;? ): MutableMap&lt;String, Any&gt;</ID>
    <ID>NestedBlockDepth:AccountProcessor.kt$SubaccountProcessor$private fun modify( positions: Map&lt;String, Any&gt;?, orders: List&lt;*&gt;?, state: String, ): Map&lt;String, Any&gt;</ID>
    <ID>NestedBlockDepth:AccountProcessor.kt$V4AccountBalancesProcessor$fun receivedBalances( existing: Map&lt;String, Any&gt;?, payload: List&lt;Any&gt;?, ): Map&lt;String, Any&gt;?</ID>
    <ID>NestedBlockDepth:AccountProcessor.kt$V4AccountDelegationsProcessor$fun received( existing: Map&lt;String, Any&gt;?, payload: List&lt;Any&gt;?, ): Map&lt;String, Any&gt;?</ID>
    <ID>NestedBlockDepth:AccountProcessor.kt$V4AccountProcessor$private fun subscribedParentSubaccount( existing: Map&lt;String, Any&gt;, content: Map&lt;String, Any&gt;, height: BlockAndTime?, ): Map&lt;String, Any&gt;</ID>
    <ID>NestedBlockDepth:AccountProcessor.kt$V4SubaccountsProcessor$internal fun receivedSubaccounts( existing: Map&lt;String, Any&gt;?, payload: List&lt;Any&gt;?, ): Map&lt;String, Any&gt;?</ID>
    <ID>NestedBlockDepth:AssetPositionsProcessor.kt$AssetPositionsProcessor$internal fun receivedChanges( existing: Map&lt;String, Any&gt;?, payload: List&lt;Any&gt;? ): Map&lt;String, Any&gt;?</ID>
    <ID>NestedBlockDepth:BaseInputValidator.kt$BaseInputValidator$private fun localize(stringKey: String?, params: Map&lt;String, Any&gt;? = null): String?</ID>
    <ID>NestedBlockDepth:BaseProcessor.kt$BaseProcessor$internal fun transform( existing: Map&lt;String, Any&gt;?, input: Map&lt;*, *&gt;?, keymap: Map&lt;String, Map&lt;String, String&gt;&gt; ): MutableMap&lt;String, Any&gt;</ID>
    <ID>NestedBlockDepth:Configs.kt$FeeDiscount.Companion$internal fun create( existing: IList&lt;FeeDiscount&gt;?, parser: ParserProtocol, data: List&lt;*&gt;?, localizer: LocalizerProtocol?, ): IList&lt;FeeDiscount&gt;?</ID>
    <ID>NestedBlockDepth:Configs.kt$FeeTier.Companion$internal fun create( existing: IList&lt;FeeTier&gt;?, parser: ParserProtocol, data: List&lt;*&gt;?, localizer: LocalizerProtocol?, ): IList&lt;FeeTier&gt;?</ID>
    <ID>NestedBlockDepth:Configs.kt$WithdrawalCapacity.Companion$internal fun create( existing: WithdrawalCapacity?, parser: ParserProtocol, data: Map&lt;*, *&gt;? ): WithdrawalCapacity?</ID>
    <ID>NestedBlockDepth:ConnectionStats.kt$ConnectionStats$private fun apiState( apiState: ApiState?, indexerState: NetworkState, validatorState: NetworkState, ): ApiState</ID>
    <ID>NestedBlockDepth:ConnectionsSupervisor.kt$ConnectionsSupervisor$internal fun calculateCurrentHeight(): Int?</ID>
    <ID>NestedBlockDepth:DynamicLocalizer.kt$DynamicLocalizer$override fun setLanguage( language: String, callback: (successful: Boolean, error: ParsingError?) -&gt; Unit, )</ID>
    <ID>NestedBlockDepth:DynamicLocalizer.kt$DynamicLocalizer$private fun localize( path: String, params: Map&lt;String, Any&gt;?, data: Map&lt;String, Any&gt;, ): String?</ID>
    <ID>NestedBlockDepth:Enviroment.kt$V4Environment.Companion$private fun parseTokens( item: Map&lt;String, Any&gt;?, parser: ParserProtocol, deploymentUri: String, ): IMap&lt;String, TokenInfo&gt;</ID>
    <ID>NestedBlockDepth:EquityTiersProcessor.kt$EquityTiersProcessor$internal fun received( payload: Map&lt;String, Map&lt;String, List&lt;Any&gt;&gt;&gt;? ): Map&lt;String, Any&gt;?</ID>
    <ID>NestedBlockDepth:FieldsInputValidator.kt$FieldsInputValidator$override fun validate( wallet: Map&lt;String, Any&gt;?, user: Map&lt;String, Any&gt;?, subaccount: Map&lt;String, Any&gt;?, markets: Map&lt;String, Any&gt;?, configs: Map&lt;String, Any&gt;?, currentBlockAndHeight: BlockAndTime?, transaction: Map&lt;String, Any&gt;, transactionType: String, environment: V4Environment?, ): List&lt;Any&gt;?</ID>
    <ID>NestedBlockDepth:Market.kt$CandleOption.Companion$fun create( existing: IList&lt;CandleOption&gt;?, parser: ParserProtocol, data: List&lt;Map&lt;String, Any&gt;&gt;? ): IList&lt;CandleOption&gt;?</ID>
    <ID>NestedBlockDepth:Market.kt$MarketCandle.Companion$internal fun create( existing: MarketCandle?, parser: ParserProtocol, data: Map&lt;*, *&gt;?, ): MarketCandle?</ID>
    <ID>NestedBlockDepth:MarketProcessor.kt$MarketProcessor$internal fun receivedCandles( market: Map&lt;String, Any&gt;, payload: List&lt;Any&gt;, ): Map&lt;String, Any&gt;</ID>
    <ID>NestedBlockDepth:MarketProcessor.kt$MarketProcessor$private fun line(market: Map&lt;String, Any&gt;): List&lt;Double&gt;?</ID>
    <ID>NestedBlockDepth:MarketsProcessor.kt$MarketsProcessor$internal fun receivedCandles( existing: Map&lt;String, Any&gt;?, payload: Map&lt;String, Any&gt; ): Map&lt;String, Any&gt;?</ID>
    <ID>NestedBlockDepth:MarketsProcessor.kt$MarketsProcessor$internal fun receivedSparklines( existing: Map&lt;String, Any&gt;?, payload: Map&lt;String, Any&gt; ): Map&lt;String, Any&gt;</ID>
    <ID>NestedBlockDepth:NetworkHelper.kt$NetworkHelper$internal fun retrieveTimed( url: String, items: List&lt;Any&gt;?, timeField: String, sampleDuration: Duration, maxDuration: Duration, beforeParam: String, afterParam: String? = null, additionalParams: Map&lt;String, String&gt;? = null, previousUrl: String?, callback: RestCallbackWithUrl, )</ID>
    <ID>NestedBlockDepth:NetworkHelper.kt$NetworkHelper$internal fun updateStateChanges( stateMachine: TradingStateMachine, changes: StateChanges?, oldState: PerpetualState?, )</ID>
    <ID>NestedBlockDepth:NotificationsProvider.kt$NotificationsProvider$private fun buildFillsNotifications( stateMachine: TradingStateMachine, subaccountNumber: Int ): Map&lt;String, Notification&gt;</ID>
    <ID>NestedBlockDepth:OnboardingSupervisor.kt$OnboardingSupervisor$private fun didUpdateStateForTransfer( data: String?, type: TransferInputField?, accountAddress: String, sourceAddress: String, subaccountNumber: Int? )</ID>
    <ID>NestedBlockDepth:OrderProcessor.kt$OrderProcessor$override fun received( existing: Map&lt;String, Any&gt;?, payload: Map&lt;String, Any&gt;, height: BlockAndTime?, ): Map&lt;String, Any&gt;?</ID>
    <ID>NestedBlockDepth:OrderbookProcessor.kt$OrderbookProcessor$fun consolidate(orderbook: Map&lt;String, Any&gt;?, stepSize: Double): Map&lt;String, Any&gt;?</ID>
    <ID>NestedBlockDepth:OrderbookProcessor.kt$OrderbookProcessor$fun group(orderbook: List&lt;Any&gt;?, grouping: Double): List&lt;Any&gt;?</ID>
    <ID>NestedBlockDepth:OrderbookProcessor.kt$OrderbookProcessor$private fun receiveChangeBinary( existing: List&lt;Map&lt;String, Any&gt;&gt;, change: Any, offset: Long?, comparator: Comparator&lt;Map&lt;String, Any&gt;&gt; ): MutableList&lt;Map&lt;String, Any&gt;&gt;</ID>
    <ID>NestedBlockDepth:OrderbookProcessor.kt$OrderbookProcessor$private fun receivedChangesLinear( existing: List&lt;Map&lt;String, Any&gt;&gt;?, changes: List&lt;Any&gt;, offset: Long?, ascending: Boolean ): List&lt;Map&lt;String, Any&gt;&gt;</ID>
    <ID>NestedBlockDepth:OrdersProcessor.kt$OrdersProcessor$internal fun received( existing: Map&lt;String, Any&gt;?, payload: List&lt;Any&gt;?, height: BlockAndTime? ): Map&lt;String, Any&gt;?</ID>
    <ID>NestedBlockDepth:Parser.kt$Parser$private fun value(data: Any?, path: IMutableList&lt;String&gt;): Any?</ID>
    <ID>NestedBlockDepth:ParsingHelper.kt$ParsingHelper.Companion$internal fun &lt;T : Any&gt; merge( parser: ParserProtocol, existing: List&lt;T&gt;?, data: List&lt;*&gt;?, comparison: ObjectAndDataComparisonBlock, createObject: ObjectCreationBlock, syncItems: Boolean = false, includesObjectBlock: IncludesObjectBlock? = null, includesDataBlock: IncludesDataBlock? = null, ): List&lt;T&gt;?</ID>
    <ID>NestedBlockDepth:ParsingHelper.kt$ParsingHelper.Companion$internal fun compare( value1: Instant?, value2: Instant?, ascending: Boolean, ): ComparisonOrder</ID>
    <ID>NestedBlockDepth:ParsingHelper.kt$ParsingHelper.Companion$internal inline fun &lt;reified T : Any&gt; transform( parser: ParserProtocol, existing: List&lt;T&gt;?, data: Map&lt;*, *&gt;?, key: ObjectKeyBlock, changed: ObjectAndDataChangedBlock, crossinline comparison: ObjectComparisonBlock, createObject: ObjectCreationBlock, ): List&lt;T&gt;?</ID>
    <ID>NestedBlockDepth:ParsingHelper.kt$ParsingHelper.Companion$private fun mergeMap( existing: Map&lt;String, Any&gt;?, incoming: Map&lt;String, Any&gt;?, ): Map&lt;String, Any&gt;?</ID>
    <ID>NestedBlockDepth:PerpetualPositionsProcessor.kt$PerpetualPositionsProcessor$internal fun receivedChanges( existing: Map&lt;String, Any&gt;?, payload: List&lt;Any&gt;?, ): Map&lt;String, Any&gt;?</ID>
    <ID>NestedBlockDepth:SquidProcessor.kt$SquidProcessor$internal fun tokenOptions(chainId: String?): List&lt;Any&gt;</ID>
    <ID>NestedBlockDepth:SquidProcessor.kt$SquidProcessor$private fun chainOptions(): List&lt;Any&gt;</ID>
    <ID>NestedBlockDepth:SquidProcessor.kt$SquidProcessor$private fun filteredTokens(chainId: String?): List&lt;Any&gt;?</ID>
    <ID>NestedBlockDepth:StateManagerAdaptor.kt$StateManagerAdaptor$internal fun retrieveTimed( url: String, items: List&lt;Any&gt;?, timeField: String, sampleDuration: Duration, maxDuration: Duration, beforeParam: String, afterParam: String? = null, additionalParams: Map&lt;String, String&gt;? = null, previousUrl: String?, callback: (url: String, response: String?, httpCode: Int, headers: Map&lt;String, Any&gt;?) -&gt; Unit, )</ID>
    <ID>NestedBlockDepth:StateManagerAdaptor.kt$StateManagerAdaptor$internal open fun didSetSubaccount(subaccount: Subaccount?, oldValue: Subaccount?)</ID>
    <ID>NestedBlockDepth:StateManagerAdaptor.kt$StateManagerAdaptor$private fun parseTransfersToMatchFaucetRecords()</ID>
    <ID>NestedBlockDepth:StateManagerAdaptor.kt$StateManagerAdaptor$private fun updateStateChanges( state: PerpetualState?, changes: StateChanges?, oldState: PerpetualState?, )</ID>
    <ID>NestedBlockDepth:SubaccountCalculator.kt$SubaccountCalculator$private fun calculatePositionLiquidationPrice( equity: Double, market: String, positions: Map&lt;String, MutableMap&lt;String, Any&gt;&gt;?, markets: Map&lt;String, Any&gt;?, period: CalculationPeriod, ): Double?</ID>
    <ID>NestedBlockDepth:SubaccountCalculator.kt$SubaccountCalculator$private fun calculatePositionRisk( position: Map&lt;String, Any&gt;, market: Map&lt;String, Any&gt;?, period: CalculationPeriod, ): Double</ID>
    <ID>NestedBlockDepth:SubaccountCalculator.kt$SubaccountCalculator$private fun calculatePositionValues( position: Map&lt;String, Any&gt;, market: Map&lt;String, Any&gt;?, subaccount: Map&lt;String, Any&gt;, price: Double?, periods: Set&lt;CalculationPeriod&gt;, ): MutableMap&lt;String, Any&gt;</ID>
    <ID>NestedBlockDepth:SubaccountCalculator.kt$SubaccountCalculator$private fun calculatePositionsValues( positions: Map&lt;String, Any&gt;?, markets: Map&lt;String, Any&gt;?, subaccount: Map&lt;String, Any&gt;, price: Map&lt;String, Any&gt;?, periods: Set&lt;CalculationPeriod&gt;, ): MutableMap&lt;String, MutableMap&lt;String, Any&gt;&gt;?</ID>
    <ID>NestedBlockDepth:SubaccountCalculator.kt$SubaccountCalculator$private fun calculateSubaccountEquity( subaccount: MutableMap&lt;String, Any&gt;, positions: Map&lt;String, Map&lt;String, Any&gt;&gt;?, periods: Set&lt;CalculationPeriod&gt;, )</ID>
    <ID>NestedBlockDepth:SubaccountSupervisor.kt$SubaccountSupervisor$private fun parseTransfersToMatchFaucetRecords()</ID>
    <ID>NestedBlockDepth:SubaccountTransformer.kt$SubaccountTransformer$private fun deltaFromTrade( parser: ParserProtocol, trade: Map&lt;String, Any&gt;, market: Map&lt;String, Any&gt;?, usePessimisticCollateralCheck: Boolean, useOptimisticCollateralCheck: Boolean, ): Map&lt;String, Any&gt;?</ID>
    <ID>NestedBlockDepth:SubaccountTransformer.kt$SubaccountTransformer$private fun executionPrice( oraclePrice: Double?, limitPrice: Double?, isBuying: Boolean, usePessimisticPrice: Boolean, useOptimisticPrice: Boolean, ): Double?</ID>
    <ID>NestedBlockDepth:TradeAccountStateValidator.kt$TradeAccountStateValidator$private fun validateSubaccountPostOrders( parser: ParserProtocol, subaccount: Map&lt;String, Any&gt;, trade: Map&lt;String, Any&gt;, change: PositionChange, ): Map&lt;String, Any&gt;?</ID>
    <ID>NestedBlockDepth:TradeInput.kt$SelectionOption.Companion$internal fun create( existing: SelectionOption?, parser: ParserProtocol, data: Map&lt;*, *&gt;?, ): SelectionOption?</ID>
    <ID>NestedBlockDepth:TradeInput.kt$TradeInputMarketOrder.Companion$internal fun create( existing: TradeInputMarketOrder?, parser: ParserProtocol, data: Map&lt;*, *&gt;?, ): TradeInputMarketOrder?</ID>
    <ID>NestedBlockDepth:TradeInput.kt$TradeInputOptions.Companion$internal fun create( existing: TradeInputOptions?, parser: ParserProtocol, data: Map&lt;*, *&gt;?, ): TradeInputOptions?</ID>
    <ID>NestedBlockDepth:TradeInputCalculator.kt$TradeInputCalculator$private fun calculateMarketOrderFromLeverage( equity: Double, oraclePrice: Double, positionSize: Double?, isBuying: Boolean, feeRate: Double, leverage: Double, stepSize: Double, orderbook: List&lt;Map&lt;String, Any&gt;&gt;, ): Map&lt;String, Any&gt;?</ID>
    <ID>NestedBlockDepth:TradeInputCalculator.kt$TradeInputCalculator$private fun calculateMarketOrderFromSize( size: Double?, orderbook: List&lt;Map&lt;String, Any&gt;&gt;?, ): Map&lt;String, Any&gt;?</ID>
    <ID>NestedBlockDepth:TradeInputCalculator.kt$TradeInputCalculator$private fun calculateMarketOrderFromUsdcSize( usdcSize: Double?, orderbook: List&lt;Map&lt;String, Any&gt;&gt;?, stepSize: Double, ): Map&lt;String, Any&gt;?</ID>
    <ID>NestedBlockDepth:TradeInputCalculator.kt$TradeInputCalculator$private fun calculatePositionMargin( trade: Map&lt;String, Any&gt;, subaccount: Map&lt;String, Any&gt;?, market: Map&lt;String, Any&gt;? ): Double?</ID>
    <ID>NestedBlockDepth:TradeInputCalculator.kt$TradeInputCalculator$private fun calculatedOptionsFromFields( fields: List&lt;Any&gt;?, trade: Map&lt;String, Any&gt;, position: Map&lt;String, Any&gt;?, market: Map&lt;String, Any&gt;?, ): Map&lt;String, Any&gt;?</ID>
    <ID>NestedBlockDepth:TradeInputCalculator.kt$TradeInputCalculator$private fun found(data: String?, options: List&lt;Any&gt;): Boolean</ID>
    <ID>NestedBlockDepth:TradeInputCalculator.kt$TradeInputCalculator$private fun marketOrderBestPrice(marketOrder: Map&lt;String, Any&gt;): Double?</ID>
    <ID>NestedBlockDepth:TradeInputCalculator.kt$TradeInputCalculator$private fun nonMarketOrderPrice( prices: Map&lt;String, Any&gt;?, market: Map&lt;String, Any&gt;?, type: String, isBuying: Boolean, ): Double?</ID>
    <ID>NestedBlockDepth:TradeInputCalculator.kt$TradeInputCalculator$private fun summaryForType( trade: Map&lt;String, Any&gt;, subaccount: Map&lt;String, Any&gt;?, user: Map&lt;String, Any&gt;?, market: Map&lt;String, Any&gt;?, rewardsParams: Map&lt;String, Any&gt;?, feeTiers: List&lt;Any&gt;?, type: String, ): Map&lt;String, Any&gt;</ID>
    <ID>NestedBlockDepth:TradeInputDataValidator.kt$TradeInputDataValidator$private fun equityTier( isStatefulOrder: Boolean, subaccount: Map&lt;String, Any&gt;?, configs: Map&lt;String, Any&gt;? ): EquityTier?</ID>
    <ID>NestedBlockDepth:TradeInputDataValidator.kt$TradeInputDataValidator$private fun orderCount( shouldCountStatefulOrders: Boolean, subaccount: Map&lt;String, Any&gt;?, ): Int</ID>
    <ID>NestedBlockDepth:TradeInputDataValidator.kt$TradeInputDataValidator$private fun validateLimitPrice( trade: Map&lt;String, Any&gt;, market: Map&lt;String, Any&gt;?, ): List&lt;Any&gt;?</ID>
    <ID>NestedBlockDepth:TradeInputDataValidator.kt$TradeInputDataValidator$private fun validateSize( trade: Map&lt;String, Any&gt;, market: Map&lt;String, Any&gt;?, ): List&lt;Any&gt;?</ID>
    <ID>NestedBlockDepth:TradeInputValidator.kt$TradeInputValidator$private fun change( parser: ParserProtocol, subaccount: Map&lt;String, Any&gt;?, trade: Map&lt;String, Any&gt;, ): PositionChange</ID>
    <ID>NestedBlockDepth:TradeTriggerPriceValidator.kt$TradeTriggerPriceValidator$override fun validateTrade( subaccount: Map&lt;String, Any&gt;?, market: Map&lt;String, Any&gt;?, configs: Map&lt;String, Any&gt;?, trade: Map&lt;String, Any&gt;, change: PositionChange, restricted: Boolean, environment: V4Environment?, ): List&lt;Any&gt;?</ID>
    <ID>NestedBlockDepth:TradingStateMachine+ClosePositionInput.kt$fun TradingStateMachine.closePosition( data: String?, type: ClosePositionInputField, subaccountNumber: Int ): StateResponse</ID>
    <ID>NestedBlockDepth:TradingStateMachine+TradeInput.kt$fun TradingStateMachine.trade( data: String?, type: TradeInputField?, subaccountNumber: Int, ): StateResponse</ID>
    <ID>NestedBlockDepth:TradingStateMachine+TransferInput.kt$fun TradingStateMachine.transfer( data: String?, type: TransferInputField?, subaccountNumber: Int = 0 ): StateResponse</ID>
    <ID>NestedBlockDepth:TradingStateMachine.kt$TradingStateMachine$private fun maxSubaccountNumber(): Int?</ID>
    <ID>NestedBlockDepth:TradingStateMachine.kt$TradingStateMachine$private fun recalculateStates(changes: StateChanges)</ID>
    <ID>NestedBlockDepth:TradingStateMachine.kt$TradingStateMachine$private fun update( state: PerpetualState?, changes: StateChanges, tokensInfo: Map&lt;String, TokenInfo&gt;, localizer: LocalizerProtocol?, ): PerpetualState</ID>
    <ID>NestedBlockDepth:TransferInput.kt$DepositInputOptions.Companion$internal fun create( existing: DepositInputOptions?, parser: ParserProtocol, data: Map&lt;*, *&gt;? ): DepositInputOptions?</ID>
    <ID>NestedBlockDepth:TransferInput.kt$WithdrawalInputOptions.Companion$internal fun create( existing: WithdrawalInputOptions?, parser: ParserProtocol, data: Map&lt;*, *&gt;? ): WithdrawalInputOptions?</ID>
    <ID>NestedBlockDepth:TransferInputCalculator.kt$TransferInputCalculator$private fun calculatedOptionsFromFields(fields: List&lt;Any&gt;?): Map&lt;String, Any&gt;?</ID>
    <ID>NestedBlockDepth:TriggerOrdersInputValidator.kt$TriggerOrdersInputValidator$private fun equityTier( subaccount: Map&lt;String, Any&gt;?, configs: Map&lt;String, Any&gt;? ): EquityTier?</ID>
    <ID>NestedBlockDepth:TriggerOrdersInputValidator.kt$TriggerOrdersInputValidator$private fun orderCount( subaccount: Map&lt;String, Any&gt;?, ): Int</ID>
    <ID>NestedBlockDepth:TriggerOrdersInputValidator.kt$TriggerOrdersInputValidator$private fun validateLimitPrice( triggerOrder: Map&lt;String, Any&gt;, ): List&lt;Any&gt;?</ID>
    <ID>NestedBlockDepth:TriggerOrdersInputValidator.kt$TriggerOrdersInputValidator$private fun validateSize( orderSize: Double?, market: Map&lt;String, Any&gt;?, ): List&lt;Any&gt;?</ID>
    <ID>NestedBlockDepth:V4StateManagerAdaptor.kt$V4StateManagerAdaptor$override fun calculateCurrentHeight(): Int?</ID>
    <ID>NestedBlockDepth:V4StateManagerAdaptor.kt$V4StateManagerAdaptor$override fun didUpdateStateForTransfer(data: String?, type: TransferInputField?)</ID>
    <ID>NestedBlockDepth:V4StateManagerAdaptor.kt$V4StateManagerAdaptor$private fun apiState( apiState: ApiState?, indexerState: NetworkState, validatorState: NetworkState, ): ApiState</ID>
    <ID>NestedBlockDepth:ValidationError.kt$ErrorString.Companion$internal fun create( existing: ErrorString?, parser: ParserProtocol, data: Map&lt;*, *&gt;? ): ErrorString?</ID>
    <ID>NestedBlockDepth:ValidationError.kt$ValidationError.Companion$internal fun create( existing: IList&lt;ValidationError&gt;?, parser: ParserProtocol, data: List&lt;Any&gt;? ): IList&lt;ValidationError&gt;?</ID>
    <ID>NestedBlockDepth:ValidationError.kt$ValidationError.Companion$internal fun create( existing: ValidationError?, parser: ParserProtocol, data: Map&lt;*, *&gt;? ): ValidationError?</ID>
    <ID>NestedBlockDepth:Wallet.kt$LaunchIncentivePoints.Companion$internal fun create( existing: LaunchIncentivePoints?, parser: ParserProtocol, data: Map&lt;String, Any&gt;? ): LaunchIncentivePoints?</ID>
    <ID>ReturnCount:Account.kt$SubaccountPendingPosition.Companion$internal fun create( existing: SubaccountPendingPosition?, parser: ParserProtocol, data: Map&lt;String, Any&gt;?, ): SubaccountPendingPosition?</ID>
    <ID>ReturnCount:Account.kt$SubaccountTransfer.Companion$internal fun create( existing: SubaccountTransfer?, parser: ParserProtocol, data: Map&lt;*, *&gt;?, ): SubaccountTransfer?</ID>
    <ID>ReturnCount:AsyncAbacusStateManager.kt$AsyncAbacusStateManager$private fun parseEnvironments(response: String): Boolean</ID>
    <ID>ReturnCount:AsyncAbacusStateManagerV2.kt$AsyncAbacusStateManagerV2$private fun parseEnvironments(response: String): Boolean</ID>
    <ID>ReturnCount:BaseProcessor.kt$BaseProcessor$private fun value(input: Map&lt;*, *&gt;, key: String, type: String): Any?</ID>
    <ID>ReturnCount:Configs.kt$WithdrawalCapacity.Companion$internal fun create( existing: WithdrawalCapacity?, parser: ParserProtocol, data: Map&lt;*, *&gt;? ): WithdrawalCapacity?</ID>
    <ID>ReturnCount:ConnectionsSupervisor.kt$ConnectionsSupervisor$private fun connectChain(validatorUrl: String, callback: (successful: Boolean) -&gt; Unit)</ID>
    <ID>ReturnCount:DynamicLocalizer.kt$DynamicLocalizer$override fun localize( path: String, paramsAsJson: String?, ): String</ID>
    <ID>ReturnCount:Enviroment.kt$AppRequirements.Companion$fun parse( data: Map&lt;String, Any&gt;?, parser: ParserProtocol, localizer: LocalizerProtocol? ): AppRequirements?</ID>
    <ID>ReturnCount:Enviroment.kt$EnvironmentEndpoints.Companion$fun parse( data: Map&lt;String, Any&gt;, parser: ParserProtocol, ): EnvironmentEndpoints?</ID>
    <ID>ReturnCount:Enviroment.kt$EnvironmentGovernance.Companion$fun parse( data: Map&lt;String, Any&gt;?, parser: ParserProtocol, ): EnvironmentGovernance?</ID>
    <ID>ReturnCount:Enviroment.kt$EnvironmentGovernanceNewMarketProposal.Companion$fun parse( data: Map&lt;String, Any&gt;?, parser: ParserProtocol, ): EnvironmentGovernanceNewMarketProposal?</ID>
    <ID>ReturnCount:Enviroment.kt$IndexerURIs.Companion$fun parse( data: Map&lt;String, Any&gt;, parser: ParserProtocol, ): IndexerURIs?</ID>
    <ID>ReturnCount:Enviroment.kt$TokenInfo.Companion$fun parse( data: Map&lt;String, Any&gt;, parser: ParserProtocol, defaultDecimals: Int, ): TokenInfo?</ID>
    <ID>ReturnCount:Enviroment.kt$V4Environment.Companion$fun parse( id: String, data: Map&lt;String, Any&gt;, parser: ParserProtocol, deploymentUri: String, localizer: LocalizerProtocol?, tokensData: Map&lt;String, Any&gt;?, linksData: Map&lt;String, Any&gt;?, walletsData: Map&lt;String, Any&gt;?, governanceData: Map&lt;String, Any&gt;?, ): V4Environment?</ID>
    <ID>ReturnCount:Enviroment.kt$WalletConnectClient.Companion$fun parse( data: Map&lt;String, Any&gt;?, parser: ParserProtocol, deploymentUri: String, ): WalletConnectClient?</ID>
    <ID>ReturnCount:Formatter.kt$Formatter$private fun defaultPrice(value: Double?, tickSize: String?): String?</ID>
    <ID>ReturnCount:GoodTil.kt$GoodTil.Companion$internal fun duration(goodTil: Map&lt;String, Any&gt;?, parser: ParserProtocol): Duration?</ID>
    <ID>ReturnCount:GoodTil.kt$GoodTil.Companion$internal fun duration(goodTil: TradeInputGoodUntil?): Duration?</ID>
    <ID>ReturnCount:InputValidator.kt$InputValidator$fun validate( wallet: Map&lt;String, Any&gt;?, user: Map&lt;String, Any&gt;?, subaccount: Map&lt;String, Any&gt;?, markets: Map&lt;String, Any&gt;?, input: Map&lt;String, Any&gt;?, configs: Map&lt;String, Any&gt;?, currentBlockAndHeight: BlockAndTime?, environment: V4Environment?, ): Map&lt;String, Any&gt;?</ID>
    <ID>ReturnCount:JsonEncoder.kt$JsonEncoder$internal fun encode(element: Any?): String</ID>
    <ID>ReturnCount:JsonEncoder.kt$JsonEncoder$private fun string(element: Any): String?</ID>
    <ID>ReturnCount:LaunchIncentive.kt$LaunchIncentive.Companion$internal fun create( existing: LaunchIncentive?, parser: ParserProtocol, data: Map&lt;String, Any&gt;?, ): LaunchIncentive?</ID>
    <ID>ReturnCount:LaunchIncentive.kt$LaunchIncentiveSeason.Companion$internal fun create( existing: LaunchIncentiveSeason?, parser: ParserProtocol, data: Map&lt;String, Any&gt;?, ): LaunchIncentiveSeason?</ID>
    <ID>ReturnCount:LaunchIncentiveProcessor.kt$LaunchIncentiveProcessor$internal fun receivedSeasons( existing: Map&lt;String, Any&gt;?, payload: Map&lt;String, Any&gt; ): Map&lt;String, Any&gt;?</ID>
    <ID>ReturnCount:Market.kt$MarketConfigs.Companion$internal fun create( existing: MarketConfigs?, parser: ParserProtocol, data: Map&lt;String, Any&gt;, ): MarketConfigs?</ID>
    <ID>ReturnCount:Market.kt$MarketConfigsV4.Companion$internal fun create( existing: MarketConfigsV4?, parser: ParserProtocol, data: Map&lt;String, Any&gt;?, ): MarketConfigsV4?</ID>
    <ID>ReturnCount:Market.kt$MarketOrderbook.Companion$internal fun create( existing: MarketOrderbook?, parser: ParserProtocol, data: Map&lt;*, *&gt;?, ): MarketOrderbook?</ID>
    <ID>ReturnCount:Market.kt$PerpetualMarket.Companion$internal fun create( existing: PerpetualMarket?, parser: ParserProtocol, data: Map&lt;String, Any&gt;, assets: Map&lt;String, Any&gt;?, resetOrderbook: Boolean, resetTrades: Boolean, ): PerpetualMarket?</ID>
    <ID>ReturnCount:MarketCalculator.kt$MarketCalculator$private fun calculateMarketCaps( market: Map&lt;String, Any&gt;, assets: Map&lt;String, Any&gt; ): Map&lt;String, Any&gt;</ID>
    <ID>ReturnCount:MarketProcessor.kt$MarketProcessor$internal fun receivedCandles( market: Map&lt;String, Any&gt;, payload: List&lt;Any&gt;, ): Map&lt;String, Any&gt;</ID>
    <ID>ReturnCount:MarketSupervisor.kt$MarketSupervisor$private fun retrieveCandles()</ID>
    <ID>ReturnCount:MarketsProcessor.kt$MarketsProcessor$internal fun receivedCandles( existing: Map&lt;String, Any&gt;?, payload: Map&lt;String, Any&gt; ): Map&lt;String, Any&gt;?</ID>
    <ID>ReturnCount:NetworkHelper.kt$NetworkHelper$internal fun parseTransactionResponse(response: String?): ParsingError?</ID>
    <ID>ReturnCount:NotificationsProvider.kt$NotificationsProvider$private fun createFillNotification( stateMachine: TradingStateMachine, fillsForOrder: IList&lt;SubaccountFill&gt;, order: SubaccountOrder, ): Notification?</ID>
    <ID>ReturnCount:NotificationsProvider.kt$NotificationsProvider$private fun createNotificationForFill( stateMachine: TradingStateMachine, fill: SubaccountFill, ): Notification?</ID>
    <ID>ReturnCount:NotificationsProvider.kt$NotificationsProvider$private fun createOrderStatusNotification( stateMachine: TradingStateMachine, order: SubaccountOrder, ): Notification?</ID>
    <ID>ReturnCount:OrderProcessor.kt$OrderProcessor$private fun shouldUpdate(existing: Map&lt;String, Any&gt;?, payload: Map&lt;String, Any&gt;): Boolean</ID>
    <ID>ReturnCount:Parser.kt$Parser$override fun asBool(data: Any?): Boolean?</ID>
    <ID>ReturnCount:Parser.kt$Parser$override fun asDecimal(data: Any?): BigDecimal?</ID>
    <ID>ReturnCount:Parser.kt$Parser$override fun asDouble(data: Any?): Double?</ID>
    <ID>ReturnCount:Parser.kt$Parser$override fun asInt(data: Any?): Int?</ID>
    <ID>ReturnCount:Parser.kt$Parser$override fun asList(data: Any?): IList&lt;Any&gt;?</ID>
    <ID>ReturnCount:Parser.kt$Parser$override fun asLong(data: Any?): Long?</ID>
    <ID>ReturnCount:Parser.kt$Parser$override fun asMap(data: Any?): IMap&lt;String, Any&gt;?</ID>
    <ID>ReturnCount:Parser.kt$Parser$override fun asNativeList(data: Any?): List&lt;Any&gt;?</ID>
    <ID>ReturnCount:Parser.kt$Parser$override fun asNativeMap(data: Any?): Map&lt;String, Any&gt;?</ID>
    <ID>ReturnCount:Parser.kt$Parser$override fun asString(data: Any?): String?</ID>
    <ID>ReturnCount:Parser.kt$Parser$override fun asStrings(data: Any?): IList&lt;String&gt;?</ID>
    <ID>ReturnCount:Parser.kt$Parser$private fun value(data: Any?, path: IMutableList&lt;String&gt;): Any?</ID>
    <ID>ReturnCount:PerpetualPositionProcessor.kt$PerpetualPositionProcessor$private fun side(size: Double?): String</ID>
    <ID>ReturnCount:StateManagerAdaptor.kt$StateManagerAdaptor$@Throws(Exception::class) private fun socket( payload: IMap&lt;String, Any&gt;, )</ID>
    <ID>ReturnCount:StateManagerAdaptor.kt$StateManagerAdaptor$private fun maybeRetrieveMarketCandles()</ID>
    <ID>ReturnCount:StateManagerConfigs.kt$StateManagerConfigs$fun privateApiUrl(type: String): String?</ID>
    <ID>ReturnCount:StateManagerConfigs.kt$StateManagerConfigs$fun publicApiUrl(type: String): String?</ID>
    <ID>ReturnCount:StateManagerConfigs.kt$StateManagerConfigs$fun websocketUrl(): String?</ID>
    <ID>ReturnCount:String+Utils.kt$fun String.toDydxAddress(): String?</ID>
    <ID>ReturnCount:String+Utils.kt$fun String.toNobleAddress(): String?</ID>
    <ID>ReturnCount:StringHelper.kt$StringHelper.Companion$private fun formatNumericString(string: String, decimals: Int? = null): String</ID>
    <ID>ReturnCount:SubaccountSupervisor.kt$SubaccountSupervisor$internal fun getChildSubaccountNumberForIsolatedMarginTrade(marketId: String): Int</ID>
    <ID>ReturnCount:SubaccountSupervisor.kt$SubaccountSupervisor$private fun marketInfo(marketId: String): PlaceOrderMarketInfo?</ID>
    <ID>ReturnCount:SubaccountTransformer.kt$SubaccountTransformer$private fun deltaFromTrade( parser: ParserProtocol, trade: Map&lt;String, Any&gt;, market: Map&lt;String, Any&gt;?, usePessimisticCollateralCheck: Boolean, useOptimisticCollateralCheck: Boolean, ): Map&lt;String, Any&gt;?</ID>
    <ID>ReturnCount:SubaccountTransformer.kt$SubaccountTransformer$private fun executionPrice( oraclePrice: Double?, limitPrice: Double?, isBuying: Boolean, usePessimisticPrice: Boolean, useOptimisticPrice: Boolean, ): Double?</ID>
    <ID>ReturnCount:TradeAccountStateValidator.kt$TradeAccountStateValidator$private fun fillsExistingOrder( parser: ParserProtocol, trade: Map&lt;String, Any&gt;, orders: Map&lt;String, Any&gt;?, ): Boolean</ID>
    <ID>ReturnCount:TradeAccountStateValidator.kt$TradeAccountStateValidator$private fun positionOverleveragedPostAllOrders( parser: ParserProtocol, position: Map&lt;String, Any&gt;?, ): Boolean</ID>
    <ID>ReturnCount:TradeBracketOrdersValidator.kt$TradeBracketOrdersValidator$override fun validateTrade( subaccount: Map&lt;String, Any&gt;?, market: Map&lt;String, Any&gt;?, configs: Map&lt;String, Any&gt;?, trade: Map&lt;String, Any&gt;, change: PositionChange, restricted: Boolean, environment: V4Environment?, ): List&lt;Any&gt;?</ID>
    <ID>ReturnCount:TradeInputCalculator.kt$TradeInputCalculator$private fun calculateMarketOrder( trade: Map&lt;String, Any&gt;, market: Map&lt;String, Any&gt;?, subaccount: Map&lt;String, Any&gt;?, user: Map&lt;String, Any&gt;, isBuying: Boolean, input: String, ): Map&lt;String, Any&gt;?</ID>
    <ID>ReturnCount:TradeInputCalculator.kt$TradeInputCalculator$private fun calculateMarketOrderFromLeverage( leverage: Double, market: Map&lt;String, Any&gt;?, subaccount: Map&lt;String, Any&gt;?, user: Map&lt;String, Any&gt;, ): Map&lt;String, Any&gt;?</ID>
    <ID>ReturnCount:TradeInputCalculator.kt$TradeInputCalculator$private fun calculatePositionMargin( trade: Map&lt;String, Any&gt;, subaccount: Map&lt;String, Any&gt;?, market: Map&lt;String, Any&gt;? ): Double?</ID>
    <ID>ReturnCount:TradeInputCalculator.kt$TradeInputCalculator$private fun calculateSize( trade: Map&lt;String, Any&gt;, subaccount: Map&lt;String, Any&gt;?, market: Map&lt;String, Any&gt;?, ): MutableMap&lt;String, Any&gt;</ID>
    <ID>ReturnCount:TradeInputCalculator.kt$TradeInputCalculator$private fun maxLeverage( subaccount: Map&lt;String, Any&gt;?, market: Map&lt;String, Any&gt;? ): Double?</ID>
    <ID>ReturnCount:TradeInputCalculator.kt$TradeInputCalculator$private fun maxLeverageFromPosition( position: Map&lt;String, Any&gt;?, market: Map&lt;String, Any&gt;?, ): Double?</ID>
    <ID>ReturnCount:TradeInputCalculator.kt$TradeInputCalculator$private fun nonMarketOrderPrice( prices: Map&lt;String, Any&gt;?, market: Map&lt;String, Any&gt;?, type: String, isBuying: Boolean, ): Double?</ID>
    <ID>ReturnCount:TradeInputCalculator.kt$TradeInputCalculator$private fun side(marketOrder: Map&lt;String, Any&gt;, orderbook: Map&lt;String, Any&gt;): String?</ID>
    <ID>ReturnCount:TradeInputDataValidator.kt$TradeInputDataValidator$private fun equityTier( isStatefulOrder: Boolean, subaccount: Map&lt;String, Any&gt;?, configs: Map&lt;String, Any&gt;? ): EquityTier?</ID>
    <ID>ReturnCount:TradeInputDataValidator.kt$TradeInputDataValidator$private fun validateLimitPrice( trade: Map&lt;String, Any&gt;, market: Map&lt;String, Any&gt;?, ): List&lt;Any&gt;?</ID>
    <ID>ReturnCount:TradeInputDataValidator.kt$TradeInputDataValidator$private fun validateSize( trade: Map&lt;String, Any&gt;, market: Map&lt;String, Any&gt;?, ): List&lt;Any&gt;?</ID>
    <ID>ReturnCount:TradeInputValidator.kt$TradeInputValidator$override fun validate( wallet: Map&lt;String, Any&gt;?, user: Map&lt;String, Any&gt;?, subaccount: Map&lt;String, Any&gt;?, markets: Map&lt;String, Any&gt;?, configs: Map&lt;String, Any&gt;?, currentBlockAndHeight: BlockAndTime?, transaction: Map&lt;String, Any&gt;, transactionType: String, environment: V4Environment?, ): List&lt;Any&gt;?</ID>
    <ID>ReturnCount:TradeInputValidator.kt$TradeInputValidator$private fun change( parser: ParserProtocol, subaccount: Map&lt;String, Any&gt;?, trade: Map&lt;String, Any&gt;, ): PositionChange</ID>
    <ID>ReturnCount:TradeMarketOrderInputValidator.kt$TradeMarketOrderInputValidator$private fun orderbookSlippage( trade: Map&lt;String, Any&gt;, restricted: Boolean ): Map&lt;String, Any&gt;?</ID>
    <ID>ReturnCount:TradePositionStateValidator.kt$TradePositionStateValidator$private fun validatePositionSize( position: Map&lt;String, Any&gt;?, market: Map&lt;String, Any&gt;?, ): Map&lt;String, Any&gt;?</ID>
    <ID>ReturnCount:TradeTriggerPriceValidator.kt$TradeTriggerPriceValidator$override fun validateTrade( subaccount: Map&lt;String, Any&gt;?, market: Map&lt;String, Any&gt;?, configs: Map&lt;String, Any&gt;?, trade: Map&lt;String, Any&gt;, change: PositionChange, restricted: Boolean, environment: V4Environment?, ): List&lt;Any&gt;?</ID>
    <ID>ReturnCount:TradingStateMachine+Account.kt$internal fun TradingStateMachine.findOrder( clientId: Int, subaccountNumber: Int, ): SubaccountOrder?</ID>
    <ID>ReturnCount:TradingStateMachine+Account.kt$internal fun TradingStateMachine.findOrder( orderId: String, subaccountNumber: Int, ): SubaccountOrder?</ID>
    <ID>ReturnCount:TradingStateMachine+Account.kt$internal fun TradingStateMachine.findOrderInData( orderId: String, subaccountNumber: Int, ): SubaccountOrder?</ID>
    <ID>ReturnCount:TradingStateMachine+TradeInput.kt$internal fun TradingStateMachine.tradeInMarket( marketId: String, subaccountNumber: Int, ): StateResponse</ID>
    <ID>ReturnCount:TradingStateMachine.kt$TradingStateMachine$fun setHistoricalPnlDays(days: Int, subaccountNumber: Int): StateResponse</ID>
    <ID>ReturnCount:TradingStateMachine.kt$TradingStateMachine$private fun calculateReceipt(input: Map&lt;String, Any&gt;): List&lt;String&gt;?</ID>
    <ID>ReturnCount:TriggerOrdersInputCalculator.kt$TriggerOrdersInputCalculator$private fun calculateTriggerPrices( triggerPrices: Map&lt;String, Any&gt;, position: Map&lt;String, Any&gt;, size: Double?, ): MutableMap&lt;String, Any&gt;</ID>
    <ID>ReturnCount:TriggerOrdersInputValidator.kt$TriggerOrdersInputValidator$override fun validate( wallet: Map&lt;String, Any&gt;?, user: Map&lt;String, Any&gt;?, subaccount: Map&lt;String, Any&gt;?, markets: Map&lt;String, Any&gt;?, configs: Map&lt;String, Any&gt;?, currentBlockAndHeight: BlockAndTime?, transaction: Map&lt;String, Any&gt;, transactionType: String, environment: V4Environment? ): List&lt;Any&gt;?</ID>
    <ID>ReturnCount:TriggerOrdersInputValidator.kt$TriggerOrdersInputValidator$private fun equityTier( subaccount: Map&lt;String, Any&gt;?, configs: Map&lt;String, Any&gt;? ): EquityTier?</ID>
    <ID>ReturnCount:TriggerOrdersInputValidator.kt$TriggerOrdersInputValidator$private fun validateLimitPrice( triggerOrder: Map&lt;String, Any&gt;, ): List&lt;Any&gt;?</ID>
    <ID>ReturnCount:TriggerOrdersInputValidator.kt$TriggerOrdersInputValidator$private fun validateSize( orderSize: Double?, market: Map&lt;String, Any&gt;?, ): List&lt;Any&gt;?</ID>
    <ID>ReturnCount:TriggerOrdersInputValidator.kt$TriggerOrdersInputValidator$private fun validateTriggerPrice( triggerOrder: Map&lt;String, Any&gt;, oraclePrice: Double, tickSize: String, ): List&lt;Any&gt;?</ID>
    <ID>ReturnCount:V4StateManagerAdaptor.kt$V4StateManagerAdaptor$override fun marketInfo(market: String): PlaceOrderMarketInfo?</ID>
    <ID>ReturnCount:V4StateManagerAdaptor.kt$V4StateManagerAdaptor$override fun parseTransactionResponse(response: String?): ParsingError?</ID>
    <ID>ReturnCount:V4StateManagerAdaptor.kt$V4StateManagerAdaptor$private fun connectChain(validatorUrl: String, callback: (successful: Boolean) -&gt; Unit)</ID>
    <ID>ReturnCount:V4StateManagerConfigs.kt$V4StateManagerConfigs$fun launchIncentiveUrl(type: String): String?</ID>
    <ID>ReturnCount:Wallet.kt$LaunchIncentivePoints.Companion$internal fun create( existing: LaunchIncentivePoints?, parser: ParserProtocol, data: Map&lt;String, Any&gt;? ): LaunchIncentivePoints?</ID>
    <ID>SwallowedException:Parser.kt$Parser$e: Exception</ID>
    <ID>SwallowedException:String+Utils.kt$e: Exception</ID>
    <ID>SwallowedException:TradingStateMachine+Wallet.kt$e: Exception</ID>
    <ID>ThrowingExceptionsWithoutMessageOrCause:OrderbookProcessor.kt$OrderbookProcessor$Exception()</ID>
    <ID>ThrowsCount:AccountsSupervisor.kt$AccountsSupervisor$private fun splitAddressAndSubaccountNumber(id: String?): Pair&lt;String, Int&gt;</ID>
    <ID>ThrowsCount:Bech32.kt$Bech32$fun decode(str: String): Bech32Data</ID>
    <ID>ThrowsCount:MarketSupervisor.kt$MarketSupervisor$internal fun receiveMarketCandlesChannelSocketData( info: SocketInfo, resolution: String, payload: IMap&lt;String, Any&gt; )</ID>
    <ID>ThrowsCount:MarketSupervisor.kt$MarketSupervisor$internal fun receiveMarketOrderbooksChannelSocketData( info: SocketInfo, payload: IMap&lt;String, Any&gt;, subaccountNumber: Int?, )</ID>
    <ID>ThrowsCount:MarketSupervisor.kt$MarketSupervisor$internal fun receiveMarketTradesChannelSocketData( info: SocketInfo, payload: IMap&lt;String, Any&gt;, )</ID>
    <ID>ThrowsCount:MarketsSupervisor.kt$MarketsSupervisor$internal fun receiveMarketsChannelSocketData( info: SocketInfo, payload: IMap&lt;String, Any&gt;, subaccountNumber: Int?, )</ID>
    <ID>ThrowsCount:OnboardingSupervisor.kt$OnboardingSupervisor$@Throws(Exception::class) fun subaccountTransferPayload(subaccountNumber: Int?): HumanReadableSubaccountTransferPayload</ID>
    <ID>ThrowsCount:OnboardingSupervisor.kt$OnboardingSupervisor$@Throws(Exception::class) fun transferNativeTokenPayload(subaccountNumber: Int?): HumanReadableTransferPayload</ID>
    <ID>ThrowsCount:StateManagerAdaptor.kt$StateManagerAdaptor$@Throws(Exception::class) fun cancelOrderPayload(orderId: String): HumanReadableCancelOrderPayload</ID>
    <ID>ThrowsCount:StateManagerAdaptor.kt$StateManagerAdaptor$@Throws(Exception::class) fun closePositionPayload(): HumanReadablePlaceOrderPayload</ID>
    <ID>ThrowsCount:StateManagerAdaptor.kt$StateManagerAdaptor$@Throws(Exception::class) fun depositPayload(): HumanReadableDepositPayload</ID>
    <ID>ThrowsCount:StateManagerAdaptor.kt$StateManagerAdaptor$@Throws(Exception::class) fun placeOrderPayload(): HumanReadablePlaceOrderPayload</ID>
    <ID>ThrowsCount:StateManagerAdaptor.kt$StateManagerAdaptor$@Throws(Exception::class) fun subaccountTransferPayload(): HumanReadableSubaccountTransferPayload</ID>
    <ID>ThrowsCount:StateManagerAdaptor.kt$StateManagerAdaptor$@Throws(Exception::class) fun transferNativeTokenPayload(): HumanReadableTransferPayload</ID>
    <ID>ThrowsCount:StateManagerAdaptor.kt$StateManagerAdaptor$@Throws(Exception::class) fun triggerOrdersPayload(): HumanReadableTriggerOrdersPayload</ID>
    <ID>ThrowsCount:StateManagerAdaptor.kt$StateManagerAdaptor$@Throws(Exception::class) fun withdrawPayload(): HumanReadableWithdrawPayload</ID>
    <ID>ThrowsCount:StateManagerAdaptor.kt$StateManagerAdaptor$@Throws(Exception::class) private fun socket( payload: IMap&lt;String, Any&gt;, )</ID>
    <ID>ThrowsCount:StateManagerAdaptor.kt$StateManagerAdaptor$private fun triggerOrderPayload(triggerOrder: TriggerOrder, subaccountNumber: Int, marketId: String): HumanReadablePlaceOrderPayload</ID>
    <ID>ThrowsCount:SubaccountSupervisor.kt$SubaccountSupervisor$@Throws(Exception::class) fun closePositionPayload(currentHeight: Int?): HumanReadablePlaceOrderPayload</ID>
    <ID>ThrowsCount:SubaccountSupervisor.kt$SubaccountSupervisor$@Throws(Exception::class) fun placeOrderPayload(currentHeight: Int?): HumanReadablePlaceOrderPayload</ID>
    <ID>ThrowsCount:SubaccountSupervisor.kt$SubaccountSupervisor$@Throws(Exception::class) fun subaccountTransferPayload(): HumanReadableSubaccountTransferPayload</ID>
    <ID>ThrowsCount:SubaccountSupervisor.kt$SubaccountSupervisor$internal fun receiveSubaccountChannelSocketData( info: SocketInfo, payload: IMap&lt;String, Any&gt;, height: BlockAndTime?, )</ID>
    <ID>ThrowsCount:SubaccountSupervisor.kt$SubaccountSupervisor$private fun triggerOrderPayload(triggerOrder: TriggerOrder, marketId: String, currentHeight: Int?): HumanReadablePlaceOrderPayload</ID>
    <ID>ThrowsCount:TradingStateMachine.kt$TradingStateMachine$@Throws(Exception::class) private fun socket( url: AbUrl, payload: Map&lt;String, Any&gt;, subaccountNumber: Int, height: BlockAndTime?, ): StateResponse</ID>
    <ID>TooGenericExceptionCaught:AsyncAbacusStateManager.kt$AsyncAbacusStateManager$e: Exception</ID>
    <ID>TooGenericExceptionCaught:AsyncAbacusStateManagerV2.kt$AsyncAbacusStateManagerV2$e: Exception</ID>
    <ID>TooGenericExceptionCaught:NetworkHelper.kt$NetworkHelper$e: Exception</ID>
    <ID>TooGenericExceptionCaught:Parser.kt$Parser$e: Exception</ID>
    <ID>TooGenericExceptionCaught:StateManagerAdaptor.kt$StateManagerAdaptor$e: Exception</ID>
    <ID>TooGenericExceptionCaught:String+Utils.kt$e: Exception</ID>
    <ID>TooGenericExceptionCaught:TradingStateMachine+Wallet.kt$e: Exception</ID>
    <ID>TooGenericExceptionCaught:TradingStateMachine.kt$TradingStateMachine$e: Exception</ID>
    <ID>TooGenericExceptionThrown:AccountSupervisor.kt$AccountSupervisor$throw Exception("Unexpected restriction value")</ID>
    <ID>TooGenericExceptionThrown:AsyncAbacusStateManager.kt$AsyncAbacusStateManager$throw Error("Either stateNotification or dataNotification need to be set")</ID>
    <ID>TooGenericExceptionThrown:AsyncAbacusStateManager.kt$AsyncAbacusStateManager$throw Error("IOImplementations.chain is not set")</ID>
    <ID>TooGenericExceptionThrown:AsyncAbacusStateManager.kt$AsyncAbacusStateManager$throw Error("IOImplementations.fileSystem is not set, used by Abacus localizer")</ID>
    <ID>TooGenericExceptionThrown:AsyncAbacusStateManager.kt$AsyncAbacusStateManager$throw Error("IOImplementations.rest is not set")</ID>
    <ID>TooGenericExceptionThrown:AsyncAbacusStateManager.kt$AsyncAbacusStateManager$throw Error("IOImplementations.threading is not set")</ID>
    <ID>TooGenericExceptionThrown:AsyncAbacusStateManager.kt$AsyncAbacusStateManager$throw Error("IOImplementations.timer is not set")</ID>
    <ID>TooGenericExceptionThrown:AsyncAbacusStateManager.kt$AsyncAbacusStateManager$throw Error("IOImplementations.webSocket is not set")</ID>
    <ID>TooGenericExceptionThrown:AsyncAbacusStateManager.kt$AsyncAbacusStateManager$throw Error("UIImplementations.localizer is not set")</ID>
    <ID>TooGenericExceptionThrown:AsyncAbacusStateManagerV2.kt$AsyncAbacusStateManagerV2$throw Error("Either stateNotification or dataNotification need to be set")</ID>
    <ID>TooGenericExceptionThrown:AsyncAbacusStateManagerV2.kt$AsyncAbacusStateManagerV2$throw Error("IOImplementations.chain is not set")</ID>
    <ID>TooGenericExceptionThrown:AsyncAbacusStateManagerV2.kt$AsyncAbacusStateManagerV2$throw Error("IOImplementations.fileSystem is not set, used by Abacus localizer")</ID>
    <ID>TooGenericExceptionThrown:AsyncAbacusStateManagerV2.kt$AsyncAbacusStateManagerV2$throw Error("IOImplementations.rest is not set")</ID>
    <ID>TooGenericExceptionThrown:AsyncAbacusStateManagerV2.kt$AsyncAbacusStateManagerV2$throw Error("IOImplementations.threading is not set")</ID>
    <ID>TooGenericExceptionThrown:AsyncAbacusStateManagerV2.kt$AsyncAbacusStateManagerV2$throw Error("IOImplementations.timer is not set")</ID>
    <ID>TooGenericExceptionThrown:AsyncAbacusStateManagerV2.kt$AsyncAbacusStateManagerV2$throw Error("IOImplementations.webSocket is not set")</ID>
    <ID>TooGenericExceptionThrown:AsyncAbacusStateManagerV2.kt$AsyncAbacusStateManagerV2$throw Error("UIImplementations.localizer is not set")</ID>
    <ID>TooGenericExceptionThrown:MarketSupervisor.kt$MarketSupervisor$throw Exception("candlesChannel is null")</ID>
    <ID>TooGenericExceptionThrown:MarketSupervisor.kt$MarketSupervisor$throw Exception("orderbook channel is null")</ID>
    <ID>TooGenericExceptionThrown:MarketSupervisor.kt$MarketSupervisor$throw Exception("trades channel is null")</ID>
    <ID>TooGenericExceptionThrown:MarketsSupervisor.kt$MarketsSupervisor$throw Exception("markets channel is null")</ID>
    <ID>TooGenericExceptionThrown:NetworkHelper.kt$NetworkHelper$throw Exception("chain is not DYDXChainTransactionsProtocol")</ID>
    <ID>TooGenericExceptionThrown:NetworkHelper.kt$NetworkHelper$throw Exception("chain query is null")</ID>
    <ID>TooGenericExceptionThrown:OnboardingSupervisor.kt$OnboardingSupervisor$throw Exception("Transfer is null")</ID>
    <ID>TooGenericExceptionThrown:OnboardingSupervisor.kt$OnboardingSupervisor$throw Exception("address is null")</ID>
    <ID>TooGenericExceptionThrown:OnboardingSupervisor.kt$OnboardingSupervisor$throw Exception("destination address is null")</ID>
    <ID>TooGenericExceptionThrown:OnboardingSupervisor.kt$OnboardingSupervisor$throw Exception("size is null")</ID>
    <ID>TooGenericExceptionThrown:OnboardingSupervisor.kt$OnboardingSupervisor$throw Exception("usdcSize is null")</ID>
    <ID>TooGenericExceptionThrown:OrderbookProcessor.kt$OrderbookProcessor$throw Exception()</ID>
    <ID>TooGenericExceptionThrown:StateManagerAdaptor.kt$StateManagerAdaptor$throw Exception("Transfer is null")</ID>
    <ID>TooGenericExceptionThrown:StateManagerAdaptor.kt$StateManagerAdaptor$throw Exception("Unexpected restriction value")</ID>
    <ID>TooGenericExceptionThrown:StateManagerAdaptor.kt$StateManagerAdaptor$throw Exception("address is null")</ID>
    <ID>TooGenericExceptionThrown:StateManagerAdaptor.kt$StateManagerAdaptor$throw Exception("clientId is null")</ID>
    <ID>TooGenericExceptionThrown:StateManagerAdaptor.kt$StateManagerAdaptor$throw Exception("clobPairId is null")</ID>
    <ID>TooGenericExceptionThrown:StateManagerAdaptor.kt$StateManagerAdaptor$throw Exception("destination address is null")</ID>
    <ID>TooGenericExceptionThrown:StateManagerAdaptor.kt$StateManagerAdaptor$throw Exception("goodTil is null")</ID>
    <ID>TooGenericExceptionThrown:StateManagerAdaptor.kt$StateManagerAdaptor$throw Exception("invalid duration")</ID>
    <ID>TooGenericExceptionThrown:StateManagerAdaptor.kt$StateManagerAdaptor$throw Exception("invalid triggerOrderType")</ID>
    <ID>TooGenericExceptionThrown:StateManagerAdaptor.kt$StateManagerAdaptor$throw Exception("market is null")</ID>
    <ID>TooGenericExceptionThrown:StateManagerAdaptor.kt$StateManagerAdaptor$throw Exception("marketId is null")</ID>
    <ID>TooGenericExceptionThrown:StateManagerAdaptor.kt$StateManagerAdaptor$throw Exception("order is null")</ID>
    <ID>TooGenericExceptionThrown:StateManagerAdaptor.kt$StateManagerAdaptor$throw Exception("orderFlags is null")</ID>
    <ID>TooGenericExceptionThrown:StateManagerAdaptor.kt$StateManagerAdaptor$throw Exception("orderbook channel is null")</ID>
    <ID>TooGenericExceptionThrown:StateManagerAdaptor.kt$StateManagerAdaptor$throw Exception("price is null")</ID>
    <ID>TooGenericExceptionThrown:StateManagerAdaptor.kt$StateManagerAdaptor$throw Exception("side is null")</ID>
    <ID>TooGenericExceptionThrown:StateManagerAdaptor.kt$StateManagerAdaptor$throw Exception("size is null")</ID>
    <ID>TooGenericExceptionThrown:StateManagerAdaptor.kt$StateManagerAdaptor$throw Exception("subaccount channel is null")</ID>
    <ID>TooGenericExceptionThrown:StateManagerAdaptor.kt$StateManagerAdaptor$throw Exception("subaccount is null")</ID>
    <ID>TooGenericExceptionThrown:StateManagerAdaptor.kt$StateManagerAdaptor$throw Exception("subaccountNumber is null")</ID>
    <ID>TooGenericExceptionThrown:StateManagerAdaptor.kt$StateManagerAdaptor$throw Exception("summary is null")</ID>
    <ID>TooGenericExceptionThrown:StateManagerAdaptor.kt$StateManagerAdaptor$throw Exception("summary.price is null")</ID>
    <ID>TooGenericExceptionThrown:StateManagerAdaptor.kt$StateManagerAdaptor$throw Exception("trades channel is null")</ID>
    <ID>TooGenericExceptionThrown:StateManagerAdaptor.kt$StateManagerAdaptor$throw Exception("triggerPrice is null")</ID>
    <ID>TooGenericExceptionThrown:StateManagerAdaptor.kt$StateManagerAdaptor$throw Exception("type is null")</ID>
    <ID>TooGenericExceptionThrown:StateManagerAdaptor.kt$StateManagerAdaptor$throw Exception("usdcSize is null")</ID>
    <ID>TooGenericExceptionThrown:SubaccountSupervisor.kt$SubaccountSupervisor$throw Exception("Transfer is null")</ID>
    <ID>TooGenericExceptionThrown:SubaccountSupervisor.kt$SubaccountSupervisor$throw Exception("destination address is null")</ID>
    <ID>TooGenericExceptionThrown:SubaccountSupervisor.kt$SubaccountSupervisor$throw Exception("goodTil is null")</ID>
    <ID>TooGenericExceptionThrown:SubaccountSupervisor.kt$SubaccountSupervisor$throw Exception("invalid duration")</ID>
    <ID>TooGenericExceptionThrown:SubaccountSupervisor.kt$SubaccountSupervisor$throw Exception("invalid triggerOrderType")</ID>
    <ID>TooGenericExceptionThrown:SubaccountSupervisor.kt$SubaccountSupervisor$throw Exception("marginMode is null")</ID>
    <ID>TooGenericExceptionThrown:SubaccountSupervisor.kt$SubaccountSupervisor$throw Exception("marketId is null")</ID>
    <ID>TooGenericExceptionThrown:SubaccountSupervisor.kt$SubaccountSupervisor$throw Exception("order is null")</ID>
    <ID>TooGenericExceptionThrown:SubaccountSupervisor.kt$SubaccountSupervisor$throw Exception("price is null")</ID>
    <ID>TooGenericExceptionThrown:SubaccountSupervisor.kt$SubaccountSupervisor$throw Exception("side is null")</ID>
    <ID>TooGenericExceptionThrown:SubaccountSupervisor.kt$SubaccountSupervisor$throw Exception("size is null")</ID>
    <ID>TooGenericExceptionThrown:SubaccountSupervisor.kt$SubaccountSupervisor$throw Exception("subaccount channel is null")</ID>
    <ID>TooGenericExceptionThrown:SubaccountSupervisor.kt$SubaccountSupervisor$throw Exception("subaccount is null")</ID>
    <ID>TooGenericExceptionThrown:SubaccountSupervisor.kt$SubaccountSupervisor$throw Exception("summary is null")</ID>
    <ID>TooGenericExceptionThrown:SubaccountSupervisor.kt$SubaccountSupervisor$throw Exception("summary.price is null")</ID>
    <ID>TooGenericExceptionThrown:SubaccountSupervisor.kt$SubaccountSupervisor$throw Exception("triggerPrice is null")</ID>
    <ID>TooGenericExceptionThrown:SubaccountSupervisor.kt$SubaccountSupervisor$throw Exception("type is null")</ID>
    <ID>TooGenericExceptionThrown:SubaccountSupervisor.kt$SubaccountSupervisor$throw Exception("usdcSize is null")</ID>
    <ID>TooGenericExceptionThrown:V4StateManagerAdaptor.kt$V4StateManagerAdaptor$throw Exception("candlesChannel is null")</ID>
    <ID>TooGenericExceptionThrown:V4StateManagerAdaptor.kt$V4StateManagerAdaptor$throw Exception("chain is not DYDXChainTransactionsProtocol")</ID>
    <ID>TooGenericExceptionThrown:V4StateManagerAdaptor.kt$V4StateManagerAdaptor$throw Exception("chain query is null")</ID>
    <ID>UnusedParameter:AccountCalculator.kt$AccountCalculator$childSubaccountNumber: Int</ID>
    <ID>UnusedParameter:AccountInputValidator.kt$AccountInputValidator$parser: ParserProtocol</ID>
    <ID>UnusedParameter:AccountProcessor.kt$V4AccountDelegationsProcessor$existing: Map&lt;String, Any&gt;?</ID>
    <ID>UnusedParameter:AccountSupervisor.kt$AccountSupervisor$accountAddressRestriction: Restriction?</ID>
    <ID>UnusedParameter:AccountSupervisor.kt$AccountSupervisor$addressRestriction: UsageRestriction?</ID>
    <ID>UnusedParameter:AccountSupervisor.kt$AccountSupervisor$oldValue: String?</ID>
    <ID>UnusedParameter:AccountSupervisor.kt$AccountSupervisor$sourceAddressRestriction: Restriction?</ID>
    <ID>UnusedParameter:ConnectionStats.kt$ConnectionStats$indexerRestriction: UsageRestriction?</ID>
    <ID>UnusedParameter:Double+Utils.kt$ignore: Boolean</ID>
    <ID>UnusedParameter:LaunchIncentive.kt$LaunchIncentive.Companion$existing: LaunchIncentive?</ID>
    <ID>UnusedParameter:Market.kt$MarketOrderbook.Companion$ascending: Boolean</ID>
    <ID>UnusedParameter:Market.kt$MarketOrderbook.Companion$existing: IList&lt;OrderbookLine&gt;?</ID>
    <ID>UnusedParameter:Market.kt$PerpetualMarket.Companion$assets: Map&lt;String, Any&gt;?</ID>
    <ID>UnusedParameter:Market.kt$PerpetualMarket.Companion$resetOrderbook: Boolean</ID>
    <ID>UnusedParameter:Market.kt$PerpetualMarket.Companion$resetTrades: Boolean</ID>
    <ID>UnusedParameter:MarketCalculator.kt$MarketCalculator$keys: Set&lt;String&gt;? = null</ID>
    <ID>UnusedParameter:MarketsSupervisor.kt$MarketsSupervisor$oldValue: String</ID>
    <ID>UnusedParameter:NetworkHelper.kt$NetworkHelper$indexerRestriction: UsageRestriction?</ID>
    <ID>UnusedParameter:NotificationsProvider.kt$NotificationsProvider$stateMachine: TradingStateMachine</ID>
    <ID>UnusedParameter:OnboardingSupervisor.kt$OnboardingSupervisor$data: String?</ID>
    <ID>UnusedParameter:OnboardingSupervisor.kt$OnboardingSupervisor$requestId: String?</ID>
    <ID>UnusedParameter:OnboardingSupervisor.kt$OnboardingSupervisor$sourceAddress: String</ID>
    <ID>UnusedParameter:OrderbookProcessor.kt$OrderbookProcessor$stepSize: Double</ID>
    <ID>UnusedParameter:StateManagerAdaptor.kt$StateManagerAdaptor$accountAddressRestriction: Restriction?</ID>
    <ID>UnusedParameter:StateManagerAdaptor.kt$StateManagerAdaptor$addressRestriction: UsageRestriction?</ID>
    <ID>UnusedParameter:StateManagerAdaptor.kt$StateManagerAdaptor$oldValue: String?</ID>
    <ID>UnusedParameter:StateManagerAdaptor.kt$StateManagerAdaptor$sourceAddressRestriction: Restriction?</ID>
    <ID>UnusedParameter:SubaccountCalculator.kt$SubaccountCalculator$configs: Map&lt;String, Any&gt;?</ID>
    <ID>UnusedParameter:SubaccountCalculator.kt$SubaccountCalculator$notional: Double</ID>
    <ID>UnusedParameter:SubaccountCalculator.kt$SubaccountCalculator$size: Double?</ID>
    <ID>UnusedParameter:SubaccountCalculator.kt$SubaccountCalculator$subaccount: Map&lt;String, Any&gt;</ID>
    <ID>UnusedParameter:TradeAccountStateValidator.kt$TradeAccountStateValidator$parser: ParserProtocol</ID>
    <ID>UnusedParameter:TradeAccountStateValidator.kt$TradeAccountStateValidator$subaccount: Map&lt;String, Any&gt;</ID>
    <ID>UnusedParameter:TradeInputDataValidator.kt$TradeInputDataValidator$market: Map&lt;String, Any&gt;?</ID>
    <ID>UnusedParameter:TradeInputValidator.kt$TradeInputValidator$subaccount: Map&lt;String, Any&gt;?</ID>
    <ID>UnusedParameter:TradeInputValidator.kt$TradeInputValidator$trade: Map&lt;String, Any&gt;</ID>
    <ID>UnusedParameter:TradeMarketOrderInputValidator.kt$TradeMarketOrderInputValidator$markets: Map&lt;String, Any&gt;?</ID>
    <ID>UnusedParameter:TradePositionStateValidator.kt$TradePositionStateValidator$restricted: Boolean</ID>
    <ID>UnusedParameter:TradingStateMachine+Orderbook.kt$payload: Map&lt;String, Any&gt;</ID>
    <ID>UnusedParameter:TradingStateMachine+TriggerOrdersInput.kt$triggerOrders: Map&lt;String, Any&gt;</ID>
    <ID>UnusedParameter:TradingStateMachine+TriggerOrdersInput.kt$typeText: String?</ID>
    <ID>UnusedParameter:TradingStateMachine.kt$TradingStateMachine$height: Int?</ID>
    <ID>UnusedParameter:TradingStateMachine.kt$TradingStateMachine$markets: Map&lt;String, Any&gt;</ID>
    <ID>UnusedParameter:TradingStateMachine.kt$TradingStateMachine$markets: Map&lt;String, Any&gt;?</ID>
    <ID>UnusedParameter:TradingStateMachine.kt$TradingStateMachine$period: String? = null</ID>
    <ID>UnusedParameter:TradingStateMachine.kt$TradingStateMachine$url: AbUrl</ID>
    <ID>UnusedParameter:TransferInputValidator.kt$TransferInputValidator$subaccount: Map&lt;String, Any&gt;?</ID>
    <ID>UnusedParameter:TransferInputValidator.kt$TransferInputValidator$trade: Map&lt;String, Any&gt;</ID>
    <ID>UnusedParameter:V4StateManagerAdaptor.kt$V4StateManagerAdaptor$indexerRestriction: UsageRestriction?</ID>
    <ID>UnusedPrivateMember:Account.kt$Subaccount.Companion$private fun fundingPayments( parser: ParserProtocol, existing: IList&lt;SubaccountFundingPayment&gt;?, data: List&lt;*&gt;?, ): IList&lt;SubaccountFundingPayment&gt;?</ID>
    <ID>UnusedPrivateMember:Account.kt$Subaccount.Companion$private fun transfers( parser: ParserProtocol, existing: IList&lt;SubaccountTransfer&gt;?, data: List&lt;*&gt;?, ): IList&lt;SubaccountTransfer&gt;?</ID>
    <ID>UnusedPrivateMember:AsyncAbacusStateManager.kt$AsyncAbacusStateManager.Companion$private fun createIOImplementions(_nativeImplementations: ProtocolNativeImpFactory): IOImplementations</ID>
    <ID>UnusedPrivateMember:AsyncAbacusStateManager.kt$AsyncAbacusStateManager.Companion$private fun createUIImplemention(_nativeImplementations: ProtocolNativeImpFactory): UIImplementations</ID>
    <ID>UnusedPrivateMember:AsyncAbacusStateManagerV2.kt$AsyncAbacusStateManagerV2.Companion$private fun createIOImplementions(_nativeImplementations: ProtocolNativeImpFactory): IOImplementations</ID>
    <ID>UnusedPrivateMember:AsyncAbacusStateManagerV2.kt$AsyncAbacusStateManagerV2.Companion$private fun createUIImplemention(_nativeImplementations: ProtocolNativeImpFactory): UIImplementations</ID>
    <ID>UnusedPrivateMember:JsonEncoder.kt$JsonEncoder$private fun boolean(element: Any): Boolean?</ID>
    <ID>UnusedPrivateMember:OnboardingSupervisor.kt$OnboardingSupervisor$private fun transferNobleBalance(accountAddress: String, amount: BigDecimal)</ID>
    <ID>UnusedPrivateMember:OrderbookProcessor.kt$OrderbookProcessor$@Throws(Exception::class) private fun compareResults( result1: List&lt;Map&lt;String, Any&gt;&gt;, result2: List&lt;Map&lt;String, Any&gt;&gt; )</ID>
    <ID>UnusedPrivateMember:OrderbookProcessor.kt$OrderbookProcessor$private fun receivedChangesLinear( existing: List&lt;Map&lt;String, Any&gt;&gt;?, changes: List&lt;Any&gt;, offset: Long?, ascending: Boolean ): List&lt;Map&lt;String, Any&gt;&gt;</ID>
    <ID>UnusedPrivateMember:StateManagerAdaptor.kt$StateManagerAdaptor$private fun nextMinute(): Instant</ID>
    <ID>UnusedPrivateMember:StateManagerConfigs.kt$StateManagerConfigs$private fun faucetApiPath(type: String): String?</ID>
    <ID>UnusedPrivateMember:SubaccountSupervisor.kt$SubaccountSupervisor$private fun faucetBody(amount: Double): String?</ID>
    <ID>UnusedPrivateMember:SubaccountTransformer.kt$SubaccountTransformer$private fun adjustDeltaSize( size: Double, deltaSize: Double, reduceOnly: Boolean ): Double</ID>
    <ID>UnusedPrivateMember:TradeInputCalculator.kt$TradeInputCalculator$private fun marketOrderUsdcSize(marketOrder: Map&lt;String, Any&gt;): Double?</ID>
    <ID>UnusedPrivateMember:TradeInputCalculator.kt$TradeInputCalculator$private fun maxLeverage( subaccount: Map&lt;String, Any&gt;?, market: Map&lt;String, Any&gt;? ): Double?</ID>
    <ID>UnusedPrivateMember:TradeMarketOrderInputValidator.kt$TradeMarketOrderInputValidator$private fun accountRestricted(): Boolean</ID>
    <ID>UnusedPrivateMember:TradingStateMachine.kt$TradingStateMachine$private fun calculateAccount(subaccountNumbers: IList&lt;Int&gt;, period: CalculationPeriod)</ID>
    <ID>UnusedPrivateMember:TradingStateMachine.kt$TradingStateMachine$private fun groupedSubaccountFills(subaccountNumber: Int): IList&lt;Any&gt;?</ID>
    <ID>UnusedPrivateMember:TradingStateMachine.kt$TradingStateMachine$private fun groupedSubaccountFundingPayments(subaccountNumber: Int): IList&lt;Any&gt;?</ID>
    <ID>UnusedPrivateMember:TradingStateMachine.kt$TradingStateMachine$private fun groupedSubaccountHistoricalPnl(subaccountNumber: Int): IList&lt;Any&gt;?</ID>
    <ID>UnusedPrivateMember:TradingStateMachine.kt$TradingStateMachine$private fun groupedSubaccountTransfers(subaccountNumber: Int): IList&lt;Any&gt;?</ID>
    <ID>UnusedPrivateMember:TransferInputCalculator.kt$TransferInputCalculator$private fun calculatedOptions(type: String): Map&lt;String, Any&gt;?</ID>
    <ID>UnusedPrivateMember:TransferInputValidator.kt$TransferInputValidator$private fun validateClosingOnly( subaccount: Map&lt;String, Any&gt;?, market: Map&lt;String, Any&gt;?, trade: Map&lt;String, Any&gt;, change: PositionChange, restricted: Boolean, ): Map&lt;String, Any&gt;?</ID>
    <ID>UnusedPrivateProperty:Account.kt$Subaccount.Companion$val ethereumeAddress = parser.asString(data["ethereumeAddress"])</ID>
    <ID>UnusedPrivateProperty:AccountProcessor.kt$V4AccountProcessor$val test = parser.value(payload, "subaccounts.0.tradingRewards")</ID>
    <ID>UnusedPrivateProperty:AsyncAbacusStateManager.kt$AsyncAbacusStateManager$private val documentationFile = ConfigFile.DOCUMENTATION</ID>
    <ID>UnusedPrivateProperty:AsyncAbacusStateManager.kt$AsyncAbacusStateManager$private val environmentsFile = ConfigFile.ENV</ID>
    <ID>UnusedPrivateProperty:AsyncAbacusStateManagerV2.kt$AsyncAbacusStateManagerV2$private val documentationFile = ConfigFile.DOCUMENTATION</ID>
    <ID>UnusedPrivateProperty:AsyncAbacusStateManagerV2.kt$AsyncAbacusStateManagerV2$private val environmentsFile = ConfigFile.ENV</ID>
    <ID>UnusedPrivateProperty:ConnectionStats.kt$ConnectionStats$private var indexerRestriction: UsageRestriction? = null set(value) { if (field !== value) { field = value didSetIndexerRestriction(field) } }</ID>
    <ID>UnusedPrivateProperty:Double+Utils.kt$i</ID>
    <ID>UnusedPrivateProperty:InputValidator.kt$InputValidator$private val errorTypeLookup = mapOf&lt;String, Int&gt;( "ERROR" to 0, "REQUIRED" to 1, "WARNING" to 2, )</ID>
    <ID>UnusedPrivateProperty:LaunchIncentiveProcessor.kt$LaunchIncentiveProcessor$private val pointsProcessor = LaunchIncentivePointsProcessor(parser = parser)</ID>
    <ID>UnusedPrivateProperty:OrderProcessor.kt$OrderProcessor$val status = parser.asString(existing["status"])</ID>
    <ID>UnusedPrivateProperty:Rounder.kt$Rounder.Companion$i</ID>
    <ID>UnusedPrivateProperty:StateManagerAdaptor.kt$StateManagerAdaptor$val transferType = transfer.type</ID>
    <ID>UnusedPrivateProperty:StringHelper.kt$StringHelper.Companion$i</ID>
    <ID>UnusedPrivateProperty:SubaccountSupervisor.kt$SubaccountSupervisor$val transferType = transfer.type</ID>
    <ID>UnusedPrivateProperty:TradeInput.kt$TradeInputOptions.Companion$private val typeOptionsArray = iListOf( SelectionOption( OrderType.limit.rawValue, null, "APP.TRADE.LIMIT_ORDER_SHORT", null, ), SelectionOption( OrderType.market.rawValue, null, "APP.TRADE.MARKET_ORDER_SHORT", null, ), SelectionOption(OrderType.stopLimit.rawValue, null, "APP.TRADE.STOP_LIMIT", null), SelectionOption(OrderType.stopMarket.rawValue, null, "APP.TRADE.STOP_MARKET", null), SelectionOption( OrderType.trailingStop.rawValue, null, "APP.TRADE.TRAILING_STOP", null, ), SelectionOption( OrderType.takeProfitLimit.rawValue, null, "APP.TRADE.TAKE_PROFIT", null, ), SelectionOption( OrderType.takeProfitMarket.rawValue, null, "APP.TRADE.TAKE_PROFIT_MARKET", null, ), )</ID>
    <ID>UnusedPrivateProperty:TradePositionStateValidator.kt$TradePositionStateValidator$val closeOnlyError = validateCloseOnly( market, change, )</ID>
    <ID>UnusedPrivateProperty:TradingStateMachine.kt$TradingStateMachine$val startTime = now - days.days</ID>
    <ID>UtilityClassWithPublicConstructor:AbacusHelper.kt$AbacusHelper</ID>
    <ID>UtilityClassWithPublicConstructor:GoodTil.kt$GoodTil</ID>
    <ID>UtilityClassWithPublicConstructor:MarketId.kt$MarketId</ID>
    <ID>UtilityClassWithPublicConstructor:Numeric.kt$Numeric</ID>
    <ID>UtilityClassWithPublicConstructor:OrderTypeProcessor.kt$OrderTypeProcessor</ID>
    <ID>UtilityClassWithPublicConstructor:ParsingHelper.kt$ParsingHelper</ID>
    <ID>UtilityClassWithPublicConstructor:ServerTime.kt$ServerTime</ID>
    <ID>UtilityClassWithPublicConstructor:StringHelper.kt$StringHelper</ID>
    <ID>UtilityClassWithPublicConstructor:SystemUtils.kt$SystemUtils</ID>
    <ID>UtilityClassWithPublicConstructor:V4TransactionErrors.kt$V4TransactionErrors</ID>
    <ID>VariableNaming:ConnectionStats.kt$ConnectionStats$@Suppress("PropertyName") private val MAX_NUM_BLOCK_DELAY = 15</ID>
    <ID>VariableNaming:Numeric.kt$Decimals$@Suppress("PropertyName") val NEGATIVE = (-1.0).toBigDecimal(null, mode)</ID>
    <ID>VariableNaming:Numeric.kt$Decimals$@Suppress("PropertyName") val ONE = (1.0).toBigDecimal(null, mode)</ID>
    <ID>VariableNaming:Numeric.kt$Decimals$@Suppress("PropertyName") val POSITIVE = (1.0).toBigDecimal(null, mode)</ID>
    <ID>VariableNaming:Numeric.kt$Decimals$@Suppress("PropertyName") val TEN = (10.0).toBigDecimal(null, mode)</ID>
    <ID>VariableNaming:Numeric.kt$Decimals$@Suppress("PropertyName") val ZERO = (0.0).toBigDecimal(null, mode)</ID>
    <ID>VariableNaming:Numeric.kt$Doubles$@Suppress("PropertyName") val NEGATIVE = -1.0</ID>
    <ID>VariableNaming:Numeric.kt$Doubles$@Suppress("PropertyName") val ONE = 1.0</ID>
    <ID>VariableNaming:Numeric.kt$Doubles$@Suppress("PropertyName") val POSITIVE = 1.0</ID>
    <ID>VariableNaming:Numeric.kt$Doubles$@Suppress("PropertyName") val TEN = 10.0</ID>
    <ID>VariableNaming:Numeric.kt$Doubles$@Suppress("PropertyName") val ZERO = 0.0</ID>
    <ID>VariableNaming:StateManagerAdaptor.kt$StateManagerAdaptor$@Suppress("LocalVariableName", "PropertyName") private val TRIGGER_ORDER_DEFAULT_DURATION_DAYS = 28.0</ID>
    <ID>VariableNaming:SubaccountSupervisor.kt$SubaccountSupervisor$@Suppress("LocalVariableName", "PropertyName") private val TRIGGER_ORDER_DEFAULT_DURATION_DAYS = 28.0</ID>
    <ID>VariableNaming:TradeInputCalculator.kt$TradeInputCalculator$@Suppress("LocalVariableName", "PropertyName") val FR = parser.asDouble(feeRate)!!</ID>
    <ID>VariableNaming:TradeInputCalculator.kt$TradeInputCalculator$@Suppress("LocalVariableName", "PropertyName") val LV = parser.asDouble(leverage)!!</ID>
    <ID>VariableNaming:TradeInputCalculator.kt$TradeInputCalculator$@Suppress("LocalVariableName", "PropertyName") val MP = entryPrice</ID>
    <ID>VariableNaming:TradeInputCalculator.kt$TradeInputCalculator$@Suppress("LocalVariableName", "PropertyName") val OR = parser.asDouble(oraclePrice)!!</ID>
    <ID>VariableNaming:TradeInputCalculator.kt$TradeInputCalculator$@Suppress("LocalVariableName", "PropertyName") val OS: Double = if (isBuying) Numeric.double.POSITIVE else Numeric.double.NEGATIVE</ID>
    <ID>VariableNaming:TradeInputCalculator.kt$TradeInputCalculator$@Suppress("LocalVariableName", "PropertyName") val X = ((LV * AE) - (SZ * OR)) / (OR + (OS * LV * MP * FR) - (LV * (OR - MP)))</ID>
    <ID>VariableNaming:TradeInputCalculator.kt$TradeInputCalculator$@Suppress("LocalVariableName", "PropertyName") var AE = parser.asDouble(equity)!!</ID>
    <ID>VariableNaming:TradeInputCalculator.kt$TradeInputCalculator$@Suppress("LocalVariableName", "PropertyName") var SZ = parser.asDouble(positionSize) ?: Numeric.double.ZERO</ID>
    <ID>VariableNaming:TradeMarketOrderInputValidator.kt$TradeMarketOrderInputValidator$@Suppress("LocalVariableName", "PropertyName") private val MARKET_ORDER_ERROR_SLIPPAGE = 0.1</ID>
    <ID>VariableNaming:TradeMarketOrderInputValidator.kt$TradeMarketOrderInputValidator$@Suppress("LocalVariableName", "PropertyName") private val MARKET_ORDER_WARNING_SLIPPAGE = 0.05</ID>
    <ID>VariableNaming:TradesProcessor.kt$TradesProcessor$@Suppress("PropertyName") private val LIMIT = 500</ID>
  </CurrentIssues>
</SmellBaseline>
